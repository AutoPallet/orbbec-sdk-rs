/* automatically generated by rust-bindgen 0.71.1 */

pub const __bool_true_false_are_defined: u32 = 1;
pub const false_: u32 = 0;
pub const true_: u32 = 1;
pub const _VCRT_COMPILER_PREPROCESSOR: u32 = 1;
pub const _SAL_VERSION: u32 = 20;
pub const __SAL_H_VERSION: u32 = 180000000;
pub const _USE_DECLSPECS_FOR_SAL: u32 = 0;
pub const _USE_ATTRIBUTES_FOR_SAL: u32 = 0;
pub const _CRT_PACKING: u32 = 8;
pub const _HAS_EXCEPTIONS: u32 = 1;
pub const _STL_LANG: u32 = 0;
pub const _HAS_CXX17: u32 = 0;
pub const _HAS_CXX20: u32 = 0;
pub const _HAS_CXX23: u32 = 0;
pub const _HAS_CXX26: u32 = 0;
pub const _HAS_NODISCARD: u32 = 0;
pub const WCHAR_MIN: u32 = 0;
pub const WCHAR_MAX: u32 = 65535;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 65535;
pub const OB_WIDTH_ANY: u32 = 0;
pub const OB_HEIGHT_ANY: u32 = 0;
pub const OB_FPS_ANY: u32 = 0;
pub const OB_PROFILE_DEFAULT: u32 = 0;
pub const OB_DEFAULT_STRIDE_BYTES: u32 = 0;
pub const OB_PATH_MAX: u32 = 1024;
pub type va_list = *mut ::std::os::raw::c_char;
unsafe extern "C" {
    pub fn __va_start(arg1: *mut *mut ::std::os::raw::c_char, ...);
}
pub type __vcrt_bool = bool;
pub type wchar_t = ::std::os::raw::c_ushort;
unsafe extern "C" {
    pub fn __security_init_cookie();
}
unsafe extern "C" {
    pub fn __security_check_cookie(_StackCookie: usize);
}
unsafe extern "C" {
    pub fn __report_gsfailure(_StackCookie: usize) -> !;
}
unsafe extern "C" {
    pub static mut __security_cookie: usize;
}
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_longlong;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulonglong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_int;
pub type int_fast32_t = ::std::os::raw::c_int;
pub type int_fast64_t = ::std::os::raw::c_longlong;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_uint;
pub type uint_fast32_t = ::std::os::raw::c_uint;
pub type uint_fast64_t = ::std::os::raw::c_ulonglong;
pub type intmax_t = ::std::os::raw::c_longlong;
pub type uintmax_t = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ob_context_t {
    _unused: [u8; 0],
}
pub type ob_context = ob_context_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ob_device_t {
    _unused: [u8; 0],
}
pub type ob_device = ob_device_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ob_device_info_t {
    _unused: [u8; 0],
}
pub type ob_device_info = ob_device_info_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ob_device_list_t {
    _unused: [u8; 0],
}
pub type ob_device_list = ob_device_list_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ob_record_device_t {
    _unused: [u8; 0],
}
pub type ob_record_device = ob_record_device_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ob_playback_device_t {
    _unused: [u8; 0],
}
pub type ob_playback_device = ob_playback_device_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ob_camera_param_list_t {
    _unused: [u8; 0],
}
pub type ob_camera_param_list = ob_camera_param_list_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ob_sensor_t {
    _unused: [u8; 0],
}
pub type ob_sensor = ob_sensor_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ob_sensor_list_t {
    _unused: [u8; 0],
}
pub type ob_sensor_list = ob_sensor_list_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ob_stream_profile_t {
    _unused: [u8; 0],
}
pub type ob_stream_profile = ob_stream_profile_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ob_stream_profile_list_t {
    _unused: [u8; 0],
}
pub type ob_stream_profile_list = ob_stream_profile_list_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ob_frame_t {
    _unused: [u8; 0],
}
pub type ob_frame = ob_frame_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ob_filter_t {
    _unused: [u8; 0],
}
pub type ob_filter = ob_filter_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ob_filter_list_t {
    _unused: [u8; 0],
}
pub type ob_filter_list = ob_filter_list_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ob_pipeline_t {
    _unused: [u8; 0],
}
pub type ob_pipeline = ob_pipeline_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ob_config_t {
    _unused: [u8; 0],
}
pub type ob_config = ob_config_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ob_depth_work_mode_list_t {
    _unused: [u8; 0],
}
pub type ob_depth_work_mode_list = ob_depth_work_mode_list_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ob_device_preset_list_t {
    _unused: [u8; 0],
}
pub type ob_device_preset_list = ob_device_preset_list_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ob_filter_config_schema_list_t {
    _unused: [u8; 0],
}
pub type ob_filter_config_schema_list = ob_filter_config_schema_list_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ob_device_frame_interleave_list_t {
    _unused: [u8; 0],
}
pub type ob_device_frame_interleave_list = ob_device_frame_interleave_list_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ob_preset_resolution_config_list_t {
    _unused: [u8; 0],
}
pub type ob_preset_resolution_config_list = ob_preset_resolution_config_list_t;
#[doc = "< no permission"]
pub const OBPermissionType_OB_PERMISSION_DENY: OBPermissionType = 0;
#[doc = "< can read"]
pub const OBPermissionType_OB_PERMISSION_READ: OBPermissionType = 1;
#[doc = "< can write"]
pub const OBPermissionType_OB_PERMISSION_WRITE: OBPermissionType = 2;
#[doc = "< can read and write"]
pub const OBPermissionType_OB_PERMISSION_READ_WRITE: OBPermissionType = 3;
#[doc = "< any situation above"]
pub const OBPermissionType_OB_PERMISSION_ANY: OBPermissionType = 255;
#[doc = " @brief the permission type of api or property"]
pub type OBPermissionType = i32;
#[doc = " @brief the permission type of api or property"]
pub use self::OBPermissionType as ob_permission_type;
#[doc = "< status ok"]
pub const OBStatus_OB_STATUS_OK: OBStatus = 0;
#[doc = "< status error"]
pub const OBStatus_OB_STATUS_ERROR: OBStatus = 1;
#[doc = " @brief error code"]
pub type OBStatus = i32;
#[doc = " @brief error code"]
pub use self::OBStatus as ob_status;
#[doc = "< debug"]
pub const OBLogSeverity_OB_LOG_SEVERITY_DEBUG: OBLogSeverity = 0;
#[doc = "< information"]
pub const OBLogSeverity_OB_LOG_SEVERITY_INFO: OBLogSeverity = 1;
#[doc = "< warning"]
pub const OBLogSeverity_OB_LOG_SEVERITY_WARN: OBLogSeverity = 2;
#[doc = "< error"]
pub const OBLogSeverity_OB_LOG_SEVERITY_ERROR: OBLogSeverity = 3;
#[doc = "< fatal error"]
pub const OBLogSeverity_OB_LOG_SEVERITY_FATAL: OBLogSeverity = 4;
#[doc = "< off (close LOG)"]
pub const OBLogSeverity_OB_LOG_SEVERITY_OFF: OBLogSeverity = 5;
#[doc = " @brief log level, the higher the level, the stronger the log filter"]
pub type OBLogSeverity = i32;
#[doc = " @brief log level, the higher the level, the stronger the log filter"]
pub use self::OBLogSeverity as ob_log_severity;
#[doc = " @brief log level, the higher the level, the stronger the log filter"]
pub use self::OBLogSeverity as DEVICE_LOG_SEVERITY_LEVEL;
#[doc = " @brief log level, the higher the level, the stronger the log filter"]
pub use self::OBLogSeverity as OBDeviceLogSeverityLevel;
#[doc = " @brief log level, the higher the level, the stronger the log filter"]
pub use self::OBLogSeverity as ob_device_log_severity_level;
#[doc = "< Unknown error, an error not clearly defined by the SDK"]
pub const OBExceptionType_OB_EXCEPTION_TYPE_UNKNOWN: OBExceptionType = 0;
pub const OBExceptionType_OB_EXCEPTION_STD_EXCEPTION: OBExceptionType = 1;
#[doc = "< Camera/Device has been disconnected, the camera/device is not available"]
pub const OBExceptionType_OB_EXCEPTION_TYPE_CAMERA_DISCONNECTED: OBExceptionType = 2;
#[doc = "< An error in the SDK adaptation platform layer, which means an error in the implementation of a specific system\nplatform"]
pub const OBExceptionType_OB_EXCEPTION_TYPE_PLATFORM: OBExceptionType = 3;
#[doc = "< Invalid parameter type exception, need to check input parameter"]
pub const OBExceptionType_OB_EXCEPTION_TYPE_INVALID_VALUE: OBExceptionType = 4;
#[doc = "< Wrong API call sequence, the API is called in the wrong order or the wrong parameter is passed"]
pub const OBExceptionType_OB_EXCEPTION_TYPE_WRONG_API_CALL_SEQUENCE: OBExceptionType = 5;
#[doc = "< SDK and firmware have not yet implemented this function or feature"]
pub const OBExceptionType_OB_EXCEPTION_TYPE_NOT_IMPLEMENTED: OBExceptionType = 6;
#[doc = "< SDK access IO exception error"]
pub const OBExceptionType_OB_EXCEPTION_TYPE_IO: OBExceptionType = 7;
#[doc = "< SDK access and use memory errors. For example, the frame fails to allocate memory"]
pub const OBExceptionType_OB_EXCEPTION_TYPE_MEMORY: OBExceptionType = 8;
#[doc = "< Unsupported operation type error by SDK or device"]
pub const OBExceptionType_OB_EXCEPTION_TYPE_UNSUPPORTED_OPERATION: OBExceptionType = 9;
#[doc = " @brief The exception types in the SDK, through the exception type, you can easily determine the specific type of error.\n For detailed error API interface functions and error logs, please refer to the information of ob_error"]
pub type OBExceptionType = i32;
#[doc = " @brief The exception types in the SDK, through the exception type, you can easily determine the specific type of error.\n For detailed error API interface functions and error logs, please refer to the information of ob_error"]
pub use self::OBExceptionType as ob_exception_type;
#[doc = " @brief The error class exposed by the SDK, users can get detailed error information according to the error"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ob_error {
    #[doc = "< Describe the status code of the error, as compatible with previous customer status code requirements"]
    pub status: ob_status,
    #[doc = "< Describe the detailed error log"]
    pub message: [::std::os::raw::c_char; 256usize],
    #[doc = "< Describe the name of the function where the error occurred"]
    pub function: [::std::os::raw::c_char; 256usize],
    #[doc = "< Describes the parameters passed to the function when an error occurs. Used to check whether the parameter is wrong"]
    pub args: [::std::os::raw::c_char; 256usize],
    #[doc = "< The description is the specific error type of the SDK"]
    pub exception_type: ob_exception_type,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ob_error"][::std::mem::size_of::<ob_error>() - 776usize];
    ["Alignment of ob_error"][::std::mem::align_of::<ob_error>() - 1usize];
    ["Offset of field: ob_error::status"][::std::mem::offset_of!(ob_error, status) - 0usize];
    ["Offset of field: ob_error::message"][::std::mem::offset_of!(ob_error, message) - 4usize];
    ["Offset of field: ob_error::function"][::std::mem::offset_of!(ob_error, function) - 260usize];
    ["Offset of field: ob_error::args"][::std::mem::offset_of!(ob_error, args) - 516usize];
    ["Offset of field: ob_error::exception_type"]
        [::std::mem::offset_of!(ob_error, exception_type) - 772usize];
};
#[doc = "< Unknown type sensor"]
pub const OBSensorType_OB_SENSOR_UNKNOWN: OBSensorType = 0;
#[doc = "< IR"]
pub const OBSensorType_OB_SENSOR_IR: OBSensorType = 1;
#[doc = "< Color"]
pub const OBSensorType_OB_SENSOR_COLOR: OBSensorType = 2;
#[doc = "< Depth"]
pub const OBSensorType_OB_SENSOR_DEPTH: OBSensorType = 3;
#[doc = "< Accel"]
pub const OBSensorType_OB_SENSOR_ACCEL: OBSensorType = 4;
#[doc = "< Gyro"]
pub const OBSensorType_OB_SENSOR_GYRO: OBSensorType = 5;
#[doc = "< left IR for stereo camera"]
pub const OBSensorType_OB_SENSOR_IR_LEFT: OBSensorType = 6;
#[doc = "< Right IR for stereo camera"]
pub const OBSensorType_OB_SENSOR_IR_RIGHT: OBSensorType = 7;
#[doc = "< Raw Phase"]
pub const OBSensorType_OB_SENSOR_RAW_PHASE: OBSensorType = 8;
#[doc = "< Confidence"]
pub const OBSensorType_OB_SENSOR_CONFIDENCE: OBSensorType = 9;
pub const OBSensorType_OB_SENSOR_TYPE_COUNT: OBSensorType = 10;
#[doc = " @brief Enumeration value describing the sensor type"]
pub type OBSensorType = i32;
#[doc = " @brief Enumeration value describing the sensor type"]
pub use self::OBSensorType as ob_sensor_type;
#[doc = "< Unknown type stream"]
pub const OBStreamType_OB_STREAM_UNKNOWN: OBStreamType = -1;
#[doc = "< Video stream (infrared, color, depth streams are all video streams)"]
pub const OBStreamType_OB_STREAM_VIDEO: OBStreamType = 0;
#[doc = "< IR stream"]
pub const OBStreamType_OB_STREAM_IR: OBStreamType = 1;
#[doc = "< color stream"]
pub const OBStreamType_OB_STREAM_COLOR: OBStreamType = 2;
#[doc = "< depth stream"]
pub const OBStreamType_OB_STREAM_DEPTH: OBStreamType = 3;
#[doc = "< Accelerometer data stream"]
pub const OBStreamType_OB_STREAM_ACCEL: OBStreamType = 4;
#[doc = "< Gyroscope data stream"]
pub const OBStreamType_OB_STREAM_GYRO: OBStreamType = 5;
#[doc = "< Left IR stream for stereo camera"]
pub const OBStreamType_OB_STREAM_IR_LEFT: OBStreamType = 6;
#[doc = "< Right IR stream for stereo camera"]
pub const OBStreamType_OB_STREAM_IR_RIGHT: OBStreamType = 7;
#[doc = "< RawPhase Stream"]
pub const OBStreamType_OB_STREAM_RAW_PHASE: OBStreamType = 8;
#[doc = "< Confidence Stream"]
pub const OBStreamType_OB_STREAM_CONFIDENCE: OBStreamType = 9;
#[doc = "< The total number of stream type,is not a valid stream type"]
pub const OBStreamType_OB_STREAM_TYPE_COUNT: OBStreamType = 10;
#[doc = " @brief Enumeration value describing the type of data stream"]
pub type OBStreamType = i32;
#[doc = " @brief Enumeration value describing the type of data stream"]
pub use self::OBStreamType as ob_stream_type;
#[doc = "< Unknown frame type"]
pub const OBFrameType_OB_FRAME_UNKNOWN: OBFrameType = -1;
#[doc = "< Video frame"]
pub const OBFrameType_OB_FRAME_VIDEO: OBFrameType = 0;
#[doc = "< IR frame"]
pub const OBFrameType_OB_FRAME_IR: OBFrameType = 1;
#[doc = "< Color frame"]
pub const OBFrameType_OB_FRAME_COLOR: OBFrameType = 2;
#[doc = "< Depth frame"]
pub const OBFrameType_OB_FRAME_DEPTH: OBFrameType = 3;
#[doc = "< Accelerometer data frame"]
pub const OBFrameType_OB_FRAME_ACCEL: OBFrameType = 4;
#[doc = "< Frame collection (internally contains a variety of data frames)"]
pub const OBFrameType_OB_FRAME_SET: OBFrameType = 5;
#[doc = "< Point cloud frame"]
pub const OBFrameType_OB_FRAME_POINTS: OBFrameType = 6;
#[doc = "< Gyroscope data frame"]
pub const OBFrameType_OB_FRAME_GYRO: OBFrameType = 7;
#[doc = "< Left IR frame for stereo camera"]
pub const OBFrameType_OB_FRAME_IR_LEFT: OBFrameType = 8;
#[doc = "< Right IR frame for stereo camera"]
pub const OBFrameType_OB_FRAME_IR_RIGHT: OBFrameType = 9;
#[doc = "< Raw Phase frame"]
pub const OBFrameType_OB_FRAME_RAW_PHASE: OBFrameType = 10;
#[doc = "< Confidence frame"]
pub const OBFrameType_OB_FRAME_CONFIDENCE: OBFrameType = 11;
#[doc = "< The total number of frame types, is not a valid frame type"]
pub const OBFrameType_OB_FRAME_TYPE_COUNT: OBFrameType = 12;
#[doc = " @brief Enumeration value describing the type of frame"]
pub type OBFrameType = i32;
#[doc = " @brief Enumeration value describing the type of frame"]
pub use self::OBFrameType as ob_frame_type;
pub const OBPixelType_OB_PIXEL_UNKNOWN: OBPixelType = -1;
pub const OBPixelType_OB_PIXEL_DEPTH: OBPixelType = 0;
pub const OBPixelType_OB_PIXEL_DISPARITY: OBPixelType = 2;
pub const OBPixelType_OB_PIXEL_RAW_PHASE: OBPixelType = 3;
pub const OBPixelType_OB_PIXEL_TOF_DEPTH: OBPixelType = 4;
#[doc = " @brief Enumeration value describing the pixel type of frame (usually used for depth frame)\n"]
pub type OBPixelType = i32;
#[doc = " @brief Enumeration value describing the pixel type of frame (usually used for depth frame)\n"]
pub use self::OBPixelType as ob_pixel_type;
#[doc = "< unknown format"]
pub const OBFormat_OB_FORMAT_UNKNOWN: OBFormat = -1;
#[doc = "< YUYV format"]
pub const OBFormat_OB_FORMAT_YUYV: OBFormat = 0;
#[doc = "< YUY2 format (the actual format is the same as YUYV)"]
pub const OBFormat_OB_FORMAT_YUY2: OBFormat = 1;
#[doc = "< UYVY format"]
pub const OBFormat_OB_FORMAT_UYVY: OBFormat = 2;
#[doc = "< NV12 format"]
pub const OBFormat_OB_FORMAT_NV12: OBFormat = 3;
#[doc = "< NV21 format"]
pub const OBFormat_OB_FORMAT_NV21: OBFormat = 4;
#[doc = "< MJPEG encoding format"]
pub const OBFormat_OB_FORMAT_MJPG: OBFormat = 5;
#[doc = "< H.264 encoding format"]
pub const OBFormat_OB_FORMAT_H264: OBFormat = 6;
#[doc = "< H.265 encoding format"]
pub const OBFormat_OB_FORMAT_H265: OBFormat = 7;
#[doc = "< Y16 format, 16-bit per pixel, single-channel"]
pub const OBFormat_OB_FORMAT_Y16: OBFormat = 8;
#[doc = "< Y8 format, 8-bit per pixel, single-channel"]
pub const OBFormat_OB_FORMAT_Y8: OBFormat = 9;
#[doc = "< Y10 format, 10-bit per pixel, single-channel(SDK will unpack into Y16 by default)"]
pub const OBFormat_OB_FORMAT_Y10: OBFormat = 10;
#[doc = "< Y11 format, 11-bit per pixel, single-channel (SDK will unpack into Y16 by default)"]
pub const OBFormat_OB_FORMAT_Y11: OBFormat = 11;
#[doc = "< Y12 format, 12-bit per pixel, single-channel(SDK will unpack into Y16 by default)"]
pub const OBFormat_OB_FORMAT_Y12: OBFormat = 12;
#[doc = "< GRAY (the actual format is the same as YUYV)"]
pub const OBFormat_OB_FORMAT_GRAY: OBFormat = 13;
#[doc = "< HEVC encoding format (the actual format is the same as H265)"]
pub const OBFormat_OB_FORMAT_HEVC: OBFormat = 14;
#[doc = "< I420 format"]
pub const OBFormat_OB_FORMAT_I420: OBFormat = 15;
#[doc = "< Acceleration data format"]
pub const OBFormat_OB_FORMAT_ACCEL: OBFormat = 16;
#[doc = "< Gyroscope data format"]
pub const OBFormat_OB_FORMAT_GYRO: OBFormat = 17;
#[doc = "< XYZ 3D coordinate point format, @ref OBPoint"]
pub const OBFormat_OB_FORMAT_POINT: OBFormat = 19;
#[doc = "< XYZ 3D coordinate point format with RGB information, @ref OBColorPoint"]
pub const OBFormat_OB_FORMAT_RGB_POINT: OBFormat = 20;
#[doc = "< RLE pressure test format (SDK will be unpacked into Y16 by default)"]
pub const OBFormat_OB_FORMAT_RLE: OBFormat = 21;
#[doc = "< RGB format (actual RGB888)"]
pub const OBFormat_OB_FORMAT_RGB: OBFormat = 22;
#[doc = "< BGR format (actual BGR888)"]
pub const OBFormat_OB_FORMAT_BGR: OBFormat = 23;
#[doc = "< Y14 format, 14-bit per pixel, single-channel (SDK will unpack into Y16 by default)"]
pub const OBFormat_OB_FORMAT_Y14: OBFormat = 24;
#[doc = "< BGRA format"]
pub const OBFormat_OB_FORMAT_BGRA: OBFormat = 25;
#[doc = "< Compression format"]
pub const OBFormat_OB_FORMAT_COMPRESSED: OBFormat = 26;
#[doc = "< RVL pressure test format (SDK will be unpacked into Y16 by default)"]
pub const OBFormat_OB_FORMAT_RVL: OBFormat = 27;
#[doc = "< Is same as Y16"]
pub const OBFormat_OB_FORMAT_Z16: OBFormat = 28;
#[doc = "< Is same as Y12, using for right ir stream"]
pub const OBFormat_OB_FORMAT_YV12: OBFormat = 29;
#[doc = "< Is same as Y8, using for right ir stream"]
pub const OBFormat_OB_FORMAT_BA81: OBFormat = 30;
#[doc = "< RGBA format"]
pub const OBFormat_OB_FORMAT_RGBA: OBFormat = 31;
#[doc = "< byr2 format"]
pub const OBFormat_OB_FORMAT_BYR2: OBFormat = 32;
#[doc = "< RAW16 format"]
pub const OBFormat_OB_FORMAT_RW16: OBFormat = 33;
#[doc = "<  Y12C4 format"]
pub const OBFormat_OB_FORMAT_Y12C4: OBFormat = 34;
#[doc = " @brief Enumeration value describing the pixel format"]
pub type OBFormat = i32;
#[doc = " @brief Enumeration value describing the pixel format"]
pub use self::OBFormat as ob_format;
#[doc = "< update completed, but some files were duplicated and ignored"]
pub const OBUpgradeState_STAT_DONE_WITH_DUPLICATES: OBUpgradeState = 6;
#[doc = "< Image file verifify success"]
pub const OBUpgradeState_STAT_VERIFY_SUCCESS: OBUpgradeState = 5;
#[doc = "< file transfer"]
pub const OBUpgradeState_STAT_FILE_TRANSFER: OBUpgradeState = 4;
#[doc = "< update completed"]
pub const OBUpgradeState_STAT_DONE: OBUpgradeState = 3;
#[doc = "< upgrade in process"]
pub const OBUpgradeState_STAT_IN_PROGRESS: OBUpgradeState = 2;
#[doc = "< start the upgrade"]
pub const OBUpgradeState_STAT_START: OBUpgradeState = 1;
#[doc = "< Image file verification"]
pub const OBUpgradeState_STAT_VERIFY_IMAGE: OBUpgradeState = 0;
#[doc = "< Verification failed"]
pub const OBUpgradeState_ERR_VERIFY: OBUpgradeState = -1;
#[doc = "< Program execution failed"]
pub const OBUpgradeState_ERR_PROGRAM: OBUpgradeState = -2;
#[doc = "< Flash parameter failed"]
pub const OBUpgradeState_ERR_ERASE: OBUpgradeState = -3;
#[doc = "< Flash type error"]
pub const OBUpgradeState_ERR_FLASH_TYPE: OBUpgradeState = -4;
#[doc = "< Image file size error"]
pub const OBUpgradeState_ERR_IMAGE_SIZE: OBUpgradeState = -5;
#[doc = "< other errors"]
pub const OBUpgradeState_ERR_OTHER: OBUpgradeState = -6;
#[doc = "< DDR access error"]
pub const OBUpgradeState_ERR_DDR: OBUpgradeState = -7;
#[doc = "< timeout error"]
pub const OBUpgradeState_ERR_TIMEOUT: OBUpgradeState = -8;
#[doc = "< Mismatch firmware error"]
pub const OBUpgradeState_ERR_MISMATCH: OBUpgradeState = -9;
#[doc = "< Unsupported device error"]
pub const OBUpgradeState_ERR_UNSUPPORT_DEV: OBUpgradeState = -10;
#[doc = "< invalid firmware/preset count"]
pub const OBUpgradeState_ERR_INVALID_COUNT: OBUpgradeState = -11;
#[doc = " @brief Enumeration value describing the firmware upgrade status"]
pub type OBUpgradeState = i32;
#[doc = " @brief Enumeration value describing the firmware upgrade status"]
pub use self::OBUpgradeState as OBFwUpdateState;
#[doc = " @brief Enumeration value describing the firmware upgrade status"]
pub use self::OBUpgradeState as ob_upgrade_state;
#[doc = " @brief Enumeration value describing the firmware upgrade status"]
pub use self::OBUpgradeState as ob_fw_update_state;
#[doc = "< File transfer"]
pub const OBFileTranState_FILE_TRAN_STAT_TRANSFER: OBFileTranState = 2;
#[doc = "< File transfer succeeded"]
pub const OBFileTranState_FILE_TRAN_STAT_DONE: OBFileTranState = 1;
#[doc = "< Preparing"]
pub const OBFileTranState_FILE_TRAN_STAT_PREPAR: OBFileTranState = 0;
#[doc = "< DDR access failed"]
pub const OBFileTranState_FILE_TRAN_ERR_DDR: OBFileTranState = -1;
#[doc = "< Insufficient target space error"]
pub const OBFileTranState_FILE_TRAN_ERR_NOT_ENOUGH_SPACE: OBFileTranState = -2;
#[doc = "< Destination path is not writable"]
pub const OBFileTranState_FILE_TRAN_ERR_PATH_NOT_WRITABLE: OBFileTranState = -3;
#[doc = "< MD5 checksum error"]
pub const OBFileTranState_FILE_TRAN_ERR_MD5_ERROR: OBFileTranState = -4;
#[doc = "< Write flash error"]
pub const OBFileTranState_FILE_TRAN_ERR_WRITE_FLASH_ERROR: OBFileTranState = -5;
#[doc = "< Timeout error"]
pub const OBFileTranState_FILE_TRAN_ERR_TIMEOUT: OBFileTranState = -6;
#[doc = " @brief Enumeration value describing the file transfer status"]
pub type OBFileTranState = i32;
#[doc = " @brief Enumeration value describing the file transfer status"]
pub use self::OBFileTranState as ob_file_tran_state;
#[doc = "< data verify done"]
pub const OBDataTranState_DATA_TRAN_STAT_VERIFY_DONE: OBDataTranState = 4;
#[doc = "< data transfer stoped"]
pub const OBDataTranState_DATA_TRAN_STAT_STOPPED: OBDataTranState = 3;
#[doc = "< data transfer completed"]
pub const OBDataTranState_DATA_TRAN_STAT_DONE: OBDataTranState = 2;
#[doc = "< data verifying"]
pub const OBDataTranState_DATA_TRAN_STAT_VERIFYING: OBDataTranState = 1;
#[doc = "< data transferring"]
pub const OBDataTranState_DATA_TRAN_STAT_TRANSFERRING: OBDataTranState = 0;
#[doc = "< Transmission is busy"]
pub const OBDataTranState_DATA_TRAN_ERR_BUSY: OBDataTranState = -1;
#[doc = "< Not supported"]
pub const OBDataTranState_DATA_TRAN_ERR_UNSUPPORTED: OBDataTranState = -2;
#[doc = "< Transfer failed"]
pub const OBDataTranState_DATA_TRAN_ERR_TRAN_FAILED: OBDataTranState = -3;
#[doc = "< Test failed"]
pub const OBDataTranState_DATA_TRAN_ERR_VERIFY_FAILED: OBDataTranState = -4;
#[doc = "< Other errors"]
pub const OBDataTranState_DATA_TRAN_ERR_OTHER: OBDataTranState = -5;
#[doc = " @brief Enumeration value describing the data transfer status"]
pub type OBDataTranState = i32;
#[doc = " @brief Enumeration value describing the data transfer status"]
pub use self::OBDataTranState as ob_data_tran_state;
#[doc = " @brief Structure for transmitting data blocks"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct OBDataChunk {
    #[doc = "< Pointer to current block data"]
    pub data: *mut u8,
    #[doc = "< Length of current block data"]
    pub size: u32,
    #[doc = "< Offset of current data block relative to complete data"]
    pub offset: u32,
    #[doc = "< Size of full data"]
    pub fullDataSize: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of OBDataChunk"][::std::mem::size_of::<OBDataChunk>() - 20usize];
    ["Alignment of OBDataChunk"][::std::mem::align_of::<OBDataChunk>() - 1usize];
    ["Offset of field: OBDataChunk::data"][::std::mem::offset_of!(OBDataChunk, data) - 0usize];
    ["Offset of field: OBDataChunk::size"][::std::mem::offset_of!(OBDataChunk, size) - 8usize];
    ["Offset of field: OBDataChunk::offset"][::std::mem::offset_of!(OBDataChunk, offset) - 12usize];
    ["Offset of field: OBDataChunk::fullDataSize"]
        [::std::mem::offset_of!(OBDataChunk, fullDataSize) - 16usize];
};
#[doc = " @brief Structure for transmitting data blocks"]
pub type ob_data_chunk = OBDataChunk;
#[doc = " @brief Structure for integer range"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct OBIntPropertyRange {
    #[doc = "< Current value"]
    pub cur: i32,
    #[doc = "< Maximum value"]
    pub max: i32,
    #[doc = "< Minimum value"]
    pub min: i32,
    #[doc = "< Step value"]
    pub step: i32,
    #[doc = "< Default value"]
    pub def: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of OBIntPropertyRange"][::std::mem::size_of::<OBIntPropertyRange>() - 20usize];
    ["Alignment of OBIntPropertyRange"][::std::mem::align_of::<OBIntPropertyRange>() - 1usize];
    ["Offset of field: OBIntPropertyRange::cur"]
        [::std::mem::offset_of!(OBIntPropertyRange, cur) - 0usize];
    ["Offset of field: OBIntPropertyRange::max"]
        [::std::mem::offset_of!(OBIntPropertyRange, max) - 4usize];
    ["Offset of field: OBIntPropertyRange::min"]
        [::std::mem::offset_of!(OBIntPropertyRange, min) - 8usize];
    ["Offset of field: OBIntPropertyRange::step"]
        [::std::mem::offset_of!(OBIntPropertyRange, step) - 12usize];
    ["Offset of field: OBIntPropertyRange::def"]
        [::std::mem::offset_of!(OBIntPropertyRange, def) - 16usize];
};
#[doc = " @brief Structure for integer range"]
pub type ob_int_property_range = OBIntPropertyRange;
#[doc = " @brief Structure for float range"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct OBFloatPropertyRange {
    #[doc = "< Current value"]
    pub cur: f32,
    #[doc = "< Maximum value"]
    pub max: f32,
    #[doc = "< Minimum value"]
    pub min: f32,
    #[doc = "< Step value"]
    pub step: f32,
    #[doc = "< Default value"]
    pub def: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of OBFloatPropertyRange"][::std::mem::size_of::<OBFloatPropertyRange>() - 20usize];
    ["Alignment of OBFloatPropertyRange"][::std::mem::align_of::<OBFloatPropertyRange>() - 1usize];
    ["Offset of field: OBFloatPropertyRange::cur"]
        [::std::mem::offset_of!(OBFloatPropertyRange, cur) - 0usize];
    ["Offset of field: OBFloatPropertyRange::max"]
        [::std::mem::offset_of!(OBFloatPropertyRange, max) - 4usize];
    ["Offset of field: OBFloatPropertyRange::min"]
        [::std::mem::offset_of!(OBFloatPropertyRange, min) - 8usize];
    ["Offset of field: OBFloatPropertyRange::step"]
        [::std::mem::offset_of!(OBFloatPropertyRange, step) - 12usize];
    ["Offset of field: OBFloatPropertyRange::def"]
        [::std::mem::offset_of!(OBFloatPropertyRange, def) - 16usize];
};
#[doc = " @brief Structure for float range"]
pub type ob_float_property_range = OBFloatPropertyRange;
#[doc = " @brief Structure for float range"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct OBUint16PropertyRange {
    #[doc = "< Current value"]
    pub cur: u16,
    #[doc = "< Maximum value"]
    pub max: u16,
    #[doc = "< Minimum value"]
    pub min: u16,
    #[doc = "< Step value"]
    pub step: u16,
    #[doc = "< Default value"]
    pub def: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of OBUint16PropertyRange"][::std::mem::size_of::<OBUint16PropertyRange>() - 10usize];
    ["Alignment of OBUint16PropertyRange"]
        [::std::mem::align_of::<OBUint16PropertyRange>() - 1usize];
    ["Offset of field: OBUint16PropertyRange::cur"]
        [::std::mem::offset_of!(OBUint16PropertyRange, cur) - 0usize];
    ["Offset of field: OBUint16PropertyRange::max"]
        [::std::mem::offset_of!(OBUint16PropertyRange, max) - 2usize];
    ["Offset of field: OBUint16PropertyRange::min"]
        [::std::mem::offset_of!(OBUint16PropertyRange, min) - 4usize];
    ["Offset of field: OBUint16PropertyRange::step"]
        [::std::mem::offset_of!(OBUint16PropertyRange, step) - 6usize];
    ["Offset of field: OBUint16PropertyRange::def"]
        [::std::mem::offset_of!(OBUint16PropertyRange, def) - 8usize];
};
#[doc = " @brief Structure for float range"]
pub type ob_uint16_property_range = OBUint16PropertyRange;
#[doc = " @brief Structure for float range"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OBUint8PropertyRange {
    #[doc = "< Current value"]
    pub cur: u8,
    #[doc = "< Maximum value"]
    pub max: u8,
    #[doc = "< Minimum value"]
    pub min: u8,
    #[doc = "< Step value"]
    pub step: u8,
    #[doc = "< Default value"]
    pub def: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of OBUint8PropertyRange"][::std::mem::size_of::<OBUint8PropertyRange>() - 5usize];
    ["Alignment of OBUint8PropertyRange"][::std::mem::align_of::<OBUint8PropertyRange>() - 1usize];
    ["Offset of field: OBUint8PropertyRange::cur"]
        [::std::mem::offset_of!(OBUint8PropertyRange, cur) - 0usize];
    ["Offset of field: OBUint8PropertyRange::max"]
        [::std::mem::offset_of!(OBUint8PropertyRange, max) - 1usize];
    ["Offset of field: OBUint8PropertyRange::min"]
        [::std::mem::offset_of!(OBUint8PropertyRange, min) - 2usize];
    ["Offset of field: OBUint8PropertyRange::step"]
        [::std::mem::offset_of!(OBUint8PropertyRange, step) - 3usize];
    ["Offset of field: OBUint8PropertyRange::def"]
        [::std::mem::offset_of!(OBUint8PropertyRange, def) - 4usize];
};
#[doc = " @brief Structure for float range"]
pub type ob_uint8_property_range = OBUint8PropertyRange;
#[doc = " @brief Structure for boolean range"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OBBoolPropertyRange {
    #[doc = "< Current value"]
    pub cur: bool,
    #[doc = "< Maximum value"]
    pub max: bool,
    #[doc = "< Minimum value"]
    pub min: bool,
    #[doc = "< Step value"]
    pub step: bool,
    #[doc = "< Default value"]
    pub def: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of OBBoolPropertyRange"][::std::mem::size_of::<OBBoolPropertyRange>() - 5usize];
    ["Alignment of OBBoolPropertyRange"][::std::mem::align_of::<OBBoolPropertyRange>() - 1usize];
    ["Offset of field: OBBoolPropertyRange::cur"]
        [::std::mem::offset_of!(OBBoolPropertyRange, cur) - 0usize];
    ["Offset of field: OBBoolPropertyRange::max"]
        [::std::mem::offset_of!(OBBoolPropertyRange, max) - 1usize];
    ["Offset of field: OBBoolPropertyRange::min"]
        [::std::mem::offset_of!(OBBoolPropertyRange, min) - 2usize];
    ["Offset of field: OBBoolPropertyRange::step"]
        [::std::mem::offset_of!(OBBoolPropertyRange, step) - 3usize];
    ["Offset of field: OBBoolPropertyRange::def"]
        [::std::mem::offset_of!(OBBoolPropertyRange, def) - 4usize];
};
#[doc = " @brief Structure for boolean range"]
pub type ob_bool_property_range = OBBoolPropertyRange;
#[doc = "< Rectilinear images. No distortion compensation required."]
pub const OBCameraDistortionModel_OB_DISTORTION_NONE: OBCameraDistortionModel = 0;
#[doc = "< Equivalent to Brown-Conrady distortion, except that tangential distortion is applied to radially distorted points"]
pub const OBCameraDistortionModel_OB_DISTORTION_MODIFIED_BROWN_CONRADY: OBCameraDistortionModel = 1;
#[doc = "< Equivalent to Brown-Conrady distortion, except undistorts image instead of distorting it"]
pub const OBCameraDistortionModel_OB_DISTORTION_INVERSE_BROWN_CONRADY: OBCameraDistortionModel = 2;
#[doc = "< Unmodified Brown-Conrady distortion model"]
pub const OBCameraDistortionModel_OB_DISTORTION_BROWN_CONRADY: OBCameraDistortionModel = 3;
#[doc = "< Unmodified Brown-Conrady distortion model with k6 supported"]
pub const OBCameraDistortionModel_OB_DISTORTION_BROWN_CONRADY_K6: OBCameraDistortionModel = 4;
#[doc = "< Kannala-Brandt distortion model"]
pub const OBCameraDistortionModel_OB_DISTORTION_KANNALA_BRANDT4: OBCameraDistortionModel = 5;
#[doc = " \\brief Distortion model: defines how pixel coordinates should be mapped to sensor coordinates."]
pub type OBCameraDistortionModel = i32;
#[doc = " \\brief Distortion model: defines how pixel coordinates should be mapped to sensor coordinates."]
pub use self::OBCameraDistortionModel as ob_camera_distortion_model;
#[doc = " @brief Structure for camera intrinsic parameters"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct OBCameraIntrinsic {
    #[doc = "< Focal length in x direction"]
    pub fx: f32,
    #[doc = "< Focal length in y direction"]
    pub fy: f32,
    #[doc = "< Optical center abscissa"]
    pub cx: f32,
    #[doc = "< Optical center ordinate"]
    pub cy: f32,
    #[doc = "< Image width"]
    pub width: i16,
    #[doc = "< Image height"]
    pub height: i16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of OBCameraIntrinsic"][::std::mem::size_of::<OBCameraIntrinsic>() - 20usize];
    ["Alignment of OBCameraIntrinsic"][::std::mem::align_of::<OBCameraIntrinsic>() - 1usize];
    ["Offset of field: OBCameraIntrinsic::fx"]
        [::std::mem::offset_of!(OBCameraIntrinsic, fx) - 0usize];
    ["Offset of field: OBCameraIntrinsic::fy"]
        [::std::mem::offset_of!(OBCameraIntrinsic, fy) - 4usize];
    ["Offset of field: OBCameraIntrinsic::cx"]
        [::std::mem::offset_of!(OBCameraIntrinsic, cx) - 8usize];
    ["Offset of field: OBCameraIntrinsic::cy"]
        [::std::mem::offset_of!(OBCameraIntrinsic, cy) - 12usize];
    ["Offset of field: OBCameraIntrinsic::width"]
        [::std::mem::offset_of!(OBCameraIntrinsic, width) - 16usize];
    ["Offset of field: OBCameraIntrinsic::height"]
        [::std::mem::offset_of!(OBCameraIntrinsic, height) - 18usize];
};
#[doc = " @brief Structure for camera intrinsic parameters"]
pub type ob_camera_intrinsic = OBCameraIntrinsic;
#[doc = " @brief Structure for accelerometer intrinsic parameters"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct OBAccelIntrinsic {
    #[doc = "< In-run bias instability"]
    pub noiseDensity: f64,
    #[doc = "< random walk"]
    pub randomWalk: f64,
    #[doc = "< reference temperature"]
    pub referenceTemp: f64,
    #[doc = "< bias for x, y, z axis"]
    pub bias: [f64; 3usize],
    #[doc = "< gravity direction for x, y, z axis"]
    pub gravity: [f64; 3usize],
    #[doc = "< scale factor and three-axis non-orthogonal error"]
    pub scaleMisalignment: [f64; 9usize],
    #[doc = "< linear temperature drift coefficient"]
    pub tempSlope: [f64; 9usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of OBAccelIntrinsic"][::std::mem::size_of::<OBAccelIntrinsic>() - 216usize];
    ["Alignment of OBAccelIntrinsic"][::std::mem::align_of::<OBAccelIntrinsic>() - 1usize];
    ["Offset of field: OBAccelIntrinsic::noiseDensity"]
        [::std::mem::offset_of!(OBAccelIntrinsic, noiseDensity) - 0usize];
    ["Offset of field: OBAccelIntrinsic::randomWalk"]
        [::std::mem::offset_of!(OBAccelIntrinsic, randomWalk) - 8usize];
    ["Offset of field: OBAccelIntrinsic::referenceTemp"]
        [::std::mem::offset_of!(OBAccelIntrinsic, referenceTemp) - 16usize];
    ["Offset of field: OBAccelIntrinsic::bias"]
        [::std::mem::offset_of!(OBAccelIntrinsic, bias) - 24usize];
    ["Offset of field: OBAccelIntrinsic::gravity"]
        [::std::mem::offset_of!(OBAccelIntrinsic, gravity) - 48usize];
    ["Offset of field: OBAccelIntrinsic::scaleMisalignment"]
        [::std::mem::offset_of!(OBAccelIntrinsic, scaleMisalignment) - 72usize];
    ["Offset of field: OBAccelIntrinsic::tempSlope"]
        [::std::mem::offset_of!(OBAccelIntrinsic, tempSlope) - 144usize];
};
#[doc = " @brief Structure for accelerometer intrinsic parameters"]
pub type ob_accel_intrinsic = OBAccelIntrinsic;
#[doc = " @brief Structure for gyroscope intrinsic parameters"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct OBGyroIntrinsic {
    #[doc = "< In-run bias instability"]
    pub noiseDensity: f64,
    #[doc = "< random walk"]
    pub randomWalk: f64,
    #[doc = "< reference temperature"]
    pub referenceTemp: f64,
    #[doc = "< bias for x, y, z axis"]
    pub bias: [f64; 3usize],
    #[doc = "< scale factor and three-axis non-orthogonal error"]
    pub scaleMisalignment: [f64; 9usize],
    #[doc = "< linear temperature drift coefficient"]
    pub tempSlope: [f64; 9usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of OBGyroIntrinsic"][::std::mem::size_of::<OBGyroIntrinsic>() - 192usize];
    ["Alignment of OBGyroIntrinsic"][::std::mem::align_of::<OBGyroIntrinsic>() - 1usize];
    ["Offset of field: OBGyroIntrinsic::noiseDensity"]
        [::std::mem::offset_of!(OBGyroIntrinsic, noiseDensity) - 0usize];
    ["Offset of field: OBGyroIntrinsic::randomWalk"]
        [::std::mem::offset_of!(OBGyroIntrinsic, randomWalk) - 8usize];
    ["Offset of field: OBGyroIntrinsic::referenceTemp"]
        [::std::mem::offset_of!(OBGyroIntrinsic, referenceTemp) - 16usize];
    ["Offset of field: OBGyroIntrinsic::bias"]
        [::std::mem::offset_of!(OBGyroIntrinsic, bias) - 24usize];
    ["Offset of field: OBGyroIntrinsic::scaleMisalignment"]
        [::std::mem::offset_of!(OBGyroIntrinsic, scaleMisalignment) - 48usize];
    ["Offset of field: OBGyroIntrinsic::tempSlope"]
        [::std::mem::offset_of!(OBGyroIntrinsic, tempSlope) - 120usize];
};
#[doc = " @brief Structure for gyroscope intrinsic parameters"]
pub type ob_gyro_intrinsic = OBGyroIntrinsic;
#[doc = " @brief Structure for distortion parameters"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct OBCameraDistortion {
    #[doc = "< Radial distortion factor 1"]
    pub k1: f32,
    #[doc = "< Radial distortion factor 2"]
    pub k2: f32,
    #[doc = "< Radial distortion factor 3"]
    pub k3: f32,
    #[doc = "< Radial distortion factor 4"]
    pub k4: f32,
    #[doc = "< Radial distortion factor 5"]
    pub k5: f32,
    #[doc = "< Radial distortion factor 6"]
    pub k6: f32,
    #[doc = "< Tangential distortion factor 1"]
    pub p1: f32,
    #[doc = "< Tangential distortion factor 2"]
    pub p2: f32,
    pub model: OBCameraDistortionModel,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of OBCameraDistortion"][::std::mem::size_of::<OBCameraDistortion>() - 36usize];
    ["Alignment of OBCameraDistortion"][::std::mem::align_of::<OBCameraDistortion>() - 1usize];
    ["Offset of field: OBCameraDistortion::k1"]
        [::std::mem::offset_of!(OBCameraDistortion, k1) - 0usize];
    ["Offset of field: OBCameraDistortion::k2"]
        [::std::mem::offset_of!(OBCameraDistortion, k2) - 4usize];
    ["Offset of field: OBCameraDistortion::k3"]
        [::std::mem::offset_of!(OBCameraDistortion, k3) - 8usize];
    ["Offset of field: OBCameraDistortion::k4"]
        [::std::mem::offset_of!(OBCameraDistortion, k4) - 12usize];
    ["Offset of field: OBCameraDistortion::k5"]
        [::std::mem::offset_of!(OBCameraDistortion, k5) - 16usize];
    ["Offset of field: OBCameraDistortion::k6"]
        [::std::mem::offset_of!(OBCameraDistortion, k6) - 20usize];
    ["Offset of field: OBCameraDistortion::p1"]
        [::std::mem::offset_of!(OBCameraDistortion, p1) - 24usize];
    ["Offset of field: OBCameraDistortion::p2"]
        [::std::mem::offset_of!(OBCameraDistortion, p2) - 28usize];
    ["Offset of field: OBCameraDistortion::model"]
        [::std::mem::offset_of!(OBCameraDistortion, model) - 32usize];
};
#[doc = " @brief Structure for distortion parameters"]
pub type ob_camera_distortion = OBCameraDistortion;
#[doc = " @brief Structure for rotation/transformation"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct OBD2CTransform {
    #[doc = "< Rotation matrix"]
    pub rot: [f32; 9usize],
    #[doc = "< Transformation matrix in millimeters"]
    pub trans: [f32; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of OBD2CTransform"][::std::mem::size_of::<OBD2CTransform>() - 48usize];
    ["Alignment of OBD2CTransform"][::std::mem::align_of::<OBD2CTransform>() - 1usize];
    ["Offset of field: OBD2CTransform::rot"][::std::mem::offset_of!(OBD2CTransform, rot) - 0usize];
    ["Offset of field: OBD2CTransform::trans"]
        [::std::mem::offset_of!(OBD2CTransform, trans) - 36usize];
};
#[doc = " @brief Structure for rotation/transformation"]
pub type ob_d2c_transform = OBD2CTransform;
#[doc = " @brief Structure for rotation/transformation"]
pub type OBTransform = OBD2CTransform;
#[doc = " @brief Structure for rotation/transformation"]
pub type ob_transform = OBD2CTransform;
#[doc = " @brief Structure for rotation/transformation"]
pub type OBExtrinsic = OBD2CTransform;
#[doc = " @brief Structure for rotation/transformation"]
pub type ob_extrinsic = OBD2CTransform;
#[doc = " @brief Structure for camera parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OBCameraParam {
    #[doc = "< Depth camera internal parameters"]
    pub depthIntrinsic: OBCameraIntrinsic,
    #[doc = "< Color camera internal parameters"]
    pub rgbIntrinsic: OBCameraIntrinsic,
    #[doc = "< Depth camera distortion parameters"]
    pub depthDistortion: OBCameraDistortion,
    #[doc = "< Color camera distortion parameters"]
    pub rgbDistortion: OBCameraDistortion,
    #[doc = "< Rotation/transformation matrix"]
    pub transform: OBD2CTransform,
    #[doc = "< Whether the image frame corresponding to this group of parameters is mirrored"]
    pub isMirrored: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of OBCameraParam"][::std::mem::size_of::<OBCameraParam>() - 161usize];
    ["Alignment of OBCameraParam"][::std::mem::align_of::<OBCameraParam>() - 1usize];
    ["Offset of field: OBCameraParam::depthIntrinsic"]
        [::std::mem::offset_of!(OBCameraParam, depthIntrinsic) - 0usize];
    ["Offset of field: OBCameraParam::rgbIntrinsic"]
        [::std::mem::offset_of!(OBCameraParam, rgbIntrinsic) - 20usize];
    ["Offset of field: OBCameraParam::depthDistortion"]
        [::std::mem::offset_of!(OBCameraParam, depthDistortion) - 40usize];
    ["Offset of field: OBCameraParam::rgbDistortion"]
        [::std::mem::offset_of!(OBCameraParam, rgbDistortion) - 76usize];
    ["Offset of field: OBCameraParam::transform"]
        [::std::mem::offset_of!(OBCameraParam, transform) - 112usize];
    ["Offset of field: OBCameraParam::isMirrored"]
        [::std::mem::offset_of!(OBCameraParam, isMirrored) - 160usize];
};
#[doc = " @brief Structure for camera parameters"]
pub type ob_camera_param = OBCameraParam;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct OBPresetResolutionConfig {
    #[doc = "< width"]
    pub width: i16,
    #[doc = "< height"]
    pub height: i16,
    #[doc = "< ir decimation factor"]
    pub irDecimationFactor: ::std::os::raw::c_int,
    #[doc = "< depth decimation factor"]
    pub depthDecimationFactor: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of OBPresetResolutionConfig"]
        [::std::mem::size_of::<OBPresetResolutionConfig>() - 12usize];
    ["Alignment of OBPresetResolutionConfig"]
        [::std::mem::align_of::<OBPresetResolutionConfig>() - 1usize];
    ["Offset of field: OBPresetResolutionConfig::width"]
        [::std::mem::offset_of!(OBPresetResolutionConfig, width) - 0usize];
    ["Offset of field: OBPresetResolutionConfig::height"]
        [::std::mem::offset_of!(OBPresetResolutionConfig, height) - 2usize];
    ["Offset of field: OBPresetResolutionConfig::irDecimationFactor"]
        [::std::mem::offset_of!(OBPresetResolutionConfig, irDecimationFactor) - 4usize];
    ["Offset of field: OBPresetResolutionConfig::depthDecimationFactor"]
        [::std::mem::offset_of!(OBPresetResolutionConfig, depthDecimationFactor) - 8usize];
};
pub type ob_preset_resolution_ratio_config = OBPresetResolutionConfig;
#[doc = " @brief calibration parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OBCalibrationParam {
    #[doc = "< Sensor internal parameters"]
    pub intrinsics: [OBCameraIntrinsic; 10usize],
    #[doc = "< Sensor distortion"]
    pub distortion: [OBCameraDistortion; 10usize],
    pub extrinsics: [[OBExtrinsic; 10usize]; 10usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of OBCalibrationParam"][::std::mem::size_of::<OBCalibrationParam>() - 5360usize];
    ["Alignment of OBCalibrationParam"][::std::mem::align_of::<OBCalibrationParam>() - 1usize];
    ["Offset of field: OBCalibrationParam::intrinsics"]
        [::std::mem::offset_of!(OBCalibrationParam, intrinsics) - 0usize];
    ["Offset of field: OBCalibrationParam::distortion"]
        [::std::mem::offset_of!(OBCalibrationParam, distortion) - 200usize];
    ["Offset of field: OBCalibrationParam::extrinsics"]
        [::std::mem::offset_of!(OBCalibrationParam, extrinsics) - 560usize];
};
#[doc = " @brief calibration parameters"]
pub type ob_calibration_param = OBCalibrationParam;
#[doc = " @brief Configuration for depth margin filter"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ob_margin_filter_config {
    #[doc = "< Horizontal threshold settings"]
    pub margin_x_th: ::std::os::raw::c_int,
    #[doc = "< Vertical threshold settings"]
    pub margin_y_th: ::std::os::raw::c_int,
    #[doc = "< Maximum horizontal threshold"]
    pub limit_x_th: ::std::os::raw::c_int,
    #[doc = "< Maximum vertical threshold"]
    pub limit_y_th: ::std::os::raw::c_int,
    #[doc = "< Image width"]
    pub width: u32,
    #[doc = "< Image height"]
    pub height: u32,
    #[doc = "< Set to true for horizontal and vertical, false for horizontal only"]
    pub enable_direction: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ob_margin_filter_config"][::std::mem::size_of::<ob_margin_filter_config>() - 25usize];
    ["Alignment of ob_margin_filter_config"]
        [::std::mem::align_of::<ob_margin_filter_config>() - 1usize];
    ["Offset of field: ob_margin_filter_config::margin_x_th"]
        [::std::mem::offset_of!(ob_margin_filter_config, margin_x_th) - 0usize];
    ["Offset of field: ob_margin_filter_config::margin_y_th"]
        [::std::mem::offset_of!(ob_margin_filter_config, margin_y_th) - 4usize];
    ["Offset of field: ob_margin_filter_config::limit_x_th"]
        [::std::mem::offset_of!(ob_margin_filter_config, limit_x_th) - 8usize];
    ["Offset of field: ob_margin_filter_config::limit_y_th"]
        [::std::mem::offset_of!(ob_margin_filter_config, limit_y_th) - 12usize];
    ["Offset of field: ob_margin_filter_config::width"]
        [::std::mem::offset_of!(ob_margin_filter_config, width) - 16usize];
    ["Offset of field: ob_margin_filter_config::height"]
        [::std::mem::offset_of!(ob_margin_filter_config, height) - 20usize];
    ["Offset of field: ob_margin_filter_config::enable_direction"]
        [::std::mem::offset_of!(ob_margin_filter_config, enable_direction) - 24usize];
};
#[doc = " @brief Configuration for depth margin filter"]
pub type OBMarginFilterConfig = ob_margin_filter_config;
#[doc = " @brief Configuration for mgc filter"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct OBMGCFilterConfig {
    pub width: u32,
    pub height: u32,
    pub max_width_left: ::std::os::raw::c_int,
    pub max_width_right: ::std::os::raw::c_int,
    pub max_radius: ::std::os::raw::c_int,
    pub margin_x_th: ::std::os::raw::c_int,
    pub margin_y_th: ::std::os::raw::c_int,
    pub limit_x_th: ::std::os::raw::c_int,
    pub limit_y_th: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of OBMGCFilterConfig"][::std::mem::size_of::<OBMGCFilterConfig>() - 36usize];
    ["Alignment of OBMGCFilterConfig"][::std::mem::align_of::<OBMGCFilterConfig>() - 1usize];
    ["Offset of field: OBMGCFilterConfig::width"]
        [::std::mem::offset_of!(OBMGCFilterConfig, width) - 0usize];
    ["Offset of field: OBMGCFilterConfig::height"]
        [::std::mem::offset_of!(OBMGCFilterConfig, height) - 4usize];
    ["Offset of field: OBMGCFilterConfig::max_width_left"]
        [::std::mem::offset_of!(OBMGCFilterConfig, max_width_left) - 8usize];
    ["Offset of field: OBMGCFilterConfig::max_width_right"]
        [::std::mem::offset_of!(OBMGCFilterConfig, max_width_right) - 12usize];
    ["Offset of field: OBMGCFilterConfig::max_radius"]
        [::std::mem::offset_of!(OBMGCFilterConfig, max_radius) - 16usize];
    ["Offset of field: OBMGCFilterConfig::margin_x_th"]
        [::std::mem::offset_of!(OBMGCFilterConfig, margin_x_th) - 20usize];
    ["Offset of field: OBMGCFilterConfig::margin_y_th"]
        [::std::mem::offset_of!(OBMGCFilterConfig, margin_y_th) - 24usize];
    ["Offset of field: OBMGCFilterConfig::limit_x_th"]
        [::std::mem::offset_of!(OBMGCFilterConfig, limit_x_th) - 28usize];
    ["Offset of field: OBMGCFilterConfig::limit_y_th"]
        [::std::mem::offset_of!(OBMGCFilterConfig, limit_y_th) - 32usize];
};
#[doc = " @brief Configuration for mgc filter"]
pub type ob_mgc_filter_config = OBMGCFilterConfig;
#[doc = "< Turn off alignment"]
pub const OBAlignMode_ALIGN_DISABLE: OBAlignMode = 0;
#[doc = "< Hardware D2C alignment mode"]
pub const OBAlignMode_ALIGN_D2C_HW_MODE: OBAlignMode = 1;
#[doc = "< Software D2C alignment mode"]
pub const OBAlignMode_ALIGN_D2C_SW_MODE: OBAlignMode = 2;
#[doc = " @brief Alignment mode"]
pub type OBAlignMode = i32;
#[doc = " @brief Alignment mode"]
pub use self::OBAlignMode as ob_align_mode;
#[doc = "< Camera adaptive mode"]
pub const OBCameraPerformanceMode_ADAPTIVE_PERFORMANCE_MODE: OBCameraPerformanceMode = 0;
#[doc = "< High Performance Mode"]
pub const OBCameraPerformanceMode_HIGH_PERFORMANCE_MODE: OBCameraPerformanceMode = 1;
#[doc = " @brief Camera performance mode"]
pub type OBCameraPerformanceMode = i32;
#[doc = " @brief Camera performance mode"]
pub use self::OBCameraPerformanceMode as ob_camera_performance_mode;
#[doc = " @brief Rectangle"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct OBRect {
    #[doc = "< Origin coordinate x"]
    pub x: u32,
    #[doc = "< Origin coordinate y"]
    pub y: u32,
    #[doc = "< Rectangle width"]
    pub width: u32,
    #[doc = "< Rectangle height"]
    pub height: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of OBRect"][::std::mem::size_of::<OBRect>() - 16usize];
    ["Alignment of OBRect"][::std::mem::align_of::<OBRect>() - 1usize];
    ["Offset of field: OBRect::x"][::std::mem::offset_of!(OBRect, x) - 0usize];
    ["Offset of field: OBRect::y"][::std::mem::offset_of!(OBRect, y) - 4usize];
    ["Offset of field: OBRect::width"][::std::mem::offset_of!(OBRect, width) - 8usize];
    ["Offset of field: OBRect::height"][::std::mem::offset_of!(OBRect, height) - 12usize];
};
#[doc = " @brief Rectangle"]
pub type ob_rect = OBRect;
#[doc = "< YUYV to RGB"]
pub const OBConvertFormat_FORMAT_YUYV_TO_RGB: OBConvertFormat = 0;
#[doc = "< I420 to RGB"]
pub const OBConvertFormat_FORMAT_I420_TO_RGB: OBConvertFormat = 1;
#[doc = "< NV21 to RGB"]
pub const OBConvertFormat_FORMAT_NV21_TO_RGB: OBConvertFormat = 2;
#[doc = "< NV12 to RGB"]
pub const OBConvertFormat_FORMAT_NV12_TO_RGB: OBConvertFormat = 3;
#[doc = "< MJPG to I420"]
pub const OBConvertFormat_FORMAT_MJPG_TO_I420: OBConvertFormat = 4;
#[doc = "< RGB888 to BGR"]
pub const OBConvertFormat_FORMAT_RGB_TO_BGR: OBConvertFormat = 5;
#[doc = "< MJPG to NV21"]
pub const OBConvertFormat_FORMAT_MJPG_TO_NV21: OBConvertFormat = 6;
#[doc = "< MJPG to RGB"]
pub const OBConvertFormat_FORMAT_MJPG_TO_RGB: OBConvertFormat = 7;
#[doc = "< MJPG to BGR"]
pub const OBConvertFormat_FORMAT_MJPG_TO_BGR: OBConvertFormat = 8;
#[doc = "< MJPG to BGRA"]
pub const OBConvertFormat_FORMAT_MJPG_TO_BGRA: OBConvertFormat = 9;
#[doc = "< UYVY to RGB"]
pub const OBConvertFormat_FORMAT_UYVY_TO_RGB: OBConvertFormat = 10;
#[doc = "< BGR to RGB"]
pub const OBConvertFormat_FORMAT_BGR_TO_RGB: OBConvertFormat = 11;
#[doc = "< MJPG to NV12"]
pub const OBConvertFormat_FORMAT_MJPG_TO_NV12: OBConvertFormat = 12;
#[doc = "< YUYV to BGR"]
pub const OBConvertFormat_FORMAT_YUYV_TO_BGR: OBConvertFormat = 13;
#[doc = "< YUYV to RGBA"]
pub const OBConvertFormat_FORMAT_YUYV_TO_RGBA: OBConvertFormat = 14;
#[doc = "< YUYV to BGRA"]
pub const OBConvertFormat_FORMAT_YUYV_TO_BGRA: OBConvertFormat = 15;
#[doc = "< YUYV to Y16"]
pub const OBConvertFormat_FORMAT_YUYV_TO_Y16: OBConvertFormat = 16;
#[doc = "< YUYV to Y8"]
pub const OBConvertFormat_FORMAT_YUYV_TO_Y8: OBConvertFormat = 17;
#[doc = "< RGBA to RGB"]
pub const OBConvertFormat_FORMAT_RGBA_TO_RGB: OBConvertFormat = 18;
#[doc = "< BGRA to BGR"]
pub const OBConvertFormat_FORMAT_BGRA_TO_BGR: OBConvertFormat = 19;
#[doc = "< Y16 to RGB"]
pub const OBConvertFormat_FORMAT_Y16_TO_RGB: OBConvertFormat = 20;
#[doc = "< Y8 to RGB"]
pub const OBConvertFormat_FORMAT_Y8_TO_RGB: OBConvertFormat = 21;
#[doc = " @brief Enumeration of format conversion types"]
pub type OBConvertFormat = i32;
#[doc = " @brief Enumeration of format conversion types"]
pub use self::OBConvertFormat as ob_convert_format;
pub const OBIMUSampleRate_OB_SAMPLE_RATE_UNKNOWN: OBIMUSampleRate = 0;
#[doc = "< 1.5625Hz"]
pub const OBIMUSampleRate_OB_SAMPLE_RATE_1_5625_HZ: OBIMUSampleRate = 1;
#[doc = "< 3.125Hz"]
pub const OBIMUSampleRate_OB_SAMPLE_RATE_3_125_HZ: OBIMUSampleRate = 2;
#[doc = "< 6.25Hz"]
pub const OBIMUSampleRate_OB_SAMPLE_RATE_6_25_HZ: OBIMUSampleRate = 3;
#[doc = "< 12.5Hz"]
pub const OBIMUSampleRate_OB_SAMPLE_RATE_12_5_HZ: OBIMUSampleRate = 4;
#[doc = "< 25Hz"]
pub const OBIMUSampleRate_OB_SAMPLE_RATE_25_HZ: OBIMUSampleRate = 5;
#[doc = "< 50Hz"]
pub const OBIMUSampleRate_OB_SAMPLE_RATE_50_HZ: OBIMUSampleRate = 6;
#[doc = "< 100Hz"]
pub const OBIMUSampleRate_OB_SAMPLE_RATE_100_HZ: OBIMUSampleRate = 7;
#[doc = "< 200Hz"]
pub const OBIMUSampleRate_OB_SAMPLE_RATE_200_HZ: OBIMUSampleRate = 8;
#[doc = "< 500Hz"]
pub const OBIMUSampleRate_OB_SAMPLE_RATE_500_HZ: OBIMUSampleRate = 9;
#[doc = "< 1KHz"]
pub const OBIMUSampleRate_OB_SAMPLE_RATE_1_KHZ: OBIMUSampleRate = 10;
#[doc = "< 2KHz"]
pub const OBIMUSampleRate_OB_SAMPLE_RATE_2_KHZ: OBIMUSampleRate = 11;
#[doc = "< 4KHz"]
pub const OBIMUSampleRate_OB_SAMPLE_RATE_4_KHZ: OBIMUSampleRate = 12;
#[doc = "< 8KHz"]
pub const OBIMUSampleRate_OB_SAMPLE_RATE_8_KHZ: OBIMUSampleRate = 13;
#[doc = "< 16KHz"]
pub const OBIMUSampleRate_OB_SAMPLE_RATE_16_KHZ: OBIMUSampleRate = 14;
#[doc = "< 32Hz"]
pub const OBIMUSampleRate_OB_SAMPLE_RATE_32_KHZ: OBIMUSampleRate = 15;
#[doc = "< 400Hz"]
pub const OBIMUSampleRate_OB_SAMPLE_RATE_400_HZ: OBIMUSampleRate = 16;
#[doc = "< 800Hz"]
pub const OBIMUSampleRate_OB_SAMPLE_RATE_800_HZ: OBIMUSampleRate = 17;
#[doc = " @brief Enumeration of IMU sample rate values (gyroscope or accelerometer)"]
pub type OBIMUSampleRate = i32;
#[doc = " @brief Enumeration of IMU sample rate values (gyroscope or accelerometer)"]
pub use self::OBIMUSampleRate as OBGyroSampleRate;
#[doc = " @brief Enumeration of IMU sample rate values (gyroscope or accelerometer)"]
pub use self::OBIMUSampleRate as ob_gyro_sample_rate;
#[doc = " @brief Enumeration of IMU sample rate values (gyroscope or accelerometer)"]
pub use self::OBIMUSampleRate as OBAccelSampleRate;
#[doc = " @brief Enumeration of IMU sample rate values (gyroscope or accelerometer)"]
pub use self::OBIMUSampleRate as ob_accel_sample_rate;
#[doc = " @brief Enumeration of IMU sample rate values (gyroscope or accelerometer)"]
pub use self::OBIMUSampleRate as OB_SAMPLE_RATE;
pub const OBGyroFullScaleRange_OB_GYRO_FS_UNKNOWN: OBGyroFullScaleRange = -1;
#[doc = "< 16 degrees per second"]
pub const OBGyroFullScaleRange_OB_GYRO_FS_16dps: OBGyroFullScaleRange = 1;
#[doc = "< 31 degrees per second"]
pub const OBGyroFullScaleRange_OB_GYRO_FS_31dps: OBGyroFullScaleRange = 2;
#[doc = "< 62 degrees per second"]
pub const OBGyroFullScaleRange_OB_GYRO_FS_62dps: OBGyroFullScaleRange = 3;
#[doc = "< 125 degrees per second"]
pub const OBGyroFullScaleRange_OB_GYRO_FS_125dps: OBGyroFullScaleRange = 4;
#[doc = "< 250 degrees per second"]
pub const OBGyroFullScaleRange_OB_GYRO_FS_250dps: OBGyroFullScaleRange = 5;
#[doc = "< 500 degrees per second"]
pub const OBGyroFullScaleRange_OB_GYRO_FS_500dps: OBGyroFullScaleRange = 6;
#[doc = "< 1000 degrees per second"]
pub const OBGyroFullScaleRange_OB_GYRO_FS_1000dps: OBGyroFullScaleRange = 7;
#[doc = "< 2000 degrees per second"]
pub const OBGyroFullScaleRange_OB_GYRO_FS_2000dps: OBGyroFullScaleRange = 8;
#[doc = "< 400 degrees per second"]
pub const OBGyroFullScaleRange_OB_GYRO_FS_400dps: OBGyroFullScaleRange = 9;
#[doc = "< 800 degrees per second"]
pub const OBGyroFullScaleRange_OB_GYRO_FS_800dps: OBGyroFullScaleRange = 10;
#[doc = " @brief Enumeration of gyroscope ranges"]
pub type OBGyroFullScaleRange = i32;
#[doc = " @brief Enumeration of gyroscope ranges"]
pub use self::OBGyroFullScaleRange as ob_gyro_full_scale_range;
#[doc = " @brief Enumeration of gyroscope ranges"]
pub use self::OBGyroFullScaleRange as OB_GYRO_FULL_SCALE_RANGE;
pub const OBAccelFullScaleRange_OB_ACCEL_FS_UNKNOWN: OBAccelFullScaleRange = -1;
#[doc = "< 1x the acceleration of gravity"]
pub const OBAccelFullScaleRange_OB_ACCEL_FS_2g: OBAccelFullScaleRange = 1;
#[doc = "< 4x the acceleration of gravity"]
pub const OBAccelFullScaleRange_OB_ACCEL_FS_4g: OBAccelFullScaleRange = 2;
#[doc = "< 8x the acceleration of gravity"]
pub const OBAccelFullScaleRange_OB_ACCEL_FS_8g: OBAccelFullScaleRange = 3;
#[doc = "< 16x the acceleration of gravity"]
pub const OBAccelFullScaleRange_OB_ACCEL_FS_16g: OBAccelFullScaleRange = 4;
#[doc = "< 3x the acceleration of gravity"]
pub const OBAccelFullScaleRange_OB_ACCEL_FS_3g: OBAccelFullScaleRange = 5;
#[doc = "< 6x the acceleration of gravity"]
pub const OBAccelFullScaleRange_OB_ACCEL_FS_6g: OBAccelFullScaleRange = 6;
#[doc = "< 12x the acceleration of gravity"]
pub const OBAccelFullScaleRange_OB_ACCEL_FS_12g: OBAccelFullScaleRange = 7;
#[doc = "< 24x the acceleration of gravity"]
pub const OBAccelFullScaleRange_OB_ACCEL_FS_24g: OBAccelFullScaleRange = 8;
#[doc = " @brief Enumeration of accelerometer ranges"]
pub type OBAccelFullScaleRange = i32;
#[doc = " @brief Enumeration of accelerometer ranges"]
pub use self::OBAccelFullScaleRange as ob_accel_full_scale_range;
#[doc = " @brief Enumeration of accelerometer ranges"]
pub use self::OBAccelFullScaleRange as OB_ACCEL_FULL_SCALE_RANGE;
#[doc = " @brief Data structures for accelerometers and gyroscopes"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct OBAccelValue {
    #[doc = "< X-direction component"]
    pub x: f32,
    #[doc = "< Y-direction component"]
    pub y: f32,
    #[doc = "< Z-direction component"]
    pub z: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of OBAccelValue"][::std::mem::size_of::<OBAccelValue>() - 12usize];
    ["Alignment of OBAccelValue"][::std::mem::align_of::<OBAccelValue>() - 1usize];
    ["Offset of field: OBAccelValue::x"][::std::mem::offset_of!(OBAccelValue, x) - 0usize];
    ["Offset of field: OBAccelValue::y"][::std::mem::offset_of!(OBAccelValue, y) - 4usize];
    ["Offset of field: OBAccelValue::z"][::std::mem::offset_of!(OBAccelValue, z) - 8usize];
};
#[doc = " @brief Data structures for accelerometers and gyroscopes"]
pub type OBGyroValue = OBAccelValue;
#[doc = " @brief Data structures for accelerometers and gyroscopes"]
pub type OBFloat3D = OBAccelValue;
#[doc = " @brief Data structures for accelerometers and gyroscopes"]
pub type ob_accel_value = OBAccelValue;
#[doc = " @brief Data structures for accelerometers and gyroscopes"]
pub type ob_gyro_value = OBAccelValue;
#[doc = " @brief Data structures for accelerometers and gyroscopes"]
pub type ob_float_3d = OBAccelValue;
#[doc = " @brief Device state"]
pub type OBDeviceState = u64;
#[doc = " @brief Device state"]
pub type ob_device_state = u64;
#[doc = " @brief Temperature parameters of the device (unit: Celsius)"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct OBDeviceTemperature {
    #[doc = "< CPU temperature"]
    pub cpuTemp: f32,
    #[doc = "< IR temperature"]
    pub irTemp: f32,
    #[doc = "< Laser temperature"]
    pub ldmTemp: f32,
    #[doc = "< Motherboard temperature"]
    pub mainBoardTemp: f32,
    #[doc = "< TEC temperature"]
    pub tecTemp: f32,
    #[doc = "< IMU temperature"]
    pub imuTemp: f32,
    #[doc = "< RGB temperature"]
    pub rgbTemp: f32,
    #[doc = "< Left IR temperature"]
    pub irLeftTemp: f32,
    #[doc = "< Right IR temperature"]
    pub irRightTemp: f32,
    #[doc = "< MX6600 top temperature"]
    pub chipTopTemp: f32,
    #[doc = "< MX6600 bottom temperature"]
    pub chipBottomTemp: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of OBDeviceTemperature"][::std::mem::size_of::<OBDeviceTemperature>() - 44usize];
    ["Alignment of OBDeviceTemperature"][::std::mem::align_of::<OBDeviceTemperature>() - 1usize];
    ["Offset of field: OBDeviceTemperature::cpuTemp"]
        [::std::mem::offset_of!(OBDeviceTemperature, cpuTemp) - 0usize];
    ["Offset of field: OBDeviceTemperature::irTemp"]
        [::std::mem::offset_of!(OBDeviceTemperature, irTemp) - 4usize];
    ["Offset of field: OBDeviceTemperature::ldmTemp"]
        [::std::mem::offset_of!(OBDeviceTemperature, ldmTemp) - 8usize];
    ["Offset of field: OBDeviceTemperature::mainBoardTemp"]
        [::std::mem::offset_of!(OBDeviceTemperature, mainBoardTemp) - 12usize];
    ["Offset of field: OBDeviceTemperature::tecTemp"]
        [::std::mem::offset_of!(OBDeviceTemperature, tecTemp) - 16usize];
    ["Offset of field: OBDeviceTemperature::imuTemp"]
        [::std::mem::offset_of!(OBDeviceTemperature, imuTemp) - 20usize];
    ["Offset of field: OBDeviceTemperature::rgbTemp"]
        [::std::mem::offset_of!(OBDeviceTemperature, rgbTemp) - 24usize];
    ["Offset of field: OBDeviceTemperature::irLeftTemp"]
        [::std::mem::offset_of!(OBDeviceTemperature, irLeftTemp) - 28usize];
    ["Offset of field: OBDeviceTemperature::irRightTemp"]
        [::std::mem::offset_of!(OBDeviceTemperature, irRightTemp) - 32usize];
    ["Offset of field: OBDeviceTemperature::chipTopTemp"]
        [::std::mem::offset_of!(OBDeviceTemperature, chipTopTemp) - 36usize];
    ["Offset of field: OBDeviceTemperature::chipBottomTemp"]
        [::std::mem::offset_of!(OBDeviceTemperature, chipBottomTemp) - 40usize];
};
#[doc = " @brief Temperature parameters of the device (unit: Celsius)"]
pub type ob_device_temperature = OBDeviceTemperature;
#[doc = " @brief Temperature parameters of the device (unit: Celsius)"]
pub type DEVICE_TEMPERATURE = OBDeviceTemperature;
#[doc = "< Automatic mode"]
pub const OBDepthCroppingMode_DEPTH_CROPPING_MODE_AUTO: OBDepthCroppingMode = 0;
#[doc = "< Close crop"]
pub const OBDepthCroppingMode_DEPTH_CROPPING_MODE_CLOSE: OBDepthCroppingMode = 1;
#[doc = "< Open crop"]
pub const OBDepthCroppingMode_DEPTH_CROPPING_MODE_OPEN: OBDepthCroppingMode = 2;
#[doc = " @brief Enumeration for depth crop modes"]
pub type OBDepthCroppingMode = i32;
#[doc = " @brief Enumeration for depth crop modes"]
pub use self::OBDepthCroppingMode as ob_depth_cropping_mode;
#[doc = " @brief Enumeration for depth crop modes"]
pub use self::OBDepthCroppingMode as OB_DEPTH_CROPPING_MODE;
#[doc = "< Unknown device type"]
pub const OBDeviceType_OB_DEVICE_TYPE_UNKNOWN: OBDeviceType = -1;
#[doc = "< Monocular structured light camera"]
pub const OBDeviceType_OB_STRUCTURED_LIGHT_MONOCULAR_CAMERA: OBDeviceType = 0;
#[doc = "< Binocular structured light camera"]
pub const OBDeviceType_OB_STRUCTURED_LIGHT_BINOCULAR_CAMERA: OBDeviceType = 1;
#[doc = "< Time-of-flight camera"]
pub const OBDeviceType_OB_TOF_CAMERA: OBDeviceType = 2;
#[doc = " @brief Enumeration for device types"]
pub type OBDeviceType = i32;
#[doc = " @brief Enumeration for device types"]
pub use self::OBDeviceType as ob_device_type;
#[doc = " @brief Enumeration for device types"]
pub use self::OBDeviceType as OB_DEVICE_TYPE;
#[doc = "< Color stream"]
pub const OBMediaType_OB_MEDIA_COLOR_STREAM: OBMediaType = 1;
#[doc = "< Depth stream"]
pub const OBMediaType_OB_MEDIA_DEPTH_STREAM: OBMediaType = 2;
#[doc = "< Infrared stream"]
pub const OBMediaType_OB_MEDIA_IR_STREAM: OBMediaType = 4;
#[doc = "< Gyroscope stream"]
pub const OBMediaType_OB_MEDIA_GYRO_STREAM: OBMediaType = 8;
#[doc = "< Accelerometer stream"]
pub const OBMediaType_OB_MEDIA_ACCEL_STREAM: OBMediaType = 16;
#[doc = "< Camera parameter"]
pub const OBMediaType_OB_MEDIA_CAMERA_PARAM: OBMediaType = 32;
#[doc = "< Device information"]
pub const OBMediaType_OB_MEDIA_DEVICE_INFO: OBMediaType = 64;
#[doc = "< Stream information"]
pub const OBMediaType_OB_MEDIA_STREAM_INFO: OBMediaType = 128;
#[doc = "< Left infrared stream"]
pub const OBMediaType_OB_MEDIA_IR_LEFT_STREAM: OBMediaType = 256;
#[doc = "< Right infrared stream"]
pub const OBMediaType_OB_MEDIA_IR_RIGHT_STREAM: OBMediaType = 512;
pub const OBMediaType_OB_MEDIA_ALL: OBMediaType = 1023;
#[doc = " @brief Enumeration for types of media to record or playback"]
pub type OBMediaType = i32;
#[doc = " @brief Enumeration for types of media to record or playback"]
pub use self::OBMediaType as ob_media_type;
#[doc = " @brief Enumeration for types of media to record or playback"]
pub use self::OBMediaType as OB_MEDIA_TYPE;
#[doc = "< Begin"]
pub const OBMediaState_OB_MEDIA_BEGIN: OBMediaState = 0;
#[doc = "< Pause"]
pub const OBMediaState_OB_MEDIA_PAUSE: OBMediaState = 1;
#[doc = "< Resume"]
pub const OBMediaState_OB_MEDIA_RESUME: OBMediaState = 2;
#[doc = "< End"]
pub const OBMediaState_OB_MEDIA_END: OBMediaState = 3;
#[doc = " @brief Enumeration for record playback status"]
pub type OBMediaState = i32;
#[doc = " @brief Enumeration for record playback status"]
pub use self::OBMediaState as ob_media_state;
#[doc = " @brief Enumeration for record playback status"]
pub use self::OBMediaState as OB_MEDIA_STATE_EM;
#[doc = "< 1mm"]
pub const OBDepthPrecisionLevel_OB_PRECISION_1MM: OBDepthPrecisionLevel = 0;
#[doc = "< 0.8mm"]
pub const OBDepthPrecisionLevel_OB_PRECISION_0MM8: OBDepthPrecisionLevel = 1;
#[doc = "< 0.4mm"]
pub const OBDepthPrecisionLevel_OB_PRECISION_0MM4: OBDepthPrecisionLevel = 2;
#[doc = "< 0.1mm"]
pub const OBDepthPrecisionLevel_OB_PRECISION_0MM1: OBDepthPrecisionLevel = 3;
#[doc = "< 0.2mm"]
pub const OBDepthPrecisionLevel_OB_PRECISION_0MM2: OBDepthPrecisionLevel = 4;
#[doc = "< 0.5mm"]
pub const OBDepthPrecisionLevel_OB_PRECISION_0MM5: OBDepthPrecisionLevel = 5;
#[doc = "< 0.05mm"]
pub const OBDepthPrecisionLevel_OB_PRECISION_0MM05: OBDepthPrecisionLevel = 6;
pub const OBDepthPrecisionLevel_OB_PRECISION_UNKNOWN: OBDepthPrecisionLevel = 7;
pub const OBDepthPrecisionLevel_OB_PRECISION_COUNT: OBDepthPrecisionLevel = 8;
#[doc = " @brief Enumeration for depth precision levels\n @attention The depth precision level does not completely determine the depth unit and real precision, and the influence of the data packaging format needs to\n be considered. The specific unit can be obtained through getValueScale() of DepthFrame"]
pub type OBDepthPrecisionLevel = i32;
#[doc = " @brief Enumeration for depth precision levels\n @attention The depth precision level does not completely determine the depth unit and real precision, and the influence of the data packaging format needs to\n be considered. The specific unit can be obtained through getValueScale() of DepthFrame"]
pub use self::OBDepthPrecisionLevel as ob_depth_precision_level;
#[doc = " @brief Enumeration for depth precision levels\n @attention The depth precision level does not completely determine the depth unit and real precision, and the influence of the data packaging format needs to\n be considered. The specific unit can be obtained through getValueScale() of DepthFrame"]
pub use self::OBDepthPrecisionLevel as OB_DEPTH_PRECISION_LEVEL;
#[doc = " @brief Enumeration for depth precision levels\n @attention The depth precision level does not completely determine the depth unit and real precision, and the influence of the data packaging format needs to\n be considered. The specific unit can be obtained through getValueScale() of DepthFrame"]
pub use self::OBDepthPrecisionLevel as OBDepthUnit;
#[doc = " @brief Enumeration for depth precision levels\n @attention The depth precision level does not completely determine the depth unit and real precision, and the influence of the data packaging format needs to\n be considered. The specific unit can be obtained through getValueScale() of DepthFrame"]
pub use self::OBDepthPrecisionLevel as ob_depth_unit;
#[doc = " @brief disparity parameters for disparity based camera\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct OBDisparityParam {
    pub zpd: f64,
    pub zpps: f64,
    pub baseline: f32,
    pub fx: f64,
    pub bitSize: u8,
    pub unit: f32,
    pub minDisparity: f32,
    pub packMode: u8,
    pub dispOffset: f32,
    pub invalidDisp: i32,
    pub dispIntPlace: i32,
    pub isDualCamera: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of OBDisparityParam"][::std::mem::size_of::<OBDisparityParam>() - 51usize];
    ["Alignment of OBDisparityParam"][::std::mem::align_of::<OBDisparityParam>() - 1usize];
    ["Offset of field: OBDisparityParam::zpd"]
        [::std::mem::offset_of!(OBDisparityParam, zpd) - 0usize];
    ["Offset of field: OBDisparityParam::zpps"]
        [::std::mem::offset_of!(OBDisparityParam, zpps) - 8usize];
    ["Offset of field: OBDisparityParam::baseline"]
        [::std::mem::offset_of!(OBDisparityParam, baseline) - 16usize];
    ["Offset of field: OBDisparityParam::fx"]
        [::std::mem::offset_of!(OBDisparityParam, fx) - 20usize];
    ["Offset of field: OBDisparityParam::bitSize"]
        [::std::mem::offset_of!(OBDisparityParam, bitSize) - 28usize];
    ["Offset of field: OBDisparityParam::unit"]
        [::std::mem::offset_of!(OBDisparityParam, unit) - 29usize];
    ["Offset of field: OBDisparityParam::minDisparity"]
        [::std::mem::offset_of!(OBDisparityParam, minDisparity) - 33usize];
    ["Offset of field: OBDisparityParam::packMode"]
        [::std::mem::offset_of!(OBDisparityParam, packMode) - 37usize];
    ["Offset of field: OBDisparityParam::dispOffset"]
        [::std::mem::offset_of!(OBDisparityParam, dispOffset) - 38usize];
    ["Offset of field: OBDisparityParam::invalidDisp"]
        [::std::mem::offset_of!(OBDisparityParam, invalidDisp) - 42usize];
    ["Offset of field: OBDisparityParam::dispIntPlace"]
        [::std::mem::offset_of!(OBDisparityParam, dispIntPlace) - 46usize];
    ["Offset of field: OBDisparityParam::isDualCamera"]
        [::std::mem::offset_of!(OBDisparityParam, isDualCamera) - 50usize];
};
#[doc = " @brief disparity parameters for disparity based camera\n"]
pub type ob_disparity_param = OBDisparityParam;
#[doc = "< Close range"]
pub const OBTofFilterRange_OB_TOF_FILTER_RANGE_CLOSE: OBTofFilterRange = 0;
#[doc = "< Middle range"]
pub const OBTofFilterRange_OB_TOF_FILTER_RANGE_MIDDLE: OBTofFilterRange = 1;
#[doc = "< Long range"]
pub const OBTofFilterRange_OB_TOF_FILTER_RANGE_LONG: OBTofFilterRange = 2;
#[doc = "< Debug range"]
pub const OBTofFilterRange_OB_TOF_FILTER_RANGE_DEBUG: OBTofFilterRange = 100;
#[doc = " @brief Enumeration for TOF filter scene ranges"]
pub type OBTofFilterRange = i32;
#[doc = " @brief Enumeration for TOF filter scene ranges"]
pub use self::OBTofFilterRange as ob_tof_filter_range;
#[doc = " @brief Enumeration for TOF filter scene ranges"]
pub use self::OBTofFilterRange as TOF_FILTER_RANGE;
#[doc = " @brief 3D point structure in the SDK"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct OBPoint {
    #[doc = "< X coordinate"]
    pub x: f32,
    #[doc = "< Y coordinate"]
    pub y: f32,
    #[doc = "< Z coordinate"]
    pub z: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of OBPoint"][::std::mem::size_of::<OBPoint>() - 12usize];
    ["Alignment of OBPoint"][::std::mem::align_of::<OBPoint>() - 1usize];
    ["Offset of field: OBPoint::x"][::std::mem::offset_of!(OBPoint, x) - 0usize];
    ["Offset of field: OBPoint::y"][::std::mem::offset_of!(OBPoint, y) - 4usize];
    ["Offset of field: OBPoint::z"][::std::mem::offset_of!(OBPoint, z) - 8usize];
};
#[doc = " @brief 3D point structure in the SDK"]
pub type ob_point = OBPoint;
#[doc = " @brief 3D point structure in the SDK"]
pub type OBPoint3f = OBPoint;
#[doc = " @brief 3D point structure in the SDK"]
pub type ob_point3f = OBPoint;
#[doc = " @brief 2D point structure in the SDK"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct OBPoint2f {
    #[doc = "< X coordinate"]
    pub x: f32,
    #[doc = "< Y coordinate"]
    pub y: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of OBPoint2f"][::std::mem::size_of::<OBPoint2f>() - 8usize];
    ["Alignment of OBPoint2f"][::std::mem::align_of::<OBPoint2f>() - 1usize];
    ["Offset of field: OBPoint2f::x"][::std::mem::offset_of!(OBPoint2f, x) - 0usize];
    ["Offset of field: OBPoint2f::y"][::std::mem::offset_of!(OBPoint2f, y) - 4usize];
};
#[doc = " @brief 2D point structure in the SDK"]
pub type ob_point2f = OBPoint2f;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct OBXYTables {
    #[doc = "< table used to compute X coordinate"]
    pub xTable: *mut f32,
    #[doc = "< table used to compute Y coordinate"]
    pub yTable: *mut f32,
    #[doc = "< width of x and y tables"]
    pub width: ::std::os::raw::c_int,
    #[doc = "< height of x and y tables"]
    pub height: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of OBXYTables"][::std::mem::size_of::<OBXYTables>() - 24usize];
    ["Alignment of OBXYTables"][::std::mem::align_of::<OBXYTables>() - 1usize];
    ["Offset of field: OBXYTables::xTable"][::std::mem::offset_of!(OBXYTables, xTable) - 0usize];
    ["Offset of field: OBXYTables::yTable"][::std::mem::offset_of!(OBXYTables, yTable) - 8usize];
    ["Offset of field: OBXYTables::width"][::std::mem::offset_of!(OBXYTables, width) - 16usize];
    ["Offset of field: OBXYTables::height"][::std::mem::offset_of!(OBXYTables, height) - 20usize];
};
pub type ob_xy_tables = OBXYTables;
#[doc = " @brief 3D point structure with color information"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct OBColorPoint {
    #[doc = "< X coordinate"]
    pub x: f32,
    #[doc = "< Y coordinate"]
    pub y: f32,
    #[doc = "< Z coordinate"]
    pub z: f32,
    #[doc = "< Red channel component"]
    pub r: f32,
    #[doc = "< Green channel component"]
    pub g: f32,
    #[doc = "< Blue channel component"]
    pub b: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of OBColorPoint"][::std::mem::size_of::<OBColorPoint>() - 24usize];
    ["Alignment of OBColorPoint"][::std::mem::align_of::<OBColorPoint>() - 1usize];
    ["Offset of field: OBColorPoint::x"][::std::mem::offset_of!(OBColorPoint, x) - 0usize];
    ["Offset of field: OBColorPoint::y"][::std::mem::offset_of!(OBColorPoint, y) - 4usize];
    ["Offset of field: OBColorPoint::z"][::std::mem::offset_of!(OBColorPoint, z) - 8usize];
    ["Offset of field: OBColorPoint::r"][::std::mem::offset_of!(OBColorPoint, r) - 12usize];
    ["Offset of field: OBColorPoint::g"][::std::mem::offset_of!(OBColorPoint, g) - 16usize];
    ["Offset of field: OBColorPoint::b"][::std::mem::offset_of!(OBColorPoint, b) - 20usize];
};
#[doc = " @brief 3D point structure with color information"]
pub type ob_color_point = OBColorPoint;
#[doc = "< Lossless compression mode"]
pub const OBCompressionMode_OB_COMPRESSION_LOSSLESS: OBCompressionMode = 0;
#[doc = "< Lossy compression mode"]
pub const OBCompressionMode_OB_COMPRESSION_LOSSY: OBCompressionMode = 1;
#[doc = " @brief Compression mode"]
pub type OBCompressionMode = i32;
#[doc = " @brief Compression mode"]
pub use self::OBCompressionMode as ob_compression_mode;
#[doc = " @brief Compression mode"]
pub use self::OBCompressionMode as OB_COMPRESSION_MODE;
#[doc = " Compression Params"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct OBCompressionParams {
    #[doc = " Lossy compression threshold, range [0~255], recommended value is 9, the higher the threshold, the higher the compression ratio."]
    pub threshold: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of OBCompressionParams"][::std::mem::size_of::<OBCompressionParams>() - 4usize];
    ["Alignment of OBCompressionParams"][::std::mem::align_of::<OBCompressionParams>() - 1usize];
    ["Offset of field: OBCompressionParams::threshold"]
        [::std::mem::offset_of!(OBCompressionParams, threshold) - 0usize];
};
#[doc = " Compression Params"]
pub type ob_compression_params = OBCompressionParams;
#[doc = " Compression Params"]
pub type OB_COMPRESSION_PARAMS = OBCompressionParams;
#[doc = " @brief TOF Exposure Threshold"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct OBTofExposureThresholdControl {
    #[doc = "< Upper threshold, unit: ms"]
    pub upper: i32,
    #[doc = "< Lower threshold, unit: ms"]
    pub lower: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of OBTofExposureThresholdControl"]
        [::std::mem::size_of::<OBTofExposureThresholdControl>() - 8usize];
    ["Alignment of OBTofExposureThresholdControl"]
        [::std::mem::align_of::<OBTofExposureThresholdControl>() - 1usize];
    ["Offset of field: OBTofExposureThresholdControl::upper"]
        [::std::mem::offset_of!(OBTofExposureThresholdControl, upper) - 0usize];
    ["Offset of field: OBTofExposureThresholdControl::lower"]
        [::std::mem::offset_of!(OBTofExposureThresholdControl, lower) - 4usize];
};
#[doc = " @brief TOF Exposure Threshold"]
pub type ob_tof_exposure_threshold_control = OBTofExposureThresholdControl;
#[doc = " @brief TOF Exposure Threshold"]
pub type TOF_EXPOSURE_THRESHOLD_CONTROL = OBTofExposureThresholdControl;
#[doc = " @brief Close synchronize mode\n @brief Single device, neither process input trigger signal nor output trigger signal\n @brief Each Sensor in a single device automatically triggers"]
pub const OBSyncMode_OB_SYNC_MODE_CLOSE: OBSyncMode = 0;
#[doc = " @brief Standalone synchronize mode\n @brief Single device, neither process input trigger signal nor output trigger signal\n @brief Inside single device, RGB as Major sensor: RGB -> IR/Depth/TOF"]
pub const OBSyncMode_OB_SYNC_MODE_STANDALONE: OBSyncMode = 1;
#[doc = " @brief Primary synchronize mode\n @brief Primary device. Ignore process input trigger signal, only output trigger signal to secondary devices.\n @brief Inside single device, RGB as Major sensor: RGB -> IR/Depth/TOF"]
pub const OBSyncMode_OB_SYNC_MODE_PRIMARY: OBSyncMode = 2;
#[doc = " @brief Secondary synchronize mode\n @brief Secondary device. Both process input trigger signal and output trigger signal to other devices.\n @brief Different sensors in a single devices receive trigger signals respectively: ext trigger -> RGB && ext trigger -> IR/Depth/TOF\n\n @attention With the current Gemini 2 device set to this mode, each Sensor receives the first external trigger signal\n     after the stream is turned on and starts timing self-triggering at the set frame rate until the stream is turned off"]
pub const OBSyncMode_OB_SYNC_MODE_SECONDARY: OBSyncMode = 3;
#[doc = " @brief MCU Primary synchronize mode\n @brief Primary device. Ignore process input trigger signal, only output trigger signal to secondary devices.\n @brief Inside device, MCU is the primary signal source:  MCU -> RGB && MCU -> IR/Depth/TOF"]
pub const OBSyncMode_OB_SYNC_MODE_PRIMARY_MCU_TRIGGER: OBSyncMode = 4;
#[doc = " @brief IR Primary synchronize mode\n @brief Primary device. Ignore process input trigger signal, only output trigger signal to secondary devices.\n @brief Inside device, IR is the primary signal source: IR/Depth/TOF -> RGB"]
pub const OBSyncMode_OB_SYNC_MODE_PRIMARY_IR_TRIGGER: OBSyncMode = 5;
#[doc = " @brief Software trigger synchronize mode\n @brief Host, triggered by software control (receive the upper computer command trigger), at the same time to the trunk output trigger signal\n @brief Different sensors in a single machine receive trigger signals respectively: soft trigger -> RGB && soft trigger -> IR/Depth/TOF\n\n @attention Support product: Gemini2"]
pub const OBSyncMode_OB_SYNC_MODE_PRIMARY_SOFT_TRIGGER: OBSyncMode = 6;
#[doc = " @brief Software trigger synchronize mode as secondary device\n @brief The slave receives the external trigger signal (the external trigger signal comes from the soft trigger host) and outputs the trigger signal to\n the external relay.\n @brief Different sensors in a single machine receive trigger signals respectively: ext trigger -> RGB && ext  trigger -> IR/Depth/TOF"]
pub const OBSyncMode_OB_SYNC_MODE_SECONDARY_SOFT_TRIGGER: OBSyncMode = 7;
#[doc = " @brief IR and IMU sync signal"]
pub const OBSyncMode_OB_SYNC_MODE_IR_IMU_SYNC: OBSyncMode = 8;
#[doc = " @brief Unknown type"]
pub const OBSyncMode_OB_SYNC_MODE_UNKNOWN: OBSyncMode = 255;
#[doc = " @brief Sync mode\n @deprecated This define is deprecated, please use @ref ob_multi_device_sync_mode instead"]
pub type OBSyncMode = i32;
#[doc = " @brief Sync mode\n @deprecated This define is deprecated, please use @ref ob_multi_device_sync_mode instead"]
pub use self::OBSyncMode as ob_sync_mode;
#[doc = " @brief Sync mode\n @deprecated This define is deprecated, please use @ref ob_multi_device_sync_mode instead"]
pub use self::OBSyncMode as OB_SYNC_MODE;
#[doc = " @brief Device synchronization configuration\n @deprecated This structure is deprecated, please use @ref ob_multi_device_sync_config instead"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct OBDeviceSyncConfig {
    #[doc = " @brief Device synchronize mode"]
    pub syncMode: OBSyncMode,
    #[doc = " @brief IR Trigger signal input delay: Used to configure the delay between the IR/Depth/TOF Sensor receiving the trigger signal and starting exposure,\n Unit: microsecond\n\n @attention This parameter is invalid when the synchronization MODE is set to @ref OB_SYNC_MODE_PRIMARY_IR_TRIGGER"]
    pub irTriggerSignalInDelay: u16,
    #[doc = " @brief RGB trigger signal input delay is used to configure the delay from the time when an RGB Sensor receives the trigger signal to the time when the\n exposure starts. Unit: microsecond\n\n @attention This parameter is invalid when the synchronization MODE is set to @ref OB_SYNC_MODE_PRIMARY"]
    pub rgbTriggerSignalInDelay: u16,
    #[doc = " @brief Device trigger signal output delay, used to control the delay configuration of the host device to output trigger signals or the slave device to\n output trigger signals. Unit: microsecond\n\n @attention This parameter is invalid when the synchronization MODE is set to @ref OB_SYNC_MODE_CLOSE or @ref OB_SYNC_MODE_STANDALONE"]
    pub deviceTriggerSignalOutDelay: u16,
    #[doc = " @brief The device trigger signal output polarity is used to control the polarity configuration of the trigger signal output from the host device or the\n trigger signal output from the slave device\n @brief 0: forward pulse; 1: negative pulse\n\n @attention This parameter is invalid when the synchronization MODE is set to @ref OB_SYNC_MODE_CLOSE or @ref OB_SYNC_MODE_STANDALONE"]
    pub deviceTriggerSignalOutPolarity: u16,
    #[doc = " @brief MCU trigger frequency, used to configure the output frequency of MCU trigger signal in MCU master mode, unit: Hz\n @brief This configuration will directly affect the image output frame rate of the Sensor. Unit: FPS (frames per second)\n\n @attention This parameter is invalid only when the synchronization MODE is set to @ref OB_SYNC_MODE_PRIMARY_MCU_TRIGGER"]
    pub mcuTriggerFrequency: u16,
    #[doc = " @brief Device number. Users can mark the device with this number"]
    pub deviceId: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of OBDeviceSyncConfig"][::std::mem::size_of::<OBDeviceSyncConfig>() - 16usize];
    ["Alignment of OBDeviceSyncConfig"][::std::mem::align_of::<OBDeviceSyncConfig>() - 1usize];
    ["Offset of field: OBDeviceSyncConfig::syncMode"]
        [::std::mem::offset_of!(OBDeviceSyncConfig, syncMode) - 0usize];
    ["Offset of field: OBDeviceSyncConfig::irTriggerSignalInDelay"]
        [::std::mem::offset_of!(OBDeviceSyncConfig, irTriggerSignalInDelay) - 4usize];
    ["Offset of field: OBDeviceSyncConfig::rgbTriggerSignalInDelay"]
        [::std::mem::offset_of!(OBDeviceSyncConfig, rgbTriggerSignalInDelay) - 6usize];
    ["Offset of field: OBDeviceSyncConfig::deviceTriggerSignalOutDelay"]
        [::std::mem::offset_of!(OBDeviceSyncConfig, deviceTriggerSignalOutDelay) - 8usize];
    ["Offset of field: OBDeviceSyncConfig::deviceTriggerSignalOutPolarity"]
        [::std::mem::offset_of!(OBDeviceSyncConfig, deviceTriggerSignalOutPolarity) - 10usize];
    ["Offset of field: OBDeviceSyncConfig::mcuTriggerFrequency"]
        [::std::mem::offset_of!(OBDeviceSyncConfig, mcuTriggerFrequency) - 12usize];
    ["Offset of field: OBDeviceSyncConfig::deviceId"]
        [::std::mem::offset_of!(OBDeviceSyncConfig, deviceId) - 14usize];
};
#[doc = " @brief Device synchronization configuration\n @deprecated This structure is deprecated, please use @ref ob_multi_device_sync_config instead"]
pub type ob_device_sync_config = OBDeviceSyncConfig;
#[doc = " @brief Device synchronization configuration\n @deprecated This structure is deprecated, please use @ref ob_multi_device_sync_config instead"]
pub type OB_DEVICE_SYNC_CONFIG = OBDeviceSyncConfig;
pub const OBDepthWorkModeTag_OB_DEVICE_DEPTH_WORK_MODE: OBDepthWorkModeTag = 0;
pub const OBDepthWorkModeTag_OB_CUSTOM_DEPTH_WORK_MODE: OBDepthWorkModeTag = 1;
#[doc = " @brief Preset tag"]
pub type OBDepthWorkModeTag = i32;
#[doc = " @brief Preset tag"]
pub use self::OBDepthWorkModeTag as ob_depth_work_mode_tag;
#[doc = " @brief Depth work mode"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct OBDepthWorkMode {
    #[doc = " @brief Checksum of work mode"]
    pub checksum: [u8; 16usize],
    #[doc = " @brief Name of work mode"]
    pub name: [::std::os::raw::c_char; 32usize],
    #[doc = " @brief Preset tag"]
    pub tag: OBDepthWorkModeTag,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of OBDepthWorkMode"][::std::mem::size_of::<OBDepthWorkMode>() - 52usize];
    ["Alignment of OBDepthWorkMode"][::std::mem::align_of::<OBDepthWorkMode>() - 1usize];
    ["Offset of field: OBDepthWorkMode::checksum"]
        [::std::mem::offset_of!(OBDepthWorkMode, checksum) - 0usize];
    ["Offset of field: OBDepthWorkMode::name"]
        [::std::mem::offset_of!(OBDepthWorkMode, name) - 16usize];
    ["Offset of field: OBDepthWorkMode::tag"]
        [::std::mem::offset_of!(OBDepthWorkMode, tag) - 48usize];
};
#[doc = " @brief Depth work mode"]
pub type ob_depth_work_mode = OBDepthWorkMode;
#[doc = " @brief SequenceId fliter list item"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct OBSequenceIdItem {
    pub sequenceSelectId: ::std::os::raw::c_int,
    pub name: [::std::os::raw::c_char; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of OBSequenceIdItem"][::std::mem::size_of::<OBSequenceIdItem>() - 12usize];
    ["Alignment of OBSequenceIdItem"][::std::mem::align_of::<OBSequenceIdItem>() - 1usize];
    ["Offset of field: OBSequenceIdItem::sequenceSelectId"]
        [::std::mem::offset_of!(OBSequenceIdItem, sequenceSelectId) - 0usize];
    ["Offset of field: OBSequenceIdItem::name"]
        [::std::mem::offset_of!(OBSequenceIdItem, name) - 4usize];
};
#[doc = " @brief SequenceId fliter list item"]
pub type ob_sequence_id_item = OBSequenceIdItem;
pub const OBHoleFillingMode_OB_HOLE_FILL_TOP: OBHoleFillingMode = 0;
pub const OBHoleFillingMode_OB_HOLE_FILL_NEAREST: OBHoleFillingMode = 1;
pub const OBHoleFillingMode_OB_HOLE_FILL_FAREST: OBHoleFillingMode = 2;
#[doc = " @brief Hole fillig mode"]
pub type OBHoleFillingMode = i32;
#[doc = " @brief Hole fillig mode"]
pub use self::OBHoleFillingMode as ob_hole_filling_mode;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OBSpatialFastFilterParams {
    pub radius: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of OBSpatialFastFilterParams"]
        [::std::mem::size_of::<OBSpatialFastFilterParams>() - 1usize];
    ["Alignment of OBSpatialFastFilterParams"]
        [::std::mem::align_of::<OBSpatialFastFilterParams>() - 1usize];
    ["Offset of field: OBSpatialFastFilterParams::radius"]
        [::std::mem::offset_of!(OBSpatialFastFilterParams, radius) - 0usize];
};
pub type ob_spatial_fast_filter_params = OBSpatialFastFilterParams;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct OBSpatialModerateFilterParams {
    pub radius: u8,
    pub magnitude: u8,
    pub disp_diff: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of OBSpatialModerateFilterParams"]
        [::std::mem::size_of::<OBSpatialModerateFilterParams>() - 4usize];
    ["Alignment of OBSpatialModerateFilterParams"]
        [::std::mem::align_of::<OBSpatialModerateFilterParams>() - 1usize];
    ["Offset of field: OBSpatialModerateFilterParams::radius"]
        [::std::mem::offset_of!(OBSpatialModerateFilterParams, radius) - 0usize];
    ["Offset of field: OBSpatialModerateFilterParams::magnitude"]
        [::std::mem::offset_of!(OBSpatialModerateFilterParams, magnitude) - 1usize];
    ["Offset of field: OBSpatialModerateFilterParams::disp_diff"]
        [::std::mem::offset_of!(OBSpatialModerateFilterParams, disp_diff) - 2usize];
};
pub type ob_spatial_moderate_filter_params = OBSpatialModerateFilterParams;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct OBSpatialAdvancedFilterParams {
    pub magnitude: u8,
    pub alpha: f32,
    pub disp_diff: u16,
    pub radius: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of OBSpatialAdvancedFilterParams"]
        [::std::mem::size_of::<OBSpatialAdvancedFilterParams>() - 9usize];
    ["Alignment of OBSpatialAdvancedFilterParams"]
        [::std::mem::align_of::<OBSpatialAdvancedFilterParams>() - 1usize];
    ["Offset of field: OBSpatialAdvancedFilterParams::magnitude"]
        [::std::mem::offset_of!(OBSpatialAdvancedFilterParams, magnitude) - 0usize];
    ["Offset of field: OBSpatialAdvancedFilterParams::alpha"]
        [::std::mem::offset_of!(OBSpatialAdvancedFilterParams, alpha) - 1usize];
    ["Offset of field: OBSpatialAdvancedFilterParams::disp_diff"]
        [::std::mem::offset_of!(OBSpatialAdvancedFilterParams, disp_diff) - 5usize];
    ["Offset of field: OBSpatialAdvancedFilterParams::radius"]
        [::std::mem::offset_of!(OBSpatialAdvancedFilterParams, radius) - 7usize];
};
pub type ob_spatial_advanced_filter_params = OBSpatialAdvancedFilterParams;
pub const OB_EDGE_NOISE_REMOVAL_TYPE_OB_MG_FILTER: OB_EDGE_NOISE_REMOVAL_TYPE = 0;
pub const OB_EDGE_NOISE_REMOVAL_TYPE_OB_MGH_FILTER: OB_EDGE_NOISE_REMOVAL_TYPE = 1;
pub const OB_EDGE_NOISE_REMOVAL_TYPE_OB_MGA_FILTER: OB_EDGE_NOISE_REMOVAL_TYPE = 2;
pub const OB_EDGE_NOISE_REMOVAL_TYPE_OB_MGC_FILTER: OB_EDGE_NOISE_REMOVAL_TYPE = 3;
pub type OB_EDGE_NOISE_REMOVAL_TYPE = i32;
pub use self::OB_EDGE_NOISE_REMOVAL_TYPE as OBEdgeNoiseRemovalType;
pub use self::OB_EDGE_NOISE_REMOVAL_TYPE as ob_edge_noise_removal_type;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct OBEdgeNoiseRemovalFilterParams {
    pub type_: OBEdgeNoiseRemovalType,
    pub marginLeftTh: u16,
    pub marginRightTh: u16,
    pub marginTopTh: u16,
    pub marginBottomTh: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of OBEdgeNoiseRemovalFilterParams"]
        [::std::mem::size_of::<OBEdgeNoiseRemovalFilterParams>() - 12usize];
    ["Alignment of OBEdgeNoiseRemovalFilterParams"]
        [::std::mem::align_of::<OBEdgeNoiseRemovalFilterParams>() - 1usize];
    ["Offset of field: OBEdgeNoiseRemovalFilterParams::type_"]
        [::std::mem::offset_of!(OBEdgeNoiseRemovalFilterParams, type_) - 0usize];
    ["Offset of field: OBEdgeNoiseRemovalFilterParams::marginLeftTh"]
        [::std::mem::offset_of!(OBEdgeNoiseRemovalFilterParams, marginLeftTh) - 4usize];
    ["Offset of field: OBEdgeNoiseRemovalFilterParams::marginRightTh"]
        [::std::mem::offset_of!(OBEdgeNoiseRemovalFilterParams, marginRightTh) - 6usize];
    ["Offset of field: OBEdgeNoiseRemovalFilterParams::marginTopTh"]
        [::std::mem::offset_of!(OBEdgeNoiseRemovalFilterParams, marginTopTh) - 8usize];
    ["Offset of field: OBEdgeNoiseRemovalFilterParams::marginBottomTh"]
        [::std::mem::offset_of!(OBEdgeNoiseRemovalFilterParams, marginBottomTh) - 10usize];
};
pub type ob_edge_noise_removal_filter_params = OBEdgeNoiseRemovalFilterParams;
pub const OB_DDO_NOISE_REMOVAL_TYPE_OB_NR_LUT: OB_DDO_NOISE_REMOVAL_TYPE = 0;
pub const OB_DDO_NOISE_REMOVAL_TYPE_OB_NR_OVERALL: OB_DDO_NOISE_REMOVAL_TYPE = 1;
#[doc = " @brief Denoising method"]
pub type OB_DDO_NOISE_REMOVAL_TYPE = i32;
#[doc = " @brief Denoising method"]
pub use self::OB_DDO_NOISE_REMOVAL_TYPE as OBDDONoiseRemovalType;
#[doc = " @brief Denoising method"]
pub use self::OB_DDO_NOISE_REMOVAL_TYPE as ob_ddo_noise_removal_type;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct OBNoiseRemovalFilterParams {
    pub max_size: u16,
    pub disp_diff: u16,
    pub type_: OBDDONoiseRemovalType,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of OBNoiseRemovalFilterParams"]
        [::std::mem::size_of::<OBNoiseRemovalFilterParams>() - 8usize];
    ["Alignment of OBNoiseRemovalFilterParams"]
        [::std::mem::align_of::<OBNoiseRemovalFilterParams>() - 1usize];
    ["Offset of field: OBNoiseRemovalFilterParams::max_size"]
        [::std::mem::offset_of!(OBNoiseRemovalFilterParams, max_size) - 0usize];
    ["Offset of field: OBNoiseRemovalFilterParams::disp_diff"]
        [::std::mem::offset_of!(OBNoiseRemovalFilterParams, disp_diff) - 2usize];
    ["Offset of field: OBNoiseRemovalFilterParams::type_"]
        [::std::mem::offset_of!(OBNoiseRemovalFilterParams, type_) - 4usize];
};
pub type ob_noise_removal_filter_params = OBNoiseRemovalFilterParams;
#[doc = " @brief Control command protocol version number"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OBProtocolVersion {
    #[doc = " @brief Major version number"]
    pub major: u8,
    #[doc = " @brief Minor version number"]
    pub minor: u8,
    #[doc = " @brief Patch version number"]
    pub patch: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of OBProtocolVersion"][::std::mem::size_of::<OBProtocolVersion>() - 3usize];
    ["Alignment of OBProtocolVersion"][::std::mem::align_of::<OBProtocolVersion>() - 1usize];
    ["Offset of field: OBProtocolVersion::major"]
        [::std::mem::offset_of!(OBProtocolVersion, major) - 0usize];
    ["Offset of field: OBProtocolVersion::minor"]
        [::std::mem::offset_of!(OBProtocolVersion, minor) - 1usize];
    ["Offset of field: OBProtocolVersion::patch"]
        [::std::mem::offset_of!(OBProtocolVersion, patch) - 2usize];
};
#[doc = " @brief Control command protocol version number"]
pub type ob_protocol_version = OBProtocolVersion;
#[doc = "< Version 1.0"]
pub const OB_CMD_VERSION_OB_CMD_VERSION_V0: OB_CMD_VERSION = 0;
#[doc = "< Version 2.0"]
pub const OB_CMD_VERSION_OB_CMD_VERSION_V1: OB_CMD_VERSION = 1;
#[doc = "< Version 3.0"]
pub const OB_CMD_VERSION_OB_CMD_VERSION_V2: OB_CMD_VERSION = 2;
#[doc = "< Version 4.0"]
pub const OB_CMD_VERSION_OB_CMD_VERSION_V3: OB_CMD_VERSION = 3;
pub const OB_CMD_VERSION_OB_CMD_VERSION_NOVERSION: OB_CMD_VERSION = 65534;
#[doc = "< Invalid version"]
pub const OB_CMD_VERSION_OB_CMD_VERSION_INVALID: OB_CMD_VERSION = 65535;
#[doc = " @brief Command version associated with property id"]
pub type OB_CMD_VERSION = i32;
#[doc = " @brief Command version associated with property id"]
pub use self::OB_CMD_VERSION as OBCmdVersion;
#[doc = " @brief Command version associated with property id"]
pub use self::OB_CMD_VERSION as ob_cmd_version;
#[doc = " @brief IP address configuration for network devices (IPv4)"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct OBNetIpConfig {
    #[doc = " @brief DHCP status\n\n @note 0: static IP; 1: DHCP"]
    pub dhcp: u16,
    #[doc = " @brief IP address (IPv4, big endian: 192.168.1.10, address[0] = 192, address[1] = 168, address[2] = 1, address[3] = 10)"]
    pub address: [u8; 4usize],
    #[doc = " @brief Subnet mask (big endian)"]
    pub mask: [u8; 4usize],
    #[doc = " @brief Gateway (big endian)"]
    pub gateway: [u8; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of OBNetIpConfig"][::std::mem::size_of::<OBNetIpConfig>() - 14usize];
    ["Alignment of OBNetIpConfig"][::std::mem::align_of::<OBNetIpConfig>() - 1usize];
    ["Offset of field: OBNetIpConfig::dhcp"][::std::mem::offset_of!(OBNetIpConfig, dhcp) - 0usize];
    ["Offset of field: OBNetIpConfig::address"]
        [::std::mem::offset_of!(OBNetIpConfig, address) - 2usize];
    ["Offset of field: OBNetIpConfig::mask"][::std::mem::offset_of!(OBNetIpConfig, mask) - 6usize];
    ["Offset of field: OBNetIpConfig::gateway"]
        [::std::mem::offset_of!(OBNetIpConfig, gateway) - 10usize];
};
#[doc = " @brief IP address configuration for network devices (IPv4)"]
pub type ob_net_ip_config = OBNetIpConfig;
#[doc = " @brief IP address configuration for network devices (IPv4)"]
pub type DEVICE_IP_ADDR_CONFIG = OBNetIpConfig;
#[doc = "< USB"]
pub const OBCommunicationType_OB_COMM_USB: OBCommunicationType = 0;
#[doc = "< Ethernet"]
pub const OBCommunicationType_OB_COMM_NET: OBCommunicationType = 1;
#[doc = " @brief Device communication mode"]
pub type OBCommunicationType = i32;
#[doc = " @brief Device communication mode"]
pub use self::OBCommunicationType as ob_communication_type;
#[doc = " @brief Device communication mode"]
pub use self::OBCommunicationType as OB_COMMUNICATION_TYPE;
#[doc = "< No plugin"]
pub const OBUSBPowerState_OB_USB_POWER_NO_PLUGIN: OBUSBPowerState = 0;
#[doc = "< 5V/0.9A"]
pub const OBUSBPowerState_OB_USB_POWER_5V_0A9: OBUSBPowerState = 1;
#[doc = "< 5V/1.5A"]
pub const OBUSBPowerState_OB_USB_POWER_5V_1A5: OBUSBPowerState = 2;
#[doc = "< 5V/3.0A"]
pub const OBUSBPowerState_OB_USB_POWER_5V_3A0: OBUSBPowerState = 3;
#[doc = " @brief USB power status"]
pub type OBUSBPowerState = i32;
#[doc = " @brief USB power status"]
pub use self::OBUSBPowerState as ob_usb_power_state;
#[doc = "< No plugin"]
pub const OBDCPowerState_OB_DC_POWER_NO_PLUGIN: OBDCPowerState = 0;
#[doc = "< Plugin"]
pub const OBDCPowerState_OB_DC_POWER_PLUGIN: OBDCPowerState = 1;
#[doc = " @brief DC power status"]
pub type OBDCPowerState = i32;
#[doc = " @brief DC power status"]
pub use self::OBDCPowerState as ob_dc_power_state;
#[doc = "< Rotate 0"]
pub const ob_rotate_degree_type_OB_ROTATE_DEGREE_0: ob_rotate_degree_type = 0;
#[doc = "< Rotate 90"]
pub const ob_rotate_degree_type_OB_ROTATE_DEGREE_90: ob_rotate_degree_type = 90;
#[doc = "< Rotate 180"]
pub const ob_rotate_degree_type_OB_ROTATE_DEGREE_180: ob_rotate_degree_type = 180;
#[doc = "< Rotate 270"]
pub const ob_rotate_degree_type_OB_ROTATE_DEGREE_270: ob_rotate_degree_type = 270;
#[doc = " @brief Rotate degree"]
pub type ob_rotate_degree_type = i32;
#[doc = " @brief Rotate degree"]
pub use self::ob_rotate_degree_type as OBRotateDegreeType;
#[doc = "< Close"]
pub const ob_power_line_freq_mode_OB_POWER_LINE_FREQ_MODE_CLOSE: ob_power_line_freq_mode = 0;
#[doc = "< 50Hz"]
pub const ob_power_line_freq_mode_OB_POWER_LINE_FREQ_MODE_50HZ: ob_power_line_freq_mode = 1;
#[doc = "< 60Hz"]
pub const ob_power_line_freq_mode_OB_POWER_LINE_FREQ_MODE_60HZ: ob_power_line_freq_mode = 2;
#[doc = " @brief Power line frequency mode, for color camera anti-flicker configuration"]
pub type ob_power_line_freq_mode = i32;
#[doc = " @brief Power line frequency mode, for color camera anti-flicker configuration"]
pub use self::ob_power_line_freq_mode as OBPowerLineFreqMode;
#[doc = " @brief Only FrameSet that contains all types of data frames will be output"]
pub const OB_FRAME_AGGREGATE_OUTPUT_MODE_OB_FRAME_AGGREGATE_OUTPUT_ALL_TYPE_FRAME_REQUIRE:
    OB_FRAME_AGGREGATE_OUTPUT_MODE = 0;
#[doc = " @brief Color Frame Require output mode\n @brief Suitable for Color using H264, H265 and other inter-frame encoding format open stream\n\n @attention In this mode, the user may return null when getting a non-Color type data frame from the acquired FrameSet"]
pub const OB_FRAME_AGGREGATE_OUTPUT_MODE_OB_FRAME_AGGREGATE_OUTPUT_COLOR_FRAME_REQUIRE:
    OB_FRAME_AGGREGATE_OUTPUT_MODE = 1;
#[doc = " @brief FrameSet for any case will be output\n\n @attention In this mode, the user may return null when getting the specified type of data frame from the acquired FrameSet"]
pub const OB_FRAME_AGGREGATE_OUTPUT_MODE_OB_FRAME_AGGREGATE_OUTPUT_ANY_SITUATION:
    OB_FRAME_AGGREGATE_OUTPUT_MODE = 2;
#[doc = " @brief Disable Frame Aggreate\n\n @attention In this mode, All types of data frames will output independently."]
pub const OB_FRAME_AGGREGATE_OUTPUT_MODE_OB_FRAME_AGGREGATE_OUTPUT_DISABLE:
    OB_FRAME_AGGREGATE_OUTPUT_MODE = 3;
#[doc = " @brief Frame aggregate output mode"]
pub type OB_FRAME_AGGREGATE_OUTPUT_MODE = i32;
#[doc = " @brief Frame aggregate output mode"]
pub use self::OB_FRAME_AGGREGATE_OUTPUT_MODE as OBFrameAggregateOutputMode;
#[doc = " @brief Frame aggregate output mode"]
pub use self::OB_FRAME_AGGREGATE_OUTPUT_MODE as ob_frame_aggregate_output_mode;
pub const OB_COORDINATE_SYSTEM_TYPE_OB_LEFT_HAND_COORDINATE_SYSTEM: OB_COORDINATE_SYSTEM_TYPE = 0;
pub const OB_COORDINATE_SYSTEM_TYPE_OB_RIGHT_HAND_COORDINATE_SYSTEM: OB_COORDINATE_SYSTEM_TYPE = 1;
#[doc = " @brief Enumeration of point cloud coordinate system types"]
pub type OB_COORDINATE_SYSTEM_TYPE = i32;
#[doc = " @brief Enumeration of point cloud coordinate system types"]
pub use self::OB_COORDINATE_SYSTEM_TYPE as OBCoordinateSystemType;
#[doc = " @brief Enumeration of point cloud coordinate system types"]
pub use self::OB_COORDINATE_SYSTEM_TYPE as ob_coordinate_system_type;
#[doc = " @brief User mode (default mode), which provides full camera device functionality"]
pub const OB_DEVICE_DEVELOPMENT_MODE_OB_USER_MODE: OB_DEVICE_DEVELOPMENT_MODE = 0;
#[doc = " @brief Developer mode, which allows developers to access the operating system and software/hardware resources on the device directly"]
pub const OB_DEVICE_DEVELOPMENT_MODE_OB_DEVELOPER_MODE: OB_DEVICE_DEVELOPMENT_MODE = 1;
#[doc = " @brief Enumeration of device development modes"]
pub type OB_DEVICE_DEVELOPMENT_MODE = i32;
#[doc = " @brief Enumeration of device development modes"]
pub use self::OB_DEVICE_DEVELOPMENT_MODE as OBDeviceDevelopmentMode;
#[doc = " @brief Enumeration of device development modes"]
pub use self::OB_DEVICE_DEVELOPMENT_MODE as ob_device_development_mode;
#[doc = " @brief free run mode\n @brief The device does not synchronize with other devices,\n @brief The Color and Depth can be set to different frame rates."]
pub const ob_multi_device_sync_mode_OB_MULTI_DEVICE_SYNC_MODE_FREE_RUN: ob_multi_device_sync_mode =
    1;
#[doc = " @brief standalone mode\n @brief The device does not synchronize with other devices.\n @brief The Color and Depth should be set to same frame rates, the Color and Depth will be synchronized."]
pub const ob_multi_device_sync_mode_OB_MULTI_DEVICE_SYNC_MODE_STANDALONE:
    ob_multi_device_sync_mode = 2;
#[doc = " @brief primary mode\n @brief The device is the primary device in the multi-device system, it will output the trigger signal via VSYNC_OUT pin on synchronization port by\n default.\n @brief The Color and Depth should be set to same frame rates, the Color and Depth will be synchronized and can be adjusted by @ref colorDelayUs, @ref\n depthDelayUs or @ref trigger2ImageDelayUs."]
pub const ob_multi_device_sync_mode_OB_MULTI_DEVICE_SYNC_MODE_PRIMARY: ob_multi_device_sync_mode =
    4;
#[doc = " @brief secondary mode\n @brief The device is the secondary device in the multi-device system, it will receive the trigger signal via VSYNC_IN pin on synchronization port. It\n will out the trigger signal via VSYNC_OUT pin on synchronization port by default.\n @brief The Color and Depth should be set to same frame rates, the Color and Depth will be synchronized and can be adjusted by @ref colorDelayUs, @ref\n depthDelayUs or @ref trigger2ImageDelayUs.\n @brief After starting the stream, the device will wait for the trigger signal to start capturing images, and will stop capturing images when the trigger\n signal is stopped.\n\n @attention The frequency of the trigger signal should be same as the frame rate of the stream profile which is set when starting the stream."]
pub const ob_multi_device_sync_mode_OB_MULTI_DEVICE_SYNC_MODE_SECONDARY: ob_multi_device_sync_mode =
    8;
#[doc = " @brief secondary synced mode\n @brief The device is the secondary device in the multi-device system, it will receive the trigger signal via VSYNC_IN pin on synchronization port. It\n will out the trigger signal via VSYNC_OUT pin on synchronization port by default.\n @brief The Color and Depth should be set to same frame rates, the Color and Depth will be synchronized and can be adjusted by @ref colorDelayUs, @ref\n depthDelayUs or @ref trigger2ImageDelayUs.\n @brief After starting the stream, the device will be immediately start capturing images, and will adjust the capture time when the trigger signal is\n received to synchronize with the primary device. If the trigger signal is stopped, the device will still capture images.\n\n @attention The frequency of the trigger signal should be same as the frame rate of the stream profile which is set when starting the stream."]
pub const ob_multi_device_sync_mode_OB_MULTI_DEVICE_SYNC_MODE_SECONDARY_SYNCED:
    ob_multi_device_sync_mode = 16;
#[doc = " @brief software triggering mode\n @brief The device will start one time image capture after receiving the capture command and will output the trigger signal via VSYNC_OUT pin by default.\n The capture command can be sent form host by call @ref ob_device_trigger_capture. The number of images captured each time can be set by @ref\n framesPerTrigger.\n @brief The Color and Depth should be set to same frame rates, the Color and Depth will be synchronized and can be adjusted by @ref colorDelayUs, @ref\n depthDelayUs or @ref trigger2ImageDelayUs.\n\n @brief The frequency of the user call @ref ob_device_trigger_capture to send the capture command multiplied by the number of frames per trigger should be\n less than the frame rate of the stream profile which is set when starting the stream."]
pub const ob_multi_device_sync_mode_OB_MULTI_DEVICE_SYNC_MODE_SOFTWARE_TRIGGERING:
    ob_multi_device_sync_mode = 32;
#[doc = " @brief hardware triggering mode\n @brief The device will start one time image capture after receiving the trigger signal via VSYNC_IN pin on synchronization port and will output the\n trigger signal via VSYNC_OUT pin by default. The number of images captured each time can be set by @ref framesPerTrigger.\n @brief The Color and Depth should be set to same frame rates, the Color and Depth will be synchronized and can be adjusted by @ref colorDelayUs, @ref\n depthDelayUs or @ref trigger2ImageDelayUs.\n\n @attention The frequency of the trigger signal multiplied by the number of frames per trigger should be less than the frame rate of the stream profile\n which is set when starting the stream.\n @attention The trigger signal input via VSYNC_IN pin on synchronization port should be ouput by other device via VSYNC_OUT pin in hardware triggering\n mode or software triggering mode.\n @attention Due to different models may have different signal input requirements, please do not use different models to output trigger\n signal as input-trigger signal."]
pub const ob_multi_device_sync_mode_OB_MULTI_DEVICE_SYNC_MODE_HARDWARE_TRIGGERING:
    ob_multi_device_sync_mode = 64;
#[doc = " @brief IR and IMU sync mode"]
pub const ob_multi_device_sync_mode_OB_MULTI_DEVICE_SYNC_MODE_IR_IMU_SYNC:
    ob_multi_device_sync_mode = 128;
#[doc = " @brief The synchronization mode of the device."]
pub type ob_multi_device_sync_mode = i32;
#[doc = " @brief The synchronization mode of the device."]
pub use self::ob_multi_device_sync_mode as OBMultiDeviceSyncMode;
#[doc = " @brief The synchronization configuration of the device."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ob_multi_device_sync_config {
    #[doc = " @brief The sync mode of the device."]
    pub syncMode: OBMultiDeviceSyncMode,
    #[doc = " @brief The delay time of the depth image capture after receiving the capture command or trigger signal in microseconds.\n\n @attention This parameter is only valid for some models, please refer to the product manual for details."]
    pub depthDelayUs: ::std::os::raw::c_int,
    #[doc = " @brief The delay time of the color image capture after receiving the capture command or trigger signal in microseconds.\n\n @attention This parameter is only valid for some models, please refer to the product manual for details."]
    pub colorDelayUs: ::std::os::raw::c_int,
    #[doc = " @brief The delay time of the image capture after receiving the capture command or trigger signal in microseconds.\n @brief The depth and color images are captured synchronously as the product design and can not change the delay between the depth and color images.\n\n @attention For Orbbec Astra 2 device, this parameter is valid only when the @ref triggerOutDelayUs is set to 0.\n @attention This parameter is only valid for some models to replace @ref depthDelayUs and @ref colorDelayUs, please refer to the product manual for\n details."]
    pub trigger2ImageDelayUs: ::std::os::raw::c_int,
    #[doc = " @brief Trigger signal output enable flag.\n @brief After the trigger signal output is enabled, the trigger signal will be output when the capture command or trigger signal is received. User can\n adjust the delay time of the trigger signal output by @ref triggerOutDelayUs.\n\n @attention For some models, the trigger signal output is always enabled and cannot be disabled.\n @attention If device is in the @ref OB_MULTI_DEVICE_SYNC_MODE_FREE_RUN or @ref OB_MULTI_DEVICE_SYNC_MODE_STANDALONE mode, the trigger signal output is\n always disabled. Set this parameter to true will not take effect."]
    pub triggerOutEnable: bool,
    #[doc = " @brief The delay time of the trigger signal output after receiving the capture command or trigger signal in microseconds.\n\n @attention For Orbbec Astra 2 device, only supported -1 and 0. -1 means the trigger signal output delay is automatically adjusted by the device, 0 means\n the trigger signal output is disabled."]
    pub triggerOutDelayUs: ::std::os::raw::c_int,
    #[doc = " @brief The frame number of each stream after each trigger in triggering mode.\n\n @attention This parameter is only valid when the triggering mode is set to @ref OB_MULTI_DEVICE_SYNC_MODE_HARDWARE_TRIGGERING or @ref\n OB_MULTI_DEVICE_SYNC_MODE_SOFTWARE_TRIGGERING.\n @attention The trigger frequency multiplied by the number of frames per trigger cannot exceed the maximum frame rate of the stream profile which is set\n when starting the stream."]
    pub framesPerTrigger: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ob_multi_device_sync_config"]
        [::std::mem::size_of::<ob_multi_device_sync_config>() - 25usize];
    ["Alignment of ob_multi_device_sync_config"]
        [::std::mem::align_of::<ob_multi_device_sync_config>() - 1usize];
    ["Offset of field: ob_multi_device_sync_config::syncMode"]
        [::std::mem::offset_of!(ob_multi_device_sync_config, syncMode) - 0usize];
    ["Offset of field: ob_multi_device_sync_config::depthDelayUs"]
        [::std::mem::offset_of!(ob_multi_device_sync_config, depthDelayUs) - 4usize];
    ["Offset of field: ob_multi_device_sync_config::colorDelayUs"]
        [::std::mem::offset_of!(ob_multi_device_sync_config, colorDelayUs) - 8usize];
    ["Offset of field: ob_multi_device_sync_config::trigger2ImageDelayUs"]
        [::std::mem::offset_of!(ob_multi_device_sync_config, trigger2ImageDelayUs) - 12usize];
    ["Offset of field: ob_multi_device_sync_config::triggerOutEnable"]
        [::std::mem::offset_of!(ob_multi_device_sync_config, triggerOutEnable) - 16usize];
    ["Offset of field: ob_multi_device_sync_config::triggerOutDelayUs"]
        [::std::mem::offset_of!(ob_multi_device_sync_config, triggerOutDelayUs) - 17usize];
    ["Offset of field: ob_multi_device_sync_config::framesPerTrigger"]
        [::std::mem::offset_of!(ob_multi_device_sync_config, framesPerTrigger) - 21usize];
};
#[doc = " @brief The synchronization configuration of the device."]
pub type OBMultiDeviceSyncConfig = ob_multi_device_sync_config;
#[doc = " @brief The timestamp reset configuration of the device.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ob_device_timestamp_reset_config {
    #[doc = " @brief Whether to enable the timestamp reset function.\n @brief If the timestamp reset function is enabled, the timer for calculating the timestamp for output frames will be reset to 0 when the timestamp reset\n command or timestamp reset signal is received, and one timestamp reset signal will be output via TIMER_SYNC_OUT pin on synchronization port by default.\n The timestamp reset signal is input via TIMER_SYNC_IN pin on the synchronization port.\n\n @attention For some models, the timestamp reset function is always enabled and cannot be disabled."]
    pub enable: bool,
    #[doc = " @brief The delay time of executing the timestamp reset function after receiving the command or signal in microseconds."]
    pub timestamp_reset_delay_us: ::std::os::raw::c_int,
    #[doc = " @brief the timestamp reset signal output enable flag.\n\n @attention For some models, the timestamp reset signal output is always enabled and cannot be disabled."]
    pub timestamp_reset_signal_output_enable: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ob_device_timestamp_reset_config"]
        [::std::mem::size_of::<ob_device_timestamp_reset_config>() - 6usize];
    ["Alignment of ob_device_timestamp_reset_config"]
        [::std::mem::align_of::<ob_device_timestamp_reset_config>() - 1usize];
    ["Offset of field: ob_device_timestamp_reset_config::enable"]
        [::std::mem::offset_of!(ob_device_timestamp_reset_config, enable) - 0usize];
    ["Offset of field: ob_device_timestamp_reset_config::timestamp_reset_delay_us"][::std::mem::offset_of!(
        ob_device_timestamp_reset_config,
        timestamp_reset_delay_us
    ) - 1usize];
    ["Offset of field: ob_device_timestamp_reset_config::timestamp_reset_signal_output_enable"][::std::mem::offset_of!(
        ob_device_timestamp_reset_config,
        timestamp_reset_signal_output_enable
    )
        - 5usize];
};
#[doc = " @brief The timestamp reset configuration of the device.\n"]
pub type OBDeviceTimestampResetConfig = ob_device_timestamp_reset_config;
#[doc = " @brief Baseline calibration parameters"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct BASELINE_CALIBRATION_PARAM {
    #[doc = " @brief Baseline length"]
    pub baseline: f32,
    #[doc = " @brief Calibration distance"]
    pub zpd: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of BASELINE_CALIBRATION_PARAM"]
        [::std::mem::size_of::<BASELINE_CALIBRATION_PARAM>() - 8usize];
    ["Alignment of BASELINE_CALIBRATION_PARAM"]
        [::std::mem::align_of::<BASELINE_CALIBRATION_PARAM>() - 1usize];
    ["Offset of field: BASELINE_CALIBRATION_PARAM::baseline"]
        [::std::mem::offset_of!(BASELINE_CALIBRATION_PARAM, baseline) - 0usize];
    ["Offset of field: BASELINE_CALIBRATION_PARAM::zpd"]
        [::std::mem::offset_of!(BASELINE_CALIBRATION_PARAM, zpd) - 4usize];
};
#[doc = " @brief Baseline calibration parameters"]
pub type ob_baseline_calibration_param = BASELINE_CALIBRATION_PARAM;
#[doc = " @brief Baseline calibration parameters"]
pub type OBBaselineCalibrationParam = BASELINE_CALIBRATION_PARAM;
#[doc = " @brief HDR Configuration"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct HDR_CONFIG {
    #[doc = " @brief Enable/disable HDR, after enabling HDR, the exposure_1 and gain_1 will be used as the first exposure and gain, and the exposure_2 and gain_2 will\n be used as the second exposure and gain. The output image will be alternately exposed and gain between the first and second\n exposure and gain.\n\n @attention After enabling HDR, the auto exposure will be disabled."]
    pub enable: u8,
    #[doc = "< Sequence name"]
    pub sequence_name: u8,
    #[doc = "< Exposure time 1"]
    pub exposure_1: u32,
    #[doc = "< Gain 1"]
    pub gain_1: u32,
    #[doc = "< Exposure time 2"]
    pub exposure_2: u32,
    #[doc = "< Gain 2"]
    pub gain_2: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of HDR_CONFIG"][::std::mem::size_of::<HDR_CONFIG>() - 18usize];
    ["Alignment of HDR_CONFIG"][::std::mem::align_of::<HDR_CONFIG>() - 1usize];
    ["Offset of field: HDR_CONFIG::enable"][::std::mem::offset_of!(HDR_CONFIG, enable) - 0usize];
    ["Offset of field: HDR_CONFIG::sequence_name"]
        [::std::mem::offset_of!(HDR_CONFIG, sequence_name) - 1usize];
    ["Offset of field: HDR_CONFIG::exposure_1"]
        [::std::mem::offset_of!(HDR_CONFIG, exposure_1) - 2usize];
    ["Offset of field: HDR_CONFIG::gain_1"][::std::mem::offset_of!(HDR_CONFIG, gain_1) - 6usize];
    ["Offset of field: HDR_CONFIG::exposure_2"]
        [::std::mem::offset_of!(HDR_CONFIG, exposure_2) - 10usize];
    ["Offset of field: HDR_CONFIG::gain_2"][::std::mem::offset_of!(HDR_CONFIG, gain_2) - 14usize];
};
#[doc = " @brief HDR Configuration"]
pub type ob_hdr_config = HDR_CONFIG;
#[doc = " @brief HDR Configuration"]
pub type OBHdrConfig = HDR_CONFIG;
#[doc = " @brief The rect of the region of interest"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct AE_ROI {
    pub x0_left: i16,
    pub y0_top: i16,
    pub x1_right: i16,
    pub y1_bottom: i16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AE_ROI"][::std::mem::size_of::<AE_ROI>() - 8usize];
    ["Alignment of AE_ROI"][::std::mem::align_of::<AE_ROI>() - 1usize];
    ["Offset of field: AE_ROI::x0_left"][::std::mem::offset_of!(AE_ROI, x0_left) - 0usize];
    ["Offset of field: AE_ROI::y0_top"][::std::mem::offset_of!(AE_ROI, y0_top) - 2usize];
    ["Offset of field: AE_ROI::x1_right"][::std::mem::offset_of!(AE_ROI, x1_right) - 4usize];
    ["Offset of field: AE_ROI::y1_bottom"][::std::mem::offset_of!(AE_ROI, y1_bottom) - 6usize];
};
#[doc = " @brief The rect of the region of interest"]
pub type ob_region_of_interest = AE_ROI;
#[doc = " @brief The rect of the region of interest"]
pub type OBRegionOfInterest = AE_ROI;
pub const OBFilterConfigValueType_OB_FILTER_CONFIG_VALUE_TYPE_INVALID: OBFilterConfigValueType = -1;
pub const OBFilterConfigValueType_OB_FILTER_CONFIG_VALUE_TYPE_INT: OBFilterConfigValueType = 0;
pub const OBFilterConfigValueType_OB_FILTER_CONFIG_VALUE_TYPE_FLOAT: OBFilterConfigValueType = 1;
pub const OBFilterConfigValueType_OB_FILTER_CONFIG_VALUE_TYPE_BOOLEAN: OBFilterConfigValueType = 2;
pub type OBFilterConfigValueType = i32;
pub use self::OBFilterConfigValueType as ob_filter_config_value_type;
#[doc = " @brief  Configuration Item for the filter"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct OBFilterConfigSchemaItem {
    #[doc = "< Name of the configuration item"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "< Value type of the configuration item"]
    pub type_: OBFilterConfigValueType,
    #[doc = "< Minimum value casted to double"]
    pub min: f64,
    #[doc = "< Maximum value casted to double"]
    pub max: f64,
    #[doc = "< Step value casted to double"]
    pub step: f64,
    #[doc = "< Default value casted to double"]
    pub def: f64,
    #[doc = "< Description of the configuration item"]
    pub desc: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of OBFilterConfigSchemaItem"]
        [::std::mem::size_of::<OBFilterConfigSchemaItem>() - 52usize];
    ["Alignment of OBFilterConfigSchemaItem"]
        [::std::mem::align_of::<OBFilterConfigSchemaItem>() - 1usize];
    ["Offset of field: OBFilterConfigSchemaItem::name"]
        [::std::mem::offset_of!(OBFilterConfigSchemaItem, name) - 0usize];
    ["Offset of field: OBFilterConfigSchemaItem::type_"]
        [::std::mem::offset_of!(OBFilterConfigSchemaItem, type_) - 8usize];
    ["Offset of field: OBFilterConfigSchemaItem::min"]
        [::std::mem::offset_of!(OBFilterConfigSchemaItem, min) - 12usize];
    ["Offset of field: OBFilterConfigSchemaItem::max"]
        [::std::mem::offset_of!(OBFilterConfigSchemaItem, max) - 20usize];
    ["Offset of field: OBFilterConfigSchemaItem::step"]
        [::std::mem::offset_of!(OBFilterConfigSchemaItem, step) - 28usize];
    ["Offset of field: OBFilterConfigSchemaItem::def"]
        [::std::mem::offset_of!(OBFilterConfigSchemaItem, def) - 36usize];
    ["Offset of field: OBFilterConfigSchemaItem::desc"]
        [::std::mem::offset_of!(OBFilterConfigSchemaItem, desc) - 44usize];
};
#[doc = " @brief  Configuration Item for the filter"]
pub type ob_filter_config_schema_item = OBFilterConfigSchemaItem;
#[doc = " @brief struct of serial number"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OBDeviceSerialNumber {
    pub numberStr: [::std::os::raw::c_char; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of OBDeviceSerialNumber"][::std::mem::size_of::<OBDeviceSerialNumber>() - 16usize];
    ["Alignment of OBDeviceSerialNumber"][::std::mem::align_of::<OBDeviceSerialNumber>() - 1usize];
    ["Offset of field: OBDeviceSerialNumber::numberStr"]
        [::std::mem::offset_of!(OBDeviceSerialNumber, numberStr) - 0usize];
};
#[doc = " @brief struct of serial number"]
pub type ob_device_serial_number = OBDeviceSerialNumber;
#[doc = " @brief struct of serial number"]
pub type OBSerialNumber = OBDeviceSerialNumber;
#[doc = " @brief struct of serial number"]
pub type ob_serial_number = OBDeviceSerialNumber;
#[doc = " @brief Disparity offset interleaving configuration"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OBDispOffsetConfig {
    pub enable: u8,
    pub offset0: u8,
    pub offset1: u8,
    pub reserved: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of OBDispOffsetConfig"][::std::mem::size_of::<OBDispOffsetConfig>() - 4usize];
    ["Alignment of OBDispOffsetConfig"][::std::mem::align_of::<OBDispOffsetConfig>() - 1usize];
    ["Offset of field: OBDispOffsetConfig::enable"]
        [::std::mem::offset_of!(OBDispOffsetConfig, enable) - 0usize];
    ["Offset of field: OBDispOffsetConfig::offset0"]
        [::std::mem::offset_of!(OBDispOffsetConfig, offset0) - 1usize];
    ["Offset of field: OBDispOffsetConfig::offset1"]
        [::std::mem::offset_of!(OBDispOffsetConfig, offset1) - 2usize];
    ["Offset of field: OBDispOffsetConfig::reserved"]
        [::std::mem::offset_of!(OBDispOffsetConfig, reserved) - 3usize];
};
#[doc = " @brief Disparity offset interleaving configuration"]
pub type ob_disp_offset_config = OBDispOffsetConfig;
#[doc = " @brief Timestamp when the frame is captured.\n @attention Different device models may have different units. It is recommended to use the timestamp related functions to get the timestamp in the\n correct units."]
pub const ob_frame_metadata_type_OB_FRAME_METADATA_TYPE_TIMESTAMP: ob_frame_metadata_type = 0;
#[doc = " @brief Timestamp in the middle of the capture.\n @brief Usually is the middle of the exposure time.\n\n @attention Different device models may have different units."]
pub const ob_frame_metadata_type_OB_FRAME_METADATA_TYPE_SENSOR_TIMESTAMP: ob_frame_metadata_type =
    1;
#[doc = " @brief The number of current frame."]
pub const ob_frame_metadata_type_OB_FRAME_METADATA_TYPE_FRAME_NUMBER: ob_frame_metadata_type = 2;
#[doc = " @brief Auto exposure status\n @brief If the value is 0, it means the auto exposure is disabled. Otherwise, it means the auto exposure is enabled."]
pub const ob_frame_metadata_type_OB_FRAME_METADATA_TYPE_AUTO_EXPOSURE: ob_frame_metadata_type = 3;
#[doc = " @brief Exposure time\n\n @attention Different sensor may have different units. Usually, it is 100us for color sensor and 1us for depth/infrared sensor."]
pub const ob_frame_metadata_type_OB_FRAME_METADATA_TYPE_EXPOSURE: ob_frame_metadata_type = 4;
#[doc = " @brief Gain\n\n @attention For some device models, the gain value represents the gain level, not the multiplier."]
pub const ob_frame_metadata_type_OB_FRAME_METADATA_TYPE_GAIN: ob_frame_metadata_type = 5;
#[doc = " @brief Auto white balance status\n @brief If the value is 0, it means the auto white balance is disabled. Otherwise, it means the auto white balance is enabled."]
pub const ob_frame_metadata_type_OB_FRAME_METADATA_TYPE_AUTO_WHITE_BALANCE: ob_frame_metadata_type =
    6;
#[doc = " @brief White balance"]
pub const ob_frame_metadata_type_OB_FRAME_METADATA_TYPE_WHITE_BALANCE: ob_frame_metadata_type = 7;
#[doc = " @brief Brightness"]
pub const ob_frame_metadata_type_OB_FRAME_METADATA_TYPE_BRIGHTNESS: ob_frame_metadata_type = 8;
#[doc = " @brief Contrast"]
pub const ob_frame_metadata_type_OB_FRAME_METADATA_TYPE_CONTRAST: ob_frame_metadata_type = 9;
#[doc = " @brief Saturation"]
pub const ob_frame_metadata_type_OB_FRAME_METADATA_TYPE_SATURATION: ob_frame_metadata_type = 10;
#[doc = " @brief Sharpness"]
pub const ob_frame_metadata_type_OB_FRAME_METADATA_TYPE_SHARPNESS: ob_frame_metadata_type = 11;
#[doc = " @brief Backlight compensation"]
pub const ob_frame_metadata_type_OB_FRAME_METADATA_TYPE_BACKLIGHT_COMPENSATION:
    ob_frame_metadata_type = 12;
#[doc = " @brief Hue"]
pub const ob_frame_metadata_type_OB_FRAME_METADATA_TYPE_HUE: ob_frame_metadata_type = 13;
#[doc = " @brief Gamma"]
pub const ob_frame_metadata_type_OB_FRAME_METADATA_TYPE_GAMMA: ob_frame_metadata_type = 14;
#[doc = " @brief Power line frequency\n @brief For anti-flickering, 0: Close, 1: 50Hz, 2: 60Hz, 3: Auto"]
pub const ob_frame_metadata_type_OB_FRAME_METADATA_TYPE_POWER_LINE_FREQUENCY:
    ob_frame_metadata_type = 15;
#[doc = " @brief Low light compensation\n\n @attention The low light compensation is a feature inside the device, and can not manually control it."]
pub const ob_frame_metadata_type_OB_FRAME_METADATA_TYPE_LOW_LIGHT_COMPENSATION:
    ob_frame_metadata_type = 16;
#[doc = " @brief Manual white balance setting"]
pub const ob_frame_metadata_type_OB_FRAME_METADATA_TYPE_MANUAL_WHITE_BALANCE:
    ob_frame_metadata_type = 17;
#[doc = " @brief Actual frame rate\n @brief The actual frame rate will be calculated according to the exposure time and other parameters."]
pub const ob_frame_metadata_type_OB_FRAME_METADATA_TYPE_ACTUAL_FRAME_RATE: ob_frame_metadata_type =
    18;
#[doc = " @brief Frame rate"]
pub const ob_frame_metadata_type_OB_FRAME_METADATA_TYPE_FRAME_RATE: ob_frame_metadata_type = 19;
#[doc = " @brief Left region of interest for the auto exposure Algorithm."]
pub const ob_frame_metadata_type_OB_FRAME_METADATA_TYPE_AE_ROI_LEFT: ob_frame_metadata_type = 20;
#[doc = " @brief Top region of interest for the auto exposure Algorithm."]
pub const ob_frame_metadata_type_OB_FRAME_METADATA_TYPE_AE_ROI_TOP: ob_frame_metadata_type = 21;
#[doc = " @brief Right region of interest for the auto exposure Algorithm."]
pub const ob_frame_metadata_type_OB_FRAME_METADATA_TYPE_AE_ROI_RIGHT: ob_frame_metadata_type = 22;
#[doc = " @brief Bottom region of interest for the auto exposure Algorithm."]
pub const ob_frame_metadata_type_OB_FRAME_METADATA_TYPE_AE_ROI_BOTTOM: ob_frame_metadata_type = 23;
#[doc = " @brief Exposure priority"]
pub const ob_frame_metadata_type_OB_FRAME_METADATA_TYPE_EXPOSURE_PRIORITY: ob_frame_metadata_type =
    24;
#[doc = " @brief HDR sequence name"]
pub const ob_frame_metadata_type_OB_FRAME_METADATA_TYPE_HDR_SEQUENCE_NAME: ob_frame_metadata_type =
    25;
#[doc = " @brief HDR sequence size"]
pub const ob_frame_metadata_type_OB_FRAME_METADATA_TYPE_HDR_SEQUENCE_SIZE: ob_frame_metadata_type =
    26;
#[doc = " @brief HDR sequence index"]
pub const ob_frame_metadata_type_OB_FRAME_METADATA_TYPE_HDR_SEQUENCE_INDEX: ob_frame_metadata_type =
    27;
#[doc = " @brief Laser power value in mW\n\n @attention The laser power value is an approximate estimation."]
pub const ob_frame_metadata_type_OB_FRAME_METADATA_TYPE_LASER_POWER: ob_frame_metadata_type = 28;
#[doc = " @brief Laser power level"]
pub const ob_frame_metadata_type_OB_FRAME_METADATA_TYPE_LASER_POWER_LEVEL: ob_frame_metadata_type =
    29;
#[doc = " @brief Laser status\n @brief 0: Laser off, 1: Laser on"]
pub const ob_frame_metadata_type_OB_FRAME_METADATA_TYPE_LASER_STATUS: ob_frame_metadata_type = 30;
#[doc = " @brief GPIO input data"]
pub const ob_frame_metadata_type_OB_FRAME_METADATA_TYPE_GPIO_INPUT_DATA: ob_frame_metadata_type =
    31;
#[doc = " @brief disparity search offset value"]
pub const ob_frame_metadata_type_OB_FRAME_METADATA_TYPE_DISPARITY_SEARCH_OFFSET:
    ob_frame_metadata_type = 32;
#[doc = " @brief disparity search range"]
pub const ob_frame_metadata_type_OB_FRAME_METADATA_TYPE_DISPARITY_SEARCH_RANGE:
    ob_frame_metadata_type = 33;
#[doc = " @brief The number of frame metadata types, using for types iterating\n @attention It is not a valid frame metadata type"]
pub const ob_frame_metadata_type_OB_FRAME_METADATA_TYPE_COUNT: ob_frame_metadata_type = 34;
#[doc = " @brief Frame metadata types\n @brief The frame metadata is a set of meta info generated by the device for current individual frame."]
pub type ob_frame_metadata_type = i32;
#[doc = " @brief Frame metadata types\n @brief The frame metadata is a set of meta info generated by the device for current individual frame."]
pub use self::ob_frame_metadata_type as OBFrameMetadataType;
#[doc = " @brief Auto detect system capabilities and device hint to select backend\n"]
pub const ob_uvc_backend_type_OB_UVC_BACKEND_TYPE_AUTO: ob_uvc_backend_type = 0;
#[doc = " @brief Use libuvc backend to access the UVC device\n"]
pub const ob_uvc_backend_type_OB_UVC_BACKEND_TYPE_LIBUVC: ob_uvc_backend_type = 1;
#[doc = " @brief Use v4l2 backend to access the UVC device\n"]
pub const ob_uvc_backend_type_OB_UVC_BACKEND_TYPE_V4L2: ob_uvc_backend_type = 2;
#[doc = " @brief Use MSMF backend to access the UVC device"]
pub const ob_uvc_backend_type_OB_UVC_BACKEND_TYPE_MSMF: ob_uvc_backend_type = 3;
#[doc = " @brief For Linux, there are two ways to access the UVC device, libuvc and v4l2. The backend type is used to select the backend to access the device.\n"]
pub type ob_uvc_backend_type = i32;
#[doc = " @brief For Linux, there are two ways to access the UVC device, libuvc and v4l2. The backend type is used to select the backend to access the device.\n"]
pub use self::ob_uvc_backend_type as OBUvcBackendType;
pub const ob_playback_status_OB_PLAYBACK_UNKNOWN: ob_playback_status = 0;
#[doc = "< The media is playing"]
pub const ob_playback_status_OB_PLAYBACK_PLAYING: ob_playback_status = 1;
#[doc = "< The media is paused"]
pub const ob_playback_status_OB_PLAYBACK_PAUSED: ob_playback_status = 2;
#[doc = "< The media is stopped"]
pub const ob_playback_status_OB_PLAYBACK_STOPPED: ob_playback_status = 3;
pub const ob_playback_status_OB_PLAYBACK_COUNT: ob_playback_status = 4;
#[doc = " @brief The playback status of the media"]
pub type ob_playback_status = i32;
#[doc = " @brief The playback status of the media"]
pub use self::ob_playback_status as OBPlaybackStatus;
#[doc = " @brief Callback for file transfer\n\n @param state Transmission status\n @param message Transfer status information\n @param percent Transfer progress percentage\n @param user_data User-defined data"]
pub type ob_file_send_callback = ::std::option::Option<
    unsafe extern "C" fn(
        state: ob_file_tran_state,
        message: *const ::std::os::raw::c_char,
        percent: u8,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " @brief Callback for firmware upgrade\n\n @param state Upgrade status\n @param message Upgrade status information\n @param percent Upgrade progress percentage\n @param user_data User-defined data"]
pub type ob_device_fw_update_callback = ::std::option::Option<
    unsafe extern "C" fn(
        state: ob_fw_update_state,
        message: *const ::std::os::raw::c_char,
        percent: u8,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " @brief Callback for device status\n\n @param state Device status\n @param message Device status information\n @param user_data User-defined data"]
pub type ob_device_state_callback = ::std::option::Option<
    unsafe extern "C" fn(
        state: ob_device_state,
        message: *const ::std::os::raw::c_char,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " @brief Callback for writing data\n\n @param state Write data status\n @param percent Write data percentage\n @param user_data User-defined data"]
pub type ob_set_data_callback = ::std::option::Option<
    unsafe extern "C" fn(
        state: ob_data_tran_state,
        percent: u8,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " @brief Callback for reading data\n\n @param state Read data status\n @param dataChunk Read the returned data block\n @param user_data User-defined data"]
pub type ob_get_data_callback = ::std::option::Option<
    unsafe extern "C" fn(
        state: ob_data_tran_state,
        dataChunk: *mut ob_data_chunk,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " @brief Callback for media status (recording and playback)\n\n @param state Condition\n @param user_data User-defined data"]
pub type ob_media_state_callback = ::std::option::Option<
    unsafe extern "C" fn(state: ob_media_state, user_data: *mut ::std::os::raw::c_void),
>;
#[doc = " @brief Callback for device change\n\n @param removed List of deleted (dropped) devices\n @param added List of added (online) devices\n @param user_data User-defined data"]
pub type ob_device_changed_callback = ::std::option::Option<
    unsafe extern "C" fn(
        removed: *mut ob_device_list,
        added: *mut ob_device_list,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " @brief Callback for frame\n\n @param frame Frame object\n @param user_data User-defined data"]
pub type ob_frame_callback = ::std::option::Option<
    unsafe extern "C" fn(frame: *mut ob_frame, user_data: *mut ::std::os::raw::c_void),
>;
#[doc = " @brief Callback for frameset\n\n @param frameset Frameset object\n @param user_data User-defined data"]
pub type ob_frameset_callback = ::std::option::Option<
    unsafe extern "C" fn(frameset: *mut ob_frame, user_data: *mut ::std::os::raw::c_void),
>;
#[doc = " @brief Customize the delete callback\n\n @param buffer Data that needs to be deleted\n @param user_data User-defined data"]
pub type ob_frame_destroy_callback = ::std::option::Option<
    unsafe extern "C" fn(buffer: *mut u8, user_data: *mut ::std::os::raw::c_void),
>;
#[doc = " @brief Callback for receiving log\n\n @param severity Current log level\n @param message Log message\n @param user_data User-defined data"]
pub type ob_log_callback = ::std::option::Option<
    unsafe extern "C" fn(
        severity: ob_log_severity,
        message: *const ::std::os::raw::c_char,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
pub type ob_playback_status_changed_callback = ::std::option::Option<
    unsafe extern "C" fn(status: ob_playback_status, user_data: *mut ::std::os::raw::c_void),
>;
unsafe extern "C" {
    #[doc = " @brief Create a context object with the default configuration file\n\n @param[out] error Pointer to an error object that will be populated if an error occurs during context creation\n @return Pointer to the created context object"]
    pub fn ob_create_context(error: *mut *mut ob_error) -> *mut ob_context;
}
unsafe extern "C" {
    #[doc = " @brief Create a context object with a specified configuration file\n\n @param[in] config_file_path Path to the configuration file. If NULL, the default configuration file will be used.\n @param[out] error Pointer to an error object that will be populated if an error occurs during context creation\n @return Pointer to the created context object"]
    pub fn ob_create_context_with_config(
        config_file_path: *const ::std::os::raw::c_char,
        error: *mut *mut ob_error,
    ) -> *mut ob_context;
}
unsafe extern "C" {
    #[doc = " @brief Delete a context object\n\n @param[in] context Pointer to the context object to be deleted\n @param[out] error Pointer to an error object that will be populated if an error occurs during context deletion"]
    pub fn ob_delete_context(context: *mut ob_context, error: *mut *mut ob_error);
}
unsafe extern "C" {
    #[doc = " @brief Get a list of enumerated devices\n\n @param[in] context Pointer to the context object\n @param[out] error Pointer to an error object that will be populated if an error occurs during device enumeration\n @return Pointer to the device list object"]
    pub fn ob_query_device_list(
        context: *mut ob_context,
        error: *mut *mut ob_error,
    ) -> *mut ob_device_list;
}
unsafe extern "C" {
    #[doc = " @brief Enable or disable network device enumeration\n @brief After enabling, the network device will be automatically discovered and can be retrieved through @ref ob_query_device_list. The default state can be\n set in the configuration file.\n\n @attention Network device enumeration is performed through the GVCP protocol. If the device is not in the same subnet as the host, it will be discovered but\n cannot be connected.\n\n @param[in] context Pointer to the context object\n @param[in] enable true to enable, false to disable\n @param[out] error Pointer to an error object that will be populated if an error occurs."]
    pub fn ob_enable_net_device_enumeration(
        context: *mut ob_context,
        enable: bool,
        error: *mut *mut ob_error,
    );
}
unsafe extern "C" {
    #[doc = " @brief Create a network device object\n\n @param[in] context Pointer to the context object\n @param[in] address IP address of the device\n @param[in] port Port number of the device\n @param[out] error Pointer to an error object that will be populated if an error occurs during device creation\n @return Pointer to the created device object"]
    pub fn ob_create_net_device(
        context: *mut ob_context,
        address: *const ::std::os::raw::c_char,
        port: u16,
        error: *mut *mut ob_error,
    ) -> *mut ob_device;
}
unsafe extern "C" {
    #[doc = " @brief Set a device plug-in callback function\n @attention The added and removed device lists returned through the callback interface need to be released manually\n @attention This function supports multiple callbacks. Each call to this function adds a new callback to an internal list.\n\n @param[in] context Pointer to the context object\n @param[in] callback Pointer to the callback function triggered when a device is plugged or unplugged\n @param[in] user_data Pointer to user data that can be passed to and retrieved from the callback function\n @param[out] error Pointer to an error object that will be populated if an error occurs during callback function setting"]
    pub fn ob_set_device_changed_callback(
        context: *mut ob_context,
        callback: ob_device_changed_callback,
        user_data: *mut ::std::os::raw::c_void,
        error: *mut *mut ob_error,
    );
}
unsafe extern "C" {
    #[doc = " @brief Activates device clock synchronization to synchronize the clock of the host and all created devices (if supported).\n\n @param[in] context Pointer to the context object\n @param[in] repeat_interval_msec The interval for auto-repeated synchronization, in milliseconds. If the value is 0, synchronization is performed only once.\n @param[out] error Pointer to an error object that will be populated if an error occurs during execution"]
    pub fn ob_enable_device_clock_sync(
        context: *mut ob_context,
        repeat_interval_msec: u64,
        error: *mut *mut ob_error,
    );
}
unsafe extern "C" {
    #[doc = " @brief Free idle memory from the internal frame memory pool\n\n @param[in] context Pointer to the context object\n @param[out] error Pointer to an error object that will be populated if an error occurs during memory freeing"]
    pub fn ob_free_idle_memory(context: *mut ob_context, error: *mut *mut ob_error);
}
unsafe extern "C" {
    #[doc = " @brief For linux, there are two ways to enable the UVC backend: libuvc and v4l2. This function is used to set the backend type.\n @brief It is effective when the new device is created.\n\n @attention This interface is only available for Linux.\n\n @param[in] context Pointer to the context object\n @param[in] backend_type The backend type to be used.\n @param[out] error Pointer to an error object that will be populated if an error occurs during backend type setting"]
    pub fn ob_set_uvc_backend_type(
        context: *mut ob_context,
        backend_type: ob_uvc_backend_type,
        error: *mut *mut ob_error,
    );
}
unsafe extern "C" {
    #[doc = " @brief Set the global log level\n\n @attention This interface setting will affect the output level of all logs (terminal, file, callback)\n\n @param[in] severity Log level to set\n @param[out] error Pointer to an error object that will be populated if an error occurs during log level setting"]
    pub fn ob_set_logger_severity(severity: ob_log_severity, error: *mut *mut ob_error);
}
unsafe extern "C" {
    #[doc = " @brief Set the log output to a file\n\n @param[in] severity Log level to output to file\n @param[in] directory Path to the log file output directory. If the path is empty, the existing settings will continue to be used (if the existing\n configuration is also empty, the log will not be output to the file)\n @param[out] error Pointer to an error object that will be populated if an error occurs during log output setting"]
    pub fn ob_set_logger_to_file(
        severity: ob_log_severity,
        directory: *const ::std::os::raw::c_char,
        error: *mut *mut ob_error,
    );
}
unsafe extern "C" {
    #[doc = " @brief Set the log callback function\n\n @param[in] severity Log level to set for the callback function\n @param[in] callback Pointer to the callback function\n @param[in] user_data Pointer to user data that can be passed to and retrieved from the callback function\n @param[out] error Pointer to an error object that will be populated if an error occurs during log callback function setting"]
    pub fn ob_set_logger_to_callback(
        severity: ob_log_severity,
        callback: ob_log_callback,
        user_data: *mut ::std::os::raw::c_void,
        error: *mut *mut ob_error,
    );
}
unsafe extern "C" {
    #[doc = " @brief Set the log output to the console\n\n @param[in] severity Log level to output to the console\n @param[out] error Pointer to an error object that will be populated if an error occurs during log output setting"]
    pub fn ob_set_logger_to_console(severity: ob_log_severity, error: *mut *mut ob_error);
}
unsafe extern "C" {
    #[doc = " @brief Set the extensions directory\n @brief The extensions directory is used to search for dynamic libraries that provide additional functionality to the SDK, such as the Frame filters.\n\n @attention Should be called before creating the context and pipeline, otherwise the default extensions directory (./extensions) will be used.\n\n @param directory Path to the extensions directory. If the path is empty, extensions path will be set to the current working directory.\n @param error Pointer to an error object that will be populated if an error occurs during extensions directory setting"]
    pub fn ob_set_extensions_directory(
        directory: *const ::std::os::raw::c_char,
        error: *mut *mut ob_error,
    );
}
#[doc = " @brief LDP switch"]
pub const OBPropertyID_OB_PROP_LDP_BOOL: OBPropertyID = 2;
#[doc = " @brief Laser switch"]
pub const OBPropertyID_OB_PROP_LASER_BOOL: OBPropertyID = 3;
#[doc = " @brief laser pulse width"]
pub const OBPropertyID_OB_PROP_LASER_PULSE_WIDTH_INT: OBPropertyID = 4;
#[doc = " @brief Laser current (uint: mA)"]
pub const OBPropertyID_OB_PROP_LASER_CURRENT_FLOAT: OBPropertyID = 5;
#[doc = " @brief IR flood switch"]
pub const OBPropertyID_OB_PROP_FLOOD_BOOL: OBPropertyID = 6;
#[doc = " @brief IR flood level"]
pub const OBPropertyID_OB_PROP_FLOOD_LEVEL_INT: OBPropertyID = 7;
#[doc = " @brief Enable/disable temperature compensation\n"]
pub const OBPropertyID_OB_PROP_TEMPERATURE_COMPENSATION_BOOL: OBPropertyID = 8;
#[doc = " @brief Depth mirror"]
pub const OBPropertyID_OB_PROP_DEPTH_MIRROR_BOOL: OBPropertyID = 14;
#[doc = " @brief Depth flip"]
pub const OBPropertyID_OB_PROP_DEPTH_FLIP_BOOL: OBPropertyID = 15;
#[doc = " @brief Depth Postfilter"]
pub const OBPropertyID_OB_PROP_DEPTH_POSTFILTER_BOOL: OBPropertyID = 16;
#[doc = " @brief Depth Holefilter"]
pub const OBPropertyID_OB_PROP_DEPTH_HOLEFILTER_BOOL: OBPropertyID = 17;
#[doc = " @brief IR mirror"]
pub const OBPropertyID_OB_PROP_IR_MIRROR_BOOL: OBPropertyID = 18;
#[doc = " @brief IR flip"]
pub const OBPropertyID_OB_PROP_IR_FLIP_BOOL: OBPropertyID = 19;
#[doc = " @brief Minimum depth threshold"]
pub const OBPropertyID_OB_PROP_MIN_DEPTH_INT: OBPropertyID = 22;
#[doc = " @brief Maximum depth threshold"]
pub const OBPropertyID_OB_PROP_MAX_DEPTH_INT: OBPropertyID = 23;
#[doc = " @brief Software filter switch"]
pub const OBPropertyID_OB_PROP_DEPTH_NOISE_REMOVAL_FILTER_BOOL: OBPropertyID = 24;
#[doc = " @brief LDP status"]
pub const OBPropertyID_OB_PROP_LDP_STATUS_BOOL: OBPropertyID = 32;
#[doc = " @brief maxdiff for depth noise removal filter"]
pub const OBPropertyID_OB_PROP_DEPTH_NOISE_REMOVAL_FILTER_MAX_DIFF_INT: OBPropertyID = 40;
#[doc = " @brief maxSpeckleSize for depth noise removal filter"]
pub const OBPropertyID_OB_PROP_DEPTH_NOISE_REMOVAL_FILTER_MAX_SPECKLE_SIZE_INT: OBPropertyID = 41;
#[doc = " @brief Hardware d2c is on"]
pub const OBPropertyID_OB_PROP_DEPTH_ALIGN_HARDWARE_BOOL: OBPropertyID = 42;
#[doc = " @brief Timestamp adjustment"]
pub const OBPropertyID_OB_PROP_TIMESTAMP_OFFSET_INT: OBPropertyID = 43;
#[doc = " @brief Hardware distortion switch Rectify"]
pub const OBPropertyID_OB_PROP_HARDWARE_DISTORTION_SWITCH_BOOL: OBPropertyID = 61;
#[doc = " @brief Fan mode switch"]
pub const OBPropertyID_OB_PROP_FAN_WORK_MODE_INT: OBPropertyID = 62;
#[doc = " @brief Multi-resolution D2C mode"]
pub const OBPropertyID_OB_PROP_DEPTH_ALIGN_HARDWARE_MODE_INT: OBPropertyID = 63;
#[doc = " @brief Anti_collusion activation status"]
pub const OBPropertyID_OB_PROP_ANTI_COLLUSION_ACTIVATION_STATUS_BOOL: OBPropertyID = 64;
#[doc = " @brief the depth precision level, which may change the depth frame data unit, needs to be confirmed through the ValueScale interface of\n DepthFrame"]
pub const OBPropertyID_OB_PROP_DEPTH_PRECISION_LEVEL_INT: OBPropertyID = 75;
#[doc = " @brief tof filter range configuration"]
pub const OBPropertyID_OB_PROP_TOF_FILTER_RANGE_INT: OBPropertyID = 76;
#[doc = " @brief laser mode, the firmware terminal currently only return 1: IR Drive, 2: Torch"]
pub const OBPropertyID_OB_PROP_LASER_MODE_INT: OBPropertyID = 79;
#[doc = " @brief brt2r-rectify function switch (brt2r is a special module on mx6600), 0: Disable, 1: Rectify Enable"]
pub const OBPropertyID_OB_PROP_RECTIFY2_BOOL: OBPropertyID = 80;
#[doc = " @brief Color mirror"]
pub const OBPropertyID_OB_PROP_COLOR_MIRROR_BOOL: OBPropertyID = 81;
#[doc = " @brief Color flip"]
pub const OBPropertyID_OB_PROP_COLOR_FLIP_BOOL: OBPropertyID = 82;
#[doc = " @brief Indicator switch, 0: Disable, 1: Enable"]
pub const OBPropertyID_OB_PROP_INDICATOR_LIGHT_BOOL: OBPropertyID = 83;
#[doc = " @brief Disparity to depth switch, false: switch to software disparity convert to depth, true: switch to hardware disparity convert to depth"]
pub const OBPropertyID_OB_PROP_DISPARITY_TO_DEPTH_BOOL: OBPropertyID = 85;
#[doc = " @brief BRT function switch (anti-background interference), 0: Disable, 1: Enable"]
pub const OBPropertyID_OB_PROP_BRT_BOOL: OBPropertyID = 86;
#[doc = " @brief Watchdog function switch, 0: Disable, 1: Enable"]
pub const OBPropertyID_OB_PROP_WATCHDOG_BOOL: OBPropertyID = 87;
#[doc = " @brief External signal trigger restart function switch, 0: Disable, 1: Enable"]
pub const OBPropertyID_OB_PROP_EXTERNAL_SIGNAL_RESET_BOOL: OBPropertyID = 88;
#[doc = " @brief Heartbeat monitoring function switch, 0: Disable, 1: Enable"]
pub const OBPropertyID_OB_PROP_HEARTBEAT_BOOL: OBPropertyID = 89;
#[doc = " @brief Depth cropping mode device: OB_DEPTH_CROPPING_MODE"]
pub const OBPropertyID_OB_PROP_DEPTH_CROPPING_MODE_INT: OBPropertyID = 90;
#[doc = " @brief D2C preprocessing switch (such as RGB cropping), 0: off, 1: on"]
pub const OBPropertyID_OB_PROP_D2C_PREPROCESS_BOOL: OBPropertyID = 91;
#[doc = " @brief Enable/disable GPM function"]
pub const OBPropertyID_OB_PROP_GPM_BOOL: OBPropertyID = 93;
#[doc = " @brief Custom RGB cropping switch, 0 is off, 1 is on custom cropping, and the ROI cropping area is issued"]
pub const OBPropertyID_OB_PROP_RGB_CUSTOM_CROP_BOOL: OBPropertyID = 94;
#[doc = " @brief Device operating mode (power consumption)"]
pub const OBPropertyID_OB_PROP_DEVICE_WORK_MODE_INT: OBPropertyID = 95;
#[doc = " @brief Device communication type, 0: USB; 1: Ethernet(RTSP)"]
pub const OBPropertyID_OB_PROP_DEVICE_COMMUNICATION_TYPE_INT: OBPropertyID = 97;
#[doc = " @brief Switch infrared imaging mode, 0: active IR mode, 1: passive IR mode"]
pub const OBPropertyID_OB_PROP_SWITCH_IR_MODE_INT: OBPropertyID = 98;
#[doc = " @brief Laser power level"]
pub const OBPropertyID_OB_PROP_LASER_POWER_LEVEL_CONTROL_INT: OBPropertyID = 99;
#[doc = " @brief LDP's measure distance, unit: mm"]
pub const OBPropertyID_OB_PROP_LDP_MEASURE_DISTANCE_INT: OBPropertyID = 100;
#[doc = " @brief Reset device time to zero"]
pub const OBPropertyID_OB_PROP_TIMER_RESET_SIGNAL_BOOL: OBPropertyID = 104;
#[doc = " @brief Enable send reset device time signal to other device. true: enable, false: disable"]
pub const OBPropertyID_OB_PROP_TIMER_RESET_TRIGGER_OUT_ENABLE_BOOL: OBPropertyID = 105;
#[doc = " @brief Delay to reset device time, unit: us"]
pub const OBPropertyID_OB_PROP_TIMER_RESET_DELAY_US_INT: OBPropertyID = 106;
#[doc = " @brief Signal to capture image"]
pub const OBPropertyID_OB_PROP_CAPTURE_IMAGE_SIGNAL_BOOL: OBPropertyID = 107;
#[doc = " @brief Right IR sensor mirror state"]
pub const OBPropertyID_OB_PROP_IR_RIGHT_MIRROR_BOOL: OBPropertyID = 112;
#[doc = " @brief Number frame to capture once a 'OB_PROP_CAPTURE_IMAGE_SIGNAL_BOOL' effect. range: [1, 255]"]
pub const OBPropertyID_OB_PROP_CAPTURE_IMAGE_FRAME_NUMBER_INT: OBPropertyID = 113;
#[doc = " @brief Right IR sensor flip state. true: flip image, false: origin, default: false"]
pub const OBPropertyID_OB_PROP_IR_RIGHT_FLIP_BOOL: OBPropertyID = 114;
#[doc = " @brief Color sensor rotation, angle{0, 90, 180, 270}"]
pub const OBPropertyID_OB_PROP_COLOR_ROTATE_INT: OBPropertyID = 115;
#[doc = " @brief IR/Left-IR sensor rotation, angle{0, 90, 180, 270}"]
pub const OBPropertyID_OB_PROP_IR_ROTATE_INT: OBPropertyID = 116;
#[doc = " @brief Right IR sensor rotation, angle{0, 90, 180, 270}"]
pub const OBPropertyID_OB_PROP_IR_RIGHT_ROTATE_INT: OBPropertyID = 117;
#[doc = " @brief Depth sensor rotation, angle{0, 90, 180, 270}"]
pub const OBPropertyID_OB_PROP_DEPTH_ROTATE_INT: OBPropertyID = 118;
#[doc = " @brief Get hardware laser power actual level which real state of laser element. OB_PROP_LASER_POWER_LEVEL_CONTROL_INT99 will effect this command\n which it setting and changed the hardware laser energy level."]
pub const OBPropertyID_OB_PROP_LASER_POWER_ACTUAL_LEVEL_INT: OBPropertyID = 119;
#[doc = " @brief USB's power state, enum type: OBUSBPowerState"]
pub const OBPropertyID_OB_PROP_USB_POWER_STATE_INT: OBPropertyID = 121;
#[doc = " @brief DC's power state, enum type: OBDCPowerState"]
pub const OBPropertyID_OB_PROP_DC_POWER_STATE_INT: OBPropertyID = 122;
#[doc = " @brief Device development mode switch, optional modes can refer to the definition in @ref OBDeviceDevelopmentMode,the default mode is\n @ref OB_USER_MODE\n @attention The device takes effect after rebooting when switching modes."]
pub const OBPropertyID_OB_PROP_DEVICE_DEVELOPMENT_MODE_INT: OBPropertyID = 129;
#[doc = " @brief Multi-DeviceSync synchronized signal trigger out is enable state. true: enable, false: disable"]
pub const OBPropertyID_OB_PROP_SYNC_SIGNAL_TRIGGER_OUT_BOOL: OBPropertyID = 130;
#[doc = " @brief Restore factory settings and factory parameters\n @attention This command can only be written, and the parameter value must be true. The command takes effect after restarting the device."]
pub const OBPropertyID_OB_PROP_RESTORE_FACTORY_SETTINGS_BOOL: OBPropertyID = 131;
#[doc = " @brief Enter recovery mode (flashing mode) when boot the device\n @attention The device will take effect after rebooting with the enable option. After entering recovery mode, you can upgrade the device system. Upgrading\n the system may cause system damage, please use it with caution."]
pub const OBPropertyID_OB_PROP_BOOT_INTO_RECOVERY_MODE_BOOL: OBPropertyID = 132;
#[doc = " @brief Query whether the current device is running in recovery mode (read-only)"]
pub const OBPropertyID_OB_PROP_DEVICE_IN_RECOVERY_MODE_BOOL: OBPropertyID = 133;
#[doc = " @brief Capture interval mode, 0:time interval, 1:number interval"]
pub const OBPropertyID_OB_PROP_CAPTURE_INTERVAL_MODE_INT: OBPropertyID = 134;
#[doc = " @brief Capture time interval"]
pub const OBPropertyID_OB_PROP_CAPTURE_IMAGE_TIME_INTERVAL_INT: OBPropertyID = 135;
#[doc = " @brief Capture number interval"]
pub const OBPropertyID_OB_PROP_CAPTURE_IMAGE_NUMBER_INTERVAL_INT: OBPropertyID = 136;
pub const OBPropertyID_OB_PROP_TIMER_RESET_ENABLE_BOOL: OBPropertyID = 140;
#[doc = " @brief Enable or disable the device to retry USB2.0 re-identification when the device is connected to a USB2.0 port.\n @brief This feature ensures that the device is not mistakenly identified as a USB 2.0 device when connected to a USB 3.0 port."]
pub const OBPropertyID_OB_PROP_DEVICE_USB2_REPEAT_IDENTIFY_BOOL: OBPropertyID = 141;
#[doc = " @brief Reboot device delay mode. Delay time unit: ms, range: [0, 8000)."]
pub const OBPropertyID_OB_PROP_DEVICE_REBOOT_DELAY_INT: OBPropertyID = 142;
#[doc = " @brief Query the status of laser overcurrent protection (read-only)"]
pub const OBPropertyID_OB_PROP_LASER_OVERCURRENT_PROTECTION_STATUS_BOOL: OBPropertyID = 148;
#[doc = " @brief Query the status of laser pulse width protection (read-only)"]
pub const OBPropertyID_OB_PROP_LASER_PULSE_WIDTH_PROTECTION_STATUS_BOOL: OBPropertyID = 149;
#[doc = " @brief Laser always on, true: always on, false: off, laser will be turned off when out of exposure time"]
pub const OBPropertyID_OB_PROP_LASER_ALWAYS_ON_BOOL: OBPropertyID = 174;
#[doc = " @brief Laser on/off alternate mode, 0: off, 1: on-off alternate, 2: off-on alternate\n @attention When turn on this mode, the laser will turn on and turn off alternately each frame."]
pub const OBPropertyID_OB_PROP_LASER_ON_OFF_PATTERN_INT: OBPropertyID = 175;
#[doc = " @brief Depth unit flexible adjustment\\\n @brief This property allows continuous adjustment of the depth unit, unlike @ref OB_PROP_DEPTH_PRECISION_LEVEL_INT must be set to some fixed value."]
pub const OBPropertyID_OB_PROP_DEPTH_UNIT_FLEXIBLE_ADJUSTMENT_FLOAT: OBPropertyID = 176;
#[doc = " @brief Laser control, 0: off, 1: on, 2: auto\n"]
pub const OBPropertyID_OB_PROP_LASER_CONTROL_INT: OBPropertyID = 182;
#[doc = " @brief IR brightness"]
pub const OBPropertyID_OB_PROP_IR_BRIGHTNESS_INT: OBPropertyID = 184;
#[doc = " @brief Slave/secondary device synchronization status (read-only)"]
pub const OBPropertyID_OB_PROP_SLAVE_DEVICE_SYNC_STATUS_BOOL: OBPropertyID = 188;
#[doc = " @brief Color AE max exposure"]
pub const OBPropertyID_OB_PROP_COLOR_AE_MAX_EXPOSURE_INT: OBPropertyID = 189;
#[doc = " @brief Max exposure time of IR auto exposure"]
pub const OBPropertyID_OB_PROP_IR_AE_MAX_EXPOSURE_INT: OBPropertyID = 190;
#[doc = " @brief Disparity search range mode, 1: 128, 2: 256"]
pub const OBPropertyID_OB_PROP_DISP_SEARCH_RANGE_MODE_INT: OBPropertyID = 191;
#[doc = " @brief Laser high temperature protection"]
pub const OBPropertyID_OB_PROP_LASER_HIGH_TEMPERATURE_PROTECT_BOOL: OBPropertyID = 193;
#[doc = " @brief low exposure laser control\n\n @brief Currently using for DabaiA device,if the exposure value is lower than a certain threshold, the laser is turned off;\n if it exceeds another threshold, the laser is turned on again."]
pub const OBPropertyID_OB_PROP_LOW_EXPOSURE_LASER_CONTROL_BOOL: OBPropertyID = 194;
#[doc = " @brief check pps sync in signal"]
pub const OBPropertyID_OB_PROP_CHECK_PPS_SYNC_IN_SIGNAL_BOOL: OBPropertyID = 195;
#[doc = " @brief Disparity search range offset, range: [0, 127]"]
pub const OBPropertyID_OB_PROP_DISP_SEARCH_OFFSET_INT: OBPropertyID = 196;
#[doc = " @brief Repower device (cut off power and power on again)\n\n @brief Currently using for GMSL device, cut off power and power on again by GMSL host driver."]
pub const OBPropertyID_OB_PROP_DEVICE_REPOWER_BOOL: OBPropertyID = 202;
#[doc = " @brief frame interleave config index"]
pub const OBPropertyID_OB_PROP_FRAME_INTERLEAVE_CONFIG_INDEX_INT: OBPropertyID = 204;
#[doc = " @brief frame interleave enable (true:enable,false:disable)"]
pub const OBPropertyID_OB_PROP_FRAME_INTERLEAVE_ENABLE_BOOL: OBPropertyID = 205;
#[doc = " @brief laser pattern sync with delay(us)"]
pub const OBPropertyID_OB_PROP_FRAME_INTERLEAVE_LASER_PATTERN_SYNC_DELAY_INT: OBPropertyID = 206;
#[doc = " @brief Get the health check result from device,range is [0.0f,1.5f]"]
pub const OBPropertyID_OB_PROP_ON_CHIP_CALIBRATION_HEALTH_CHECK_FLOAT: OBPropertyID = 209;
#[doc = " @brief Enable or disable on-chip calibration"]
pub const OBPropertyID_OB_PROP_ON_CHIP_CALIBRATION_ENABLE_BOOL: OBPropertyID = 210;
#[doc = " @brief hardware noise remove filter switch"]
pub const OBPropertyID_OB_PROP_HW_NOISE_REMOVE_FILTER_ENABLE_BOOL: OBPropertyID = 211;
#[doc = " @brief hardware noise remove filter threshold ,range [0.0 - 1.0]"]
pub const OBPropertyID_OB_PROP_HW_NOISE_REMOVE_FILTER_THRESHOLD_FLOAT: OBPropertyID = 212;
#[doc = " @brief soft trigger auto capture enable, use in OB_MULTI_DEVICE_SYNC_MODE_SOFTWARE_TRIGGERING mode"]
pub const OBPropertyID_OB_DEVICE_AUTO_CAPTURE_ENABLE_BOOL: OBPropertyID = 216;
#[doc = " @brief soft trigger auto capture interval time, use in OB_MULTI_DEVICE_SYNC_MODE_SOFTWARE_TRIGGERING mode"]
pub const OBPropertyID_OB_DEVICE_AUTO_CAPTURE_INTERVAL_TIME_INT: OBPropertyID = 217;
#[doc = " @brief PTP time synchronization enable"]
pub const OBPropertyID_OB_DEVICE_PTP_CLOCK_SYNC_ENABLE_BOOL: OBPropertyID = 223;
#[doc = " @brief Depth with confidence stream enable"]
pub const OBPropertyID_OB_PROP_DEPTH_WITH_CONFIDENCE_STREAM_ENABLE_BOOL: OBPropertyID = 224;
#[doc = " @brief Enable or disable confidence stream filter"]
pub const OBPropertyID_OB_PROP_CONFIDENCE_STREAM_FILTER_BOOL: OBPropertyID = 226;
#[doc = " @brief Confidence stream filter threshold, range [0, 255]"]
pub const OBPropertyID_OB_PROP_CONFIDENCE_STREAM_FILTER_THRESHOLD_INT: OBPropertyID = 227;
#[doc = " @brief Confidence stream mirror enable"]
pub const OBPropertyID_OB_PROP_CONFIDENCE_MIRROR_BOOL: OBPropertyID = 229;
#[doc = " @brief Confidence stream flip enable"]
pub const OBPropertyID_OB_PROP_CONFIDENCE_FLIP_BOOL: OBPropertyID = 230;
#[doc = " @brief Confidence stream rotate angle{0, 90, 180, 270}"]
pub const OBPropertyID_OB_PROP_CONFIDENCE_ROTATE_INT: OBPropertyID = 231;
#[doc = " @brief Baseline calibration parameters"]
pub const OBPropertyID_OB_STRUCT_BASELINE_CALIBRATION_PARAM: OBPropertyID = 1002;
#[doc = " @brief Device temperature information"]
pub const OBPropertyID_OB_STRUCT_DEVICE_TEMPERATURE: OBPropertyID = 1003;
#[doc = " @brief TOF exposure threshold range"]
pub const OBPropertyID_OB_STRUCT_TOF_EXPOSURE_THRESHOLD_CONTROL: OBPropertyID = 1024;
#[doc = " @brief get/set serial number"]
pub const OBPropertyID_OB_STRUCT_DEVICE_SERIAL_NUMBER: OBPropertyID = 1035;
#[doc = " @brief get/set device time"]
pub const OBPropertyID_OB_STRUCT_DEVICE_TIME: OBPropertyID = 1037;
#[doc = " @brief Multi-device synchronization mode and parameter configuration"]
pub const OBPropertyID_OB_STRUCT_MULTI_DEVICE_SYNC_CONFIG: OBPropertyID = 1038;
#[doc = " @brief RGB cropping ROI"]
pub const OBPropertyID_OB_STRUCT_RGB_CROP_ROI: OBPropertyID = 1040;
#[doc = " @brief Device IP address configuration"]
pub const OBPropertyID_OB_STRUCT_DEVICE_IP_ADDR_CONFIG: OBPropertyID = 1041;
#[doc = " @brief The current camera depth mode"]
pub const OBPropertyID_OB_STRUCT_CURRENT_DEPTH_ALG_MODE: OBPropertyID = 1043;
#[doc = " @brief A list of depth accuracy levels, returning an array of uin16_t, corresponding to the enumeration"]
pub const OBPropertyID_OB_STRUCT_DEPTH_PRECISION_SUPPORT_LIST: OBPropertyID = 1045;
#[doc = " @brief Device network static ip config record\n @brief Using for get last static ip config, witch is record in device flash when user set static ip config\n\n @attention read only"]
pub const OBPropertyID_OB_STRUCT_DEVICE_STATIC_IP_CONFIG_RECORD: OBPropertyID = 1053;
#[doc = " @brief Using to configure the depth sensor's HDR mode\n @brief The Value type is @ref OBHdrConfig\n\n @attention After enable HDR mode, the depth sensor auto exposure will be disabled."]
pub const OBPropertyID_OB_STRUCT_DEPTH_HDR_CONFIG: OBPropertyID = 1059;
#[doc = " @brief Color Sensor AE ROI configuration\n @brief The Value type is @ref OBRegionOfInterest"]
pub const OBPropertyID_OB_STRUCT_COLOR_AE_ROI: OBPropertyID = 1060;
#[doc = " @brief Depth Sensor AE ROI configuration\n @brief The Value type is @ref OBRegionOfInterest\n @brief Since the ir sensor is the same physical sensor as the depth sensor, this property will also effect the ir sensor."]
pub const OBPropertyID_OB_STRUCT_DEPTH_AE_ROI: OBPropertyID = 1061;
#[doc = " @brief ASIC serial number"]
pub const OBPropertyID_OB_STRUCT_ASIC_SERIAL_NUMBER: OBPropertyID = 1063;
#[doc = " @brief Disparity offset interleaving"]
pub const OBPropertyID_OB_STRUCT_DISP_OFFSET_CONFIG: OBPropertyID = 1064;
#[doc = " @brief Preset resolution ratio configuration"]
pub const OBPropertyID_OB_STRUCT_PRESET_RESOLUTION_CONFIG: OBPropertyID = 1069;
#[doc = " @brief Color camera auto exposure"]
pub const OBPropertyID_OB_PROP_COLOR_AUTO_EXPOSURE_BOOL: OBPropertyID = 2000;
#[doc = " @brief Color camera exposure adjustment"]
pub const OBPropertyID_OB_PROP_COLOR_EXPOSURE_INT: OBPropertyID = 2001;
#[doc = " @brief Color camera gain adjustment"]
pub const OBPropertyID_OB_PROP_COLOR_GAIN_INT: OBPropertyID = 2002;
#[doc = " @brief Color camera automatic white balance"]
pub const OBPropertyID_OB_PROP_COLOR_AUTO_WHITE_BALANCE_BOOL: OBPropertyID = 2003;
#[doc = " @brief Color camera white balance adjustment"]
pub const OBPropertyID_OB_PROP_COLOR_WHITE_BALANCE_INT: OBPropertyID = 2004;
#[doc = " @brief Color camera brightness adjustment"]
pub const OBPropertyID_OB_PROP_COLOR_BRIGHTNESS_INT: OBPropertyID = 2005;
#[doc = " @brief Color camera sharpness adjustment"]
pub const OBPropertyID_OB_PROP_COLOR_SHARPNESS_INT: OBPropertyID = 2006;
#[doc = " @brief Color camera shutter adjustment"]
pub const OBPropertyID_OB_PROP_COLOR_SHUTTER_INT: OBPropertyID = 2007;
#[doc = " @brief Color camera saturation adjustment"]
pub const OBPropertyID_OB_PROP_COLOR_SATURATION_INT: OBPropertyID = 2008;
#[doc = " @brief Color camera contrast adjustment"]
pub const OBPropertyID_OB_PROP_COLOR_CONTRAST_INT: OBPropertyID = 2009;
#[doc = " @brief Color camera gamma adjustment"]
pub const OBPropertyID_OB_PROP_COLOR_GAMMA_INT: OBPropertyID = 2010;
#[doc = " @brief Color camera image rotation"]
pub const OBPropertyID_OB_PROP_COLOR_ROLL_INT: OBPropertyID = 2011;
#[doc = " @brief Color camera auto exposure priority"]
pub const OBPropertyID_OB_PROP_COLOR_AUTO_EXPOSURE_PRIORITY_INT: OBPropertyID = 2012;
#[doc = " @brief Color camera brightness compensation"]
pub const OBPropertyID_OB_PROP_COLOR_BACKLIGHT_COMPENSATION_INT: OBPropertyID = 2013;
#[doc = " @brief Color camera color tint"]
pub const OBPropertyID_OB_PROP_COLOR_HUE_INT: OBPropertyID = 2014;
#[doc = " @brief Color Camera Power Line Frequency"]
pub const OBPropertyID_OB_PROP_COLOR_POWER_LINE_FREQUENCY_INT: OBPropertyID = 2015;
#[doc = " @brief Automatic exposure of depth camera (infrared camera will be set synchronously under some models of devices)"]
pub const OBPropertyID_OB_PROP_DEPTH_AUTO_EXPOSURE_BOOL: OBPropertyID = 2016;
#[doc = " @brief Depth camera exposure adjustment (infrared cameras will be set synchronously under some models of devices)"]
pub const OBPropertyID_OB_PROP_DEPTH_EXPOSURE_INT: OBPropertyID = 2017;
#[doc = " @brief Depth camera gain adjustment (infrared cameras will be set synchronously under some models of devices)"]
pub const OBPropertyID_OB_PROP_DEPTH_GAIN_INT: OBPropertyID = 2018;
#[doc = " @brief Infrared camera auto exposure (depth camera will be set synchronously under some models of devices)"]
pub const OBPropertyID_OB_PROP_IR_AUTO_EXPOSURE_BOOL: OBPropertyID = 2025;
#[doc = " @brief Infrared camera exposure adjustment (some models of devices will set the depth camera synchronously)"]
pub const OBPropertyID_OB_PROP_IR_EXPOSURE_INT: OBPropertyID = 2026;
#[doc = " @brief Infrared camera gain adjustment (the depth camera will be set synchronously under some models of devices)"]
pub const OBPropertyID_OB_PROP_IR_GAIN_INT: OBPropertyID = 2027;
#[doc = " @brief Select Infrared camera data source channel. If not support throw exception. 0 : IR stream from IR Left sensor; 1 : IR stream from IR Right sensor;"]
pub const OBPropertyID_OB_PROP_IR_CHANNEL_DATA_SOURCE_INT: OBPropertyID = 2028;
#[doc = " @brief Depth effect dedistortion, true: on, false: off. mutually exclusive with D2C function, RM_Filter disable When hardware or software D2C is enabled."]
pub const OBPropertyID_OB_PROP_DEPTH_RM_FILTER_BOOL: OBPropertyID = 2029;
#[doc = " @brief Color camera maximal gain"]
pub const OBPropertyID_OB_PROP_COLOR_MAXIMAL_GAIN_INT: OBPropertyID = 2030;
#[doc = " @brief Color camera shutter gain"]
pub const OBPropertyID_OB_PROP_COLOR_MAXIMAL_SHUTTER_INT: OBPropertyID = 2031;
#[doc = " @brief The enable/disable switch for IR short exposure function, supported only by a few devices."]
pub const OBPropertyID_OB_PROP_IR_SHORT_EXPOSURE_BOOL: OBPropertyID = 2032;
#[doc = " @brief Color camera HDR"]
pub const OBPropertyID_OB_PROP_COLOR_HDR_BOOL: OBPropertyID = 2034;
#[doc = " @brief IR long exposure mode switch read and write."]
pub const OBPropertyID_OB_PROP_IR_LONG_EXPOSURE_BOOL: OBPropertyID = 2035;
#[doc = " @brief Setting and getting the USB device frame skipping mode status, true: frame skipping mode, false: non-frame skipping mode."]
pub const OBPropertyID_OB_PROP_SKIP_FRAME_BOOL: OBPropertyID = 2036;
#[doc = " @brief Depth HDR merge, true: on, false: off."]
pub const OBPropertyID_OB_PROP_HDR_MERGE_BOOL: OBPropertyID = 2037;
#[doc = " @brief Color camera FOCUS"]
pub const OBPropertyID_OB_PROP_COLOR_FOCUS_INT: OBPropertyID = 2038;
#[doc = " @brief ir rectify status,true: ir rectify, false: no rectify"]
pub const OBPropertyID_OB_PROP_IR_RECTIFY_BOOL: OBPropertyID = 2040;
#[doc = " @brief Depth camera priority\n"]
pub const OBPropertyID_OB_PROP_DEPTH_AUTO_EXPOSURE_PRIORITY_INT: OBPropertyID = 2052;
#[doc = " @brief Software disparity to depth"]
pub const OBPropertyID_OB_PROP_SDK_DISPARITY_TO_DEPTH_BOOL: OBPropertyID = 3004;
#[doc = " @brief Depth data unpacking function switch (each open stream will be turned on by default, support RLE/Y10/Y11/Y12/Y14 format)"]
pub const OBPropertyID_OB_PROP_SDK_DEPTH_FRAME_UNPACK_BOOL: OBPropertyID = 3007;
#[doc = " @brief IR data unpacking function switch (each current will be turned on by default, support RLE/Y10/Y11/Y12/Y14 format)"]
pub const OBPropertyID_OB_PROP_SDK_IR_FRAME_UNPACK_BOOL: OBPropertyID = 3008;
#[doc = " @brief Accel data conversion function switch (on by default)"]
pub const OBPropertyID_OB_PROP_SDK_ACCEL_FRAME_TRANSFORMED_BOOL: OBPropertyID = 3009;
#[doc = " @brief Gyro data conversion function switch (on by default)"]
pub const OBPropertyID_OB_PROP_SDK_GYRO_FRAME_TRANSFORMED_BOOL: OBPropertyID = 3010;
#[doc = " @brief Left IR frame data unpacking function switch (each current will be turned on by default, support RLE/Y10/Y11/Y12/Y14 format)"]
pub const OBPropertyID_OB_PROP_SDK_IR_LEFT_FRAME_UNPACK_BOOL: OBPropertyID = 3011;
#[doc = " @brief Right IR frame data unpacking function switch (each current will be turned on by default, support RLE/Y10/Y11/Y12/Y14 format)"]
pub const OBPropertyID_OB_PROP_SDK_IR_RIGHT_FRAME_UNPACK_BOOL: OBPropertyID = 3012;
#[doc = " @brief Read the current network bandwidth type of the network device, whether it is Gigabit Ethernet or Fast Ethernet, such as G335LE."]
pub const OBPropertyID_OB_PROP_NETWORK_BANDWIDTH_TYPE_INT: OBPropertyID = 3027;
#[doc = " @brief Switch device performance mode, currently available in Adaptive Mode and High Performance Mode, such as G335LE."]
pub const OBPropertyID_OB_PROP_DEVICE_PERFORMANCE_MODE_INT: OBPropertyID = 3028;
#[doc = " @brief Calibration JSON file read from device (Femto Mega, read only)"]
pub const OBPropertyID_OB_RAW_DATA_CAMERA_CALIB_JSON_FILE: OBPropertyID = 4029;
#[doc = " @brief Confidence degree"]
pub const OBPropertyID_OB_PROP_DEBUG_ESGM_CONFIDENCE_FLOAT: OBPropertyID = 5013;
#[doc = " @brief Enumeration value describing all attribute control commands of the device"]
pub type OBPropertyID = i32;
#[doc = " @brief Enumeration value describing all attribute control commands of the device"]
pub use self::OBPropertyID as ob_property_id;
#[doc = "< Boolean property"]
pub const OBPropertyType_OB_BOOL_PROPERTY: OBPropertyType = 0;
#[doc = "< Integer property"]
pub const OBPropertyType_OB_INT_PROPERTY: OBPropertyType = 1;
#[doc = "< Floating-point property"]
pub const OBPropertyType_OB_FLOAT_PROPERTY: OBPropertyType = 2;
#[doc = "< Struct property"]
pub const OBPropertyType_OB_STRUCT_PROPERTY: OBPropertyType = 3;
#[doc = " @brief The data type used to describe all property settings"]
pub type OBPropertyType = i32;
#[doc = " @brief The data type used to describe all property settings"]
pub use self::OBPropertyType as ob_property_type;
#[doc = " @brief Used to describe the characteristics of each property"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OBPropertyItem {
    #[doc = "< Property ID"]
    pub id: OBPropertyID,
    #[doc = "< Property name"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "< Property type"]
    pub type_: OBPropertyType,
    #[doc = "< Property read and write permission"]
    pub permission: OBPermissionType,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of OBPropertyItem"][::std::mem::size_of::<OBPropertyItem>() - 24usize];
    ["Alignment of OBPropertyItem"][::std::mem::align_of::<OBPropertyItem>() - 8usize];
    ["Offset of field: OBPropertyItem::id"][::std::mem::offset_of!(OBPropertyItem, id) - 0usize];
    ["Offset of field: OBPropertyItem::name"]
        [::std::mem::offset_of!(OBPropertyItem, name) - 8usize];
    ["Offset of field: OBPropertyItem::type_"]
        [::std::mem::offset_of!(OBPropertyItem, type_) - 16usize];
    ["Offset of field: OBPropertyItem::permission"]
        [::std::mem::offset_of!(OBPropertyItem, permission) - 20usize];
};
#[doc = " @brief Used to describe the characteristics of each property"]
pub type ob_property_item = OBPropertyItem;
unsafe extern "C" {
    #[doc = " @brief Get the supported multi device sync mode bitmap of the device.\n @brief For example, if the return value is 0b00001100, it means the device supports @ref OB_MULTI_DEVICE_SYNC_MODE_PRIMARY and @ref\n OB_MULTI_DEVICE_SYNC_MODE_SECONDARY. User can check the supported mode by the code:\n ```c\n   if(supported_mode_bitmap & OB_MULTI_DEVICE_SYNC_MODE_FREE_RUN){\n      //support OB_MULTI_DEVICE_SYNC_MODE_FREE_RUN\n   }\n   if(supported_mode_bitmap & OB_MULTI_DEVICE_SYNC_MODE_STANDALONE){\n     //support OB_MULTI_DEVICE_SYNC_MODE_STANDALONE\n   }\n   // and so on\n ```\n @param[in] device The device handle.\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return uint16_t return the supported multi device sync mode bitmap of the device."]
    pub fn ob_device_get_supported_multi_device_sync_mode_bitmap(
        device: *const ob_device,
        error: *mut *mut ob_error,
    ) -> u16;
}
unsafe extern "C" {
    #[doc = " @brief set the multi device sync configuration of the device.\n\n @param[in] device The device handle.\n @param[in] config The multi device sync configuration.\n @param[out] error Pointer to an error object that will be set if an error occurs."]
    pub fn ob_device_set_multi_device_sync_config(
        device: *mut ob_device,
        config: *const ob_multi_device_sync_config,
        error: *mut *mut ob_error,
    );
}
unsafe extern "C" {
    #[doc = " @brief get the current multi device sync configuration of the device.\n\n @param[in] device The device handle.\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return ob_multi_device_sync_config return the multi device sync configuration of the device."]
    pub fn ob_device_get_multi_device_sync_config(
        device: *const ob_device,
        error: *mut *mut ob_error,
    ) -> ob_multi_device_sync_config;
}
unsafe extern "C" {
    #[doc = " @brief send the capture command to the device to trigger the capture.\n @brief The device will start one time capture after receiving the capture command when it is in the @ref OB_MULTI_DEVICE_SYNC_MODE_SOFTWARE_TRIGGERING\n\n @attention The frequency of the user call this function multiplied by the number of frames per trigger should be less than the frame rate of the stream. The\n number of frames per trigger can be set by @ref framesPerTrigger.\n @attention For some models, receive and execute the capture command will have a certain delay and performance consumption, so the frequency of calling this\n function should not be too high, please refer to the product manual for the specific supported frequency.\n @attention If the device is not in the @ref OB_MULTI_DEVICE_SYNC_MODE_HARDWARE_TRIGGERING mode, device will ignore the capture command.\n\n @param[in] device The device handle.\n @param[out] error Pointer to an error object that will be set if an error occurs."]
    pub fn ob_device_trigger_capture(device: *mut ob_device, error: *mut *mut ob_error);
}
unsafe extern "C" {
    #[doc = " @brief set the timestamp reset configuration of the device.\n\n @param[in] device The device handle.\n @param[in] config The timestamp reset configuration.\n @param[out] error Pointer to an error object that will be set if an error occurs."]
    pub fn ob_device_set_timestamp_reset_config(
        device: *mut ob_device,
        config: *const ob_device_timestamp_reset_config,
        error: *mut *mut ob_error,
    );
}
unsafe extern "C" {
    #[doc = " @brief get the timestamp reset configuration of the device.\n\n @param[in] device The device handle.\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return ob_device_timestamp_reset_config return the timestamp reset configuration of the device."]
    pub fn ob_device_get_timestamp_reset_config(
        device: *mut ob_device,
        error: *mut *mut ob_error,
    ) -> ob_device_timestamp_reset_config;
}
unsafe extern "C" {
    #[doc = " @brief send the timestamp reset command to the device.\n @brief The device will reset the timer for calculating the timestamp for output frames to 0 after receiving the timestamp reset command when the timestamp\n reset function is enabled. The timestamp reset function can be enabled by call @ref ob_device_set_timestamp_reset_config.\n\n @attention If the stream of the device is started, the timestamp of the continuous frames output by the stream will jump once after the timestamp reset.\n @attention Due to the timer of device is not high-accuracy, the timestamp of the continuous frames output by the stream will drift after a long time. User\n can call this function periodically to reset the timer to avoid the timestamp drift, the recommended interval time is 60 minutes.\n\n @param[in] device The device handle.\n @param[out] error Pointer to an error object that will be set if an error occurs."]
    pub fn ob_device_timestamp_reset(device: *mut ob_device, error: *mut *mut ob_error);
}
unsafe extern "C" {
    #[doc = " @brief synchronize the timer of the device with the host.\n @brief After calling this function, the timer of the device will be synchronized with the host. User can call this function to multiple devices to\n synchronize all timers of the devices.\n\n @attention If the stream of the device is started, the timestamp of the continuous frames output by the stream will may jump once after the timer sync.\n @attention Due to the timer of device is not high-accuracy, the timestamp of the continuous frames output by the stream will drift after a long time. User\n can call this function periodically to synchronize the timer to avoid the timestamp drift, the recommended interval time is 60 minutes.\n\n @param[in] device The device handle.\n @param[out] error Pointer to an error object that will be set if an error occurs."]
    pub fn ob_device_timer_sync_with_host(device: *mut ob_device, error: *mut *mut ob_error);
}
unsafe extern "C" {
    #[doc = " @brief Get the current depth work mode.\n\n @param[in] device The device object.\n @param[out] error Pointer to an error object that will be set if an error occurs.\n\n @return ob_depth_work_mode The current depth work mode."]
    pub fn ob_device_get_current_depth_work_mode(
        device: *const ob_device,
        error: *mut *mut ob_error,
    ) -> ob_depth_work_mode;
}
unsafe extern "C" {
    #[doc = " @brief Get current depth mode name\n @brief According the current preset name to return current depth mode name\n @return const char* return the current depth mode name."]
    pub fn ob_device_get_current_depth_work_mode_name(
        device: *const ob_device,
        error: *mut *mut ob_error,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " @brief Switch the depth work mode by ob_depth_work_mode.\n        Prefer to use ob_device_switch_depth_work_mode_by_name to switch depth mode when the complete name of the depth work mode is known.\n\n @param[in] device The device object.\n @param[in] work_mode The depth work mode from ob_depth_work_mode_list which is returned by ob_device_get_depth_work_mode_list.\n @param[out] error Pointer to an error object that will be set if an error occurs.\n\n @return ob_status The switch result. OB_STATUS_OK: success, other failed."]
    pub fn ob_device_switch_depth_work_mode(
        device: *mut ob_device,
        work_mode: *const ob_depth_work_mode,
        error: *mut *mut ob_error,
    ) -> ob_status;
}
unsafe extern "C" {
    #[doc = " @brief Switch the depth work mode by work mode name.\n\n @param[in] device The device object.\n @param[in] mode_name The depth work mode name which is equal to ob_depth_work_mode.name.\n @param[out] error Pointer to an error object that will be set if an error occurs.\n\n @return ob_status The switch result. OB_STATUS_OK: success, other failed."]
    pub fn ob_device_switch_depth_work_mode_by_name(
        device: *mut ob_device,
        mode_name: *const ::std::os::raw::c_char,
        error: *mut *mut ob_error,
    ) -> ob_status;
}
unsafe extern "C" {
    #[doc = " @brief Request the list of supported depth work modes.\n\n @param[in] device The device object.\n @param[out] error Pointer to an error object that will be set if an error occurs.\n\n @return ob_depth_work_mode_list The list of ob_depth_work_mode."]
    pub fn ob_device_get_depth_work_mode_list(
        device: *const ob_device,
        error: *mut *mut ob_error,
    ) -> *mut ob_depth_work_mode_list;
}
unsafe extern "C" {
    #[doc = " \\if English\n @brief Get the depth work mode count that ob_depth_work_mode_list hold\n @param[in] work_mode_list data struct contain list of ob_depth_work_mode\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return The total number contained in ob_depth_work_mode_list\n"]
    pub fn ob_depth_work_mode_list_get_count(
        work_mode_list: *const ob_depth_work_mode_list,
        error: *mut *mut ob_error,
    ) -> u32;
}
unsafe extern "C" {
    #[doc = " @brief Get the index target of ob_depth_work_mode from work_mode_list\n\n @param[in] work_mode_list Data structure containing a list of ob_depth_work_mode\n @param[in] index Index of the target ob_depth_work_mode\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return ob_depth_work_mode\n"]
    pub fn ob_depth_work_mode_list_get_item(
        work_mode_list: *const ob_depth_work_mode_list,
        index: u32,
        error: *mut *mut ob_error,
    ) -> ob_depth_work_mode;
}
unsafe extern "C" {
    #[doc = " @brief Free the resources of ob_depth_work_mode_list\n\n @param[in] work_mode_list Data structure containing a list of ob_depth_work_mode\n @param[out] error Pointer to an error object that will be set if an error occurs.\n"]
    pub fn ob_delete_depth_work_mode_list(
        work_mode_list: *mut ob_depth_work_mode_list,
        error: *mut *mut ob_error,
    );
}
unsafe extern "C" {
    #[doc = " @brief Get the current preset name.\n @brief The preset mean a set of parameters or configurations that can be applied to the device to achieve a specific effect or function.\n\n @param device The device object.\n @param error  Pointer to an error object that will be set if an error occurs.\n @return  The current preset name, it should be one of the preset names returned by @ref ob_device_get_available_preset_list."]
    pub fn ob_device_get_current_preset_name(
        device: *const ob_device,
        error: *mut *mut ob_error,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " @brief Get the available preset list.\n @attention After loading the preset, the settings in the preset will set to the device immediately. Therefore, it is recommended to re-read the device\n settings to update the user program temporarily.\n\n @param device The device object.\n @param preset_name  Pointer to an error object that will be set if an error occurs. The name should be one of the preset names returned by @ref\n ob_device_get_available_preset_list.\n @param error  Pointer to an error object that will be set if an error occurs."]
    pub fn ob_device_load_preset(
        device: *mut ob_device,
        preset_name: *const ::std::os::raw::c_char,
        error: *mut *mut ob_error,
    );
}
unsafe extern "C" {
    #[doc = " @brief Load preset from json string.\n @brief After loading the custom preset, the settings in the custom preset will set to the device immediately.\n @brief After loading the custom preset, the available preset list will be appended with the custom preset and named as the file name.\n\n @param device   The device object.\n @param json_file_path  The json file path.\n @param error   Pointer to an error object that will be set if an error occurs."]
    pub fn ob_device_load_preset_from_json_file(
        device: *mut ob_device,
        json_file_path: *const ::std::os::raw::c_char,
        error: *mut *mut ob_error,
    );
}
unsafe extern "C" {
    #[doc = " @brief Load custom preset from data.\n @brief After loading the custom preset, the settings in the custom preset will set to the device immediately.\n @brief After loading the custom preset, the available preset list will be appended with the custom preset and named as the @ref presetName.\n\n @attention The user should ensure that the custom preset data is adapted to the device and the settings in the data are valid.\n @attention It is recommended to re-read the device settings to update the user program temporarily after successfully loading the custom preset.\n\n @param data The custom preset data.\n @param size The size of the custom preset data."]
    pub fn ob_device_load_preset_from_json_data(
        device: *mut ob_device,
        presetName: *const ::std::os::raw::c_char,
        data: *const u8,
        size: u32,
        error: *mut *mut ob_error,
    );
}
unsafe extern "C" {
    #[doc = " @brief Export current settings as a preset json file.\n @brief After exporting the custom preset, the available preset list will be appended with the custom preset and named as the file name.\n\n @param device   The device object.\n @param json_file_path  The json file path.\n @param error   Pointer to an error object that will be set if an error occurs."]
    pub fn ob_device_export_current_settings_as_preset_json_file(
        device: *mut ob_device,
        json_file_path: *const ::std::os::raw::c_char,
        error: *mut *mut ob_error,
    );
}
unsafe extern "C" {
    #[doc = " @brief Export current device settings as a preset json data.\n @brief After exporting the preset, a new preset named as the @ref presetName will be added to the available preset list.\n\n @attention The memory of the data is allocated by the SDK, and will automatically be released by the SDK.\n @attention The memory of the data will be reused by the SDK on the next call, so the user should copy the data to a new buffer if it needs to be\n preserved.\n\n @param[out] data return the preset json data.\n @param[out] dataSize return the size of the preset json data."]
    pub fn ob_device_export_current_settings_as_preset_json_data(
        device: *mut ob_device,
        presetName: *const ::std::os::raw::c_char,
        data: *mut *const u8,
        dataSize: *mut u32,
        error: *mut *mut ob_error,
    );
}
unsafe extern "C" {
    #[doc = " @brief Get the available preset list.\n\n @param device The device object.\n @param error  Pointer to an error object that will be set if an error occurs.\n @return  The available preset list."]
    pub fn ob_device_get_available_preset_list(
        device: *const ob_device,
        error: *mut *mut ob_error,
    ) -> *mut ob_device_preset_list;
}
unsafe extern "C" {
    #[doc = " @brief Delete the available preset list.\n\n @param preset_list The available preset list.\n @param error  Pointer to an error object that will be set if an error occurs."]
    pub fn ob_delete_preset_list(
        preset_list: *mut ob_device_preset_list,
        error: *mut *mut ob_error,
    );
}
unsafe extern "C" {
    #[doc = " @brief Get the number of preset in the preset list.\n\n @param preset_list The available preset list.\n @param error  Pointer to an error object that will be set if an error occurs.\n @return  The number of preset in the preset list."]
    pub fn ob_device_preset_list_get_count(
        preset_list: *const ob_device_preset_list,
        error: *mut *mut ob_error,
    ) -> u32;
}
unsafe extern "C" {
    #[doc = " @brief Get the name of the preset in the preset list.\n\n @param preset_list The available preset list.\n @param index  The index of the preset in the preset list.\n @param error  Pointer to an error object that will be set if an error occurs.\n @return  The name of the preset in the preset list."]
    pub fn ob_device_preset_list_get_name(
        preset_list: *const ob_device_preset_list,
        index: u32,
        error: *mut *mut ob_error,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " @brief Check if the preset list has the preset.\n\n @param preset_list The available preset list.\n @param preset_name  The name of the preset.\n @param error  Pointer to an error object that will be set if an error occurs.\n @return  Whether the preset list has the preset. If true, the preset list has the preset. If false, the preset list does not have the preset."]
    pub fn ob_device_preset_list_has_preset(
        preset_list: *const ob_device_preset_list,
        preset_name: *const ::std::os::raw::c_char,
        error: *mut *mut ob_error,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " @brief Check if the device supports the frame interleave feature.\n\n @param device The device object.\n @param error  Pointer to an error object that will be set if an error occurs.\n @return bool Returns true if the device supports the frame interleave feature."]
    pub fn ob_device_is_frame_interleave_supported(
        device: *const ob_device,
        error: *mut *mut ob_error,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " @brief load the frame interleave mode according to frame interleavee name.\n\n @param device The device object.\n @param frame_interleave_name  The name should be one of the frame interleave names returned by @ref ob_device_get_available_frame_interleave_list.\n @param error  Log error messages."]
    pub fn ob_device_load_frame_interleave(
        device: *mut ob_device,
        frame_interleave_name: *const ::std::os::raw::c_char,
        error: *mut *mut ob_error,
    );
}
unsafe extern "C" {
    #[doc = " @brief Get the available frame interleave list.\n\n @param device The device object.\n @param error  Log error messages.\n @return The available frame interleave list."]
    pub fn ob_device_get_available_frame_interleave_list(
        device: *mut ob_device,
        error: *mut *mut ob_error,
    ) -> *mut ob_device_frame_interleave_list;
}
unsafe extern "C" {
    #[doc = " @brief Delete the available frame interleave list.\n\n @param frame_interleave_list The available frame interleave list.\n @param error  Log error messages."]
    pub fn ob_delete_frame_interleave_list(
        frame_interleave_list: *mut ob_device_frame_interleave_list,
        error: *mut *mut ob_error,
    );
}
unsafe extern "C" {
    #[doc = " @brief Get the number of frame interleave in the frame interleave list.\n\n @param frame_interleave_list The available frame interleave list.\n @param error  Log error messages.\n @return  The number of frame interleave in the frame interleave list."]
    pub fn ob_device_frame_interleave_list_get_count(
        frame_interleave_list: *mut ob_device_frame_interleave_list,
        error: *mut *mut ob_error,
    ) -> u32;
}
unsafe extern "C" {
    #[doc = " @brief Get the name of frame interleave in the frame interleave list.\n\n @param frame_interleave_list The available frame interleave list.\n @param index  The index of frame interleave in the frame interleave list.\n @param error  Log error messages.\n @return  The name of frame interleave in the frame interleave list.."]
    pub fn ob_device_frame_interleave_list_get_name(
        frame_interleave_list: *mut ob_device_frame_interleave_list,
        index: u32,
        error: *mut *mut ob_error,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " @brief Check if the interleave ae list has the interleave ae.\n\n @param frame_interleave_list The available interleave ae list.\n @param frame_interleave_name  The name of the interleave ae.\n @param error  Log error messages.\n @return  Whether the interleave ae list has the interleave ae. If true, the interleave ae list has the interleave ae. If false, the interleave ae list does\n not have the interleave ae."]
    pub fn ob_device_frame_interleave_list_has_frame_interleave(
        frame_interleave_list: *mut ob_device_frame_interleave_list,
        frame_interleave_name: *const ::std::os::raw::c_char,
        error: *mut *mut ob_error,
    ) -> bool;
}
unsafe extern "C" {
    pub fn ob_device_get_available_preset_resolution_config_list(
        device: *mut ob_device,
        error: *mut *mut ob_error,
    ) -> *mut ob_preset_resolution_config_list;
}
unsafe extern "C" {
    pub fn ob_device_preset_resolution_config_get_count(
        ob_preset_resolution_config_list: *mut ob_preset_resolution_config_list,
        error: *mut *mut ob_error,
    ) -> u32;
}
unsafe extern "C" {
    #[doc = " @brief Get the preset resolution in the preset resolution list.\n\n @param ob_preset_resolution_config_list The available preset resolution list.\n @param index  The index of preset resolution in the preset resolution list.\n @param error  Log error messages.\n @return  The preset resolution in the preset resolution list."]
    pub fn ob_device_preset_resolution_config_list_get_item(
        ob_preset_resolution_config_list: *const ob_preset_resolution_config_list,
        index: u32,
        error: *mut *mut ob_error,
    ) -> OBPresetResolutionConfig;
}
unsafe extern "C" {
    #[doc = " @brief Delete the available preset resolution list.\n\n @param frame_interleave_list The available preset resolution list.\n @param error  Log error messages."]
    pub fn ob_delete_preset_resolution_config_list(
        ob_preset_resolution_config_list: *mut ob_preset_resolution_config_list,
        error: *mut *mut ob_error,
    );
}
unsafe extern "C" {
    #[doc = " @brief Delete a device.\n\n @param[in] device The device to be deleted.\n @param[out] error Pointer to an error object that will be set if an error occurs."]
    pub fn ob_delete_device(device: *mut ob_device, error: *mut *mut ob_error);
}
unsafe extern "C" {
    #[doc = " @brief List all sensors.\n\n @param[in] device The device object.\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return ob_sensor_list* The list of all sensors."]
    pub fn ob_device_get_sensor_list(
        device: *const ob_device,
        error: *mut *mut ob_error,
    ) -> *mut ob_sensor_list;
}
unsafe extern "C" {
    #[doc = " @brief Get a device's sensor.\n\n @param[in] device The device object.\n @param[in] type The type of sensor to get.\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return ob_sensor* The acquired sensor."]
    pub fn ob_device_get_sensor(
        device: *mut ob_device,
        type_: ob_sensor_type,
        error: *mut *mut ob_error,
    ) -> *mut ob_sensor;
}
unsafe extern "C" {
    #[doc = " @brief Set an integer type of device property.\n\n @param[in] device The device object.\n @param[in] property_id The ID of the property to be set.\n @param[in] value The property value to be set.\n @param[out] error Pointer to an error object that will be set if an error occurs."]
    pub fn ob_device_set_int_property(
        device: *mut ob_device,
        property_id: ob_property_id,
        value: i32,
        error: *mut *mut ob_error,
    );
}
unsafe extern "C" {
    #[doc = " @brief Get an integer type of device property.\n\n @param[in] device The device object.\n @param[in] property_id The property ID.\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return int32_t The property value."]
    pub fn ob_device_get_int_property(
        device: *mut ob_device,
        property_id: ob_property_id,
        error: *mut *mut ob_error,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " @brief Get the integer type of device property range.\n\n @param[in] device The device object.\n @param[in] property_id The property id.\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return The property range."]
    pub fn ob_device_get_int_property_range(
        device: *mut ob_device,
        property_id: ob_property_id,
        error: *mut *mut ob_error,
    ) -> ob_int_property_range;
}
unsafe extern "C" {
    #[doc = " @brief Set a float type of device property.\n\n @param[in] device The device object.\n @param[in] property_id The ID of the property to be set.\n @param[in] value The property value to be set.\n @param[out] error Pointer to an error object that will be set if an error occurs."]
    pub fn ob_device_set_float_property(
        device: *mut ob_device,
        property_id: ob_property_id,
        value: f32,
        error: *mut *mut ob_error,
    );
}
unsafe extern "C" {
    #[doc = " @brief Get a float type of device property.\n\n @param[in] device The device object.\n @param[in] property_id The property ID.\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return float The property value."]
    pub fn ob_device_get_float_property(
        device: *mut ob_device,
        property_id: ob_property_id,
        error: *mut *mut ob_error,
    ) -> f32;
}
unsafe extern "C" {
    #[doc = " @brief Get the float type of device property range.\n\n @param[in] device The device object.\n @param[in] property_id The property id.\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return The property range."]
    pub fn ob_device_get_float_property_range(
        device: *mut ob_device,
        property_id: ob_property_id,
        error: *mut *mut ob_error,
    ) -> ob_float_property_range;
}
unsafe extern "C" {
    #[doc = " @brief Set a boolean type of device property.\n\n @param[in] device The device object.\n @param[in] property_id The ID of the property to be set.\n @param[in] value The property value to be set.\n @param[out] error Pointer to an error object that will be set if an error occurs."]
    pub fn ob_device_set_bool_property(
        device: *mut ob_device,
        property_id: ob_property_id,
        value: bool,
        error: *mut *mut ob_error,
    );
}
unsafe extern "C" {
    #[doc = " @brief Get a boolean type of device property.\n\n @param[in] device The device object.\n @param[in] property_id The property ID.\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return bool The property value."]
    pub fn ob_device_get_bool_property(
        device: *mut ob_device,
        property_id: ob_property_id,
        error: *mut *mut ob_error,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " @brief Get the boolean type of device property range.\n\n @param[in] device The device object.\n @param[in] property_id The property id.\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return The property range."]
    pub fn ob_device_get_bool_property_range(
        device: *mut ob_device,
        property_id: ob_property_id,
        error: *mut *mut ob_error,
    ) -> ob_bool_property_range;
}
unsafe extern "C" {
    #[doc = " @brief Set structured data.\n\n @param[in] device The device object.\n @param[in] property_id The ID of the property to be set.\n @param[in] data The property data to be set.\n @param[in] data_size The size of the property to be set.\n @param[out] error Pointer to an error object that will be set if an error occurs."]
    pub fn ob_device_set_structured_data(
        device: *mut ob_device,
        property_id: ob_property_id,
        data: *const u8,
        data_size: u32,
        error: *mut *mut ob_error,
    );
}
unsafe extern "C" {
    #[doc = " @brief Get structured data of a device property.\n\n @param[in] device The device object.\n @param[in] property_id The ID of the property.\n @param[out] data The obtained property data.\n @param[out] data_size The size of the obtained property data.\n @param[out] error Pointer to an error object that will be set if an error occurs."]
    pub fn ob_device_get_structured_data(
        device: *mut ob_device,
        property_id: ob_property_id,
        data: *mut u8,
        data_size: *mut u32,
        error: *mut *mut ob_error,
    );
}
unsafe extern "C" {
    #[doc = " @brief Get raw data of a device property.\n\n @param[in] device The device object.\n @param[in] property_id The ID of the property.\n @param[out] cb The get data callback.\n @param[out] user_data User-defined data that will be returned in the callback.\n @param[out] error Pointer to an error object that will be set if an error occurs."]
    pub fn ob_device_get_raw_data(
        device: *mut ob_device,
        property_id: ob_property_id,
        cb: ob_get_data_callback,
        user_data: *mut ::std::os::raw::c_void,
        error: *mut *mut ob_error,
    );
}
unsafe extern "C" {
    #[doc = " @brief Set customer data.\n\n @param[in] device The device object.\n @param[in] data The property data to be set.\n @param[in] data_size The size of the property to be set,the maximum length cannot exceed 65532 bytes.\n @param[out] error Log error messages."]
    pub fn ob_device_write_customer_data(
        device: *mut ob_device,
        data: *const ::std::os::raw::c_void,
        data_size: u32,
        error: *mut *mut ob_error,
    );
}
unsafe extern "C" {
    #[doc = " @brief Get customer data of a device property.\n\n @param[in] device The device object.\n @param[out] data The obtained property data.\n @param[out] data_size The size of the obtained property data.\n @param[out] error Log error messages."]
    pub fn ob_device_read_customer_data(
        device: *mut ob_device,
        data: *mut ::std::os::raw::c_void,
        data_size: *mut u32,
        error: *mut *mut ob_error,
    );
}
unsafe extern "C" {
    #[doc = " @brief Get the number of properties supported by the device.\n\n @param[in] device The device object.\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return The number of properties supported by the device."]
    pub fn ob_device_get_supported_property_count(
        device: *const ob_device,
        error: *mut *mut ob_error,
    ) -> u32;
}
unsafe extern "C" {
    #[doc = " @brief Get the type of property supported by the device.\n\n @param[in] device The device object.\n @param[in] index The property index.\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return The type of property supported by the device."]
    pub fn ob_device_get_supported_property_item(
        device: *const ob_device,
        index: u32,
        error: *mut *mut ob_error,
    ) -> ob_property_item;
}
unsafe extern "C" {
    #[doc = " @brief Check if a device property permission is supported.\n\n @param[in] device The device object.\n @param[in] property_id The property id.\n @param[in] permission The type of permission that needs to be interpreted.\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return Whether the property permission is supported."]
    pub fn ob_device_is_property_supported(
        device: *const ob_device,
        property_id: ob_property_id,
        permission: ob_permission_type,
        error: *mut *mut ob_error,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " @brief Check if the device supports global timestamp.\n\n @param[in] device The device object.\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return bool Whether the device supports global timestamp."]
    pub fn ob_device_is_global_timestamp_supported(
        device: *const ob_device,
        error: *mut *mut ob_error,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " @brief Enable or disable global timestamp.\n\n @param device The device object.\n @param enable Whether to enable global timestamp.\n @param error Pointer to an error object that will be set if an error occurs."]
    pub fn ob_device_enable_global_timestamp(
        device: *mut ob_device,
        enable: bool,
        error: *mut *mut ob_error,
    );
}
unsafe extern "C" {
    #[doc = " @brief Update the device firmware.\n\n @param[in] device The device object.\n @param[in] path The firmware path.\n @param[in] callback The firmware upgrade progress callback.\n @param[in] async Whether to execute asynchronously.\n @param[in] user_data User-defined data that will be returned in the callback.\n @param[out] error Pointer to an error object that will be set if an error occurs."]
    pub fn ob_device_update_firmware(
        device: *mut ob_device,
        path: *const ::std::os::raw::c_char,
        callback: ob_device_fw_update_callback,
        async_: bool,
        user_data: *mut ::std::os::raw::c_void,
        error: *mut *mut ob_error,
    );
}
unsafe extern "C" {
    #[doc = " @brief Update the device firmware from data.\n\n @param[in] device The device object.\n @param[in] data The firmware file data.\n @param[in] data_size The firmware file size.\n @param[in] callback The firmware upgrade progress callback.\n @param[in] async Whether to execute asynchronously.\n @param[in] user_data User-defined data that will be returned in the callback.\n @param[out] error Pointer to an error object that will be set if an error occurs."]
    pub fn ob_device_update_firmware_from_data(
        device: *mut ob_device,
        data: *const u8,
        data_size: u32,
        callback: ob_device_fw_update_callback,
        async_: bool,
        user_data: *mut ::std::os::raw::c_void,
        error: *mut *mut ob_error,
    );
}
unsafe extern "C" {
    #[doc = " @brief Update the device optional depth presets.\n\n @param[in] device The device object.\n @param[in] file_path_list A list(2D array) of preset file paths, each up to OB_PATH_MAX characters.\n @param[in] path_count The number of the preset file paths.\n @param[in] callback The preset upgrade progress callback.\n @param[in] user_data User-defined data that will be returned in the callback.\n @param[out] error Pointer to an error object that will be set if an error occurs."]
    pub fn ob_device_update_optional_depth_presets(
        device: *mut ob_device,
        file_path_list: *const [::std::os::raw::c_char; 1024usize],
        path_count: u8,
        callback: ob_device_fw_update_callback,
        user_data: *mut ::std::os::raw::c_void,
        error: *mut *mut ob_error,
    );
}
unsafe extern "C" {
    #[doc = " @brief Device reboot\n @attention The device will be disconnected and reconnected. After the device is disconnected, the interface access to the device handle may be abnormal.\n Please use the ob_delete_device interface to delete the handle directly. After the device is reconnected, it can be obtained again.\n\n @param[in] device Device object\n @param[out] error Pointer to an error object that will be set if an error occurs."]
    pub fn ob_device_reboot(device: *mut ob_device, error: *mut *mut ob_error);
}
unsafe extern "C" {
    #[doc = " @brief Get the current device status.\n\n @param[in] device The device object.\n @param[out] error Pointer to an error object that will be set if an error occurs.\n\n @return ob_device_state The device state information."]
    pub fn ob_device_get_device_state(
        device: *const ob_device,
        error: *mut *mut ob_error,
    ) -> ob_device_state;
}
unsafe extern "C" {
    #[doc = " @brief Set the device state changed callback.\n\n @param[in] device The device object.\n @param[in] callback The callback function to be called when the device status changes.\n @param[in] user_data User-defined data that will be returned in the callback.\n @param[out] error Pointer to an error object that will be set if an error occurs."]
    pub fn ob_device_set_state_changed_callback(
        device: *mut ob_device,
        callback: ob_device_state_callback,
        user_data: *mut ::std::os::raw::c_void,
        error: *mut *mut ob_error,
    );
}
unsafe extern "C" {
    #[doc = " @brief Enable or disable the device heartbeat.\n @brief After enable the device heartbeat, the sdk will start a thread to send heartbeat signal to the device error every 3 seconds.\n\n @attention If the device does not receive the heartbeat signal for a long time, it will be disconnected and rebooted.\n\n @param[in] device The device object.\n @param[in] enable Whether to enable the device heartbeat.\n @param error Pointer to an error object that will be set if an error occurs."]
    pub fn ob_device_enable_heartbeat(
        device: *mut ob_device,
        enable: bool,
        error: *mut *mut ob_error,
    );
}
unsafe extern "C" {
    #[doc = " @brief Send data to the device and receive data from the device.\n @brief This is a factory and debug function, which can be used to send and receive data from the device. The data format is secret and belongs to the device\n vendor.\n\n @param[in] device The device object.\n @param[in] send_data The data to be sent to the device.\n @param[in] send_data_size The size of the data to be sent to the device.\n @param[out] receive_data The data received from the device.\n @param[in,out] receive_data_size Pass in the expected size of the receive data, and return the actual size of the received data.\n @param error Pointer to an error object that will be set if an error occurs."]
    pub fn ob_device_send_and_receive_data(
        device: *mut ob_device,
        send_data: *const u8,
        send_data_size: u32,
        receive_data: *mut u8,
        receive_data_size: *mut u32,
        error: *mut *mut ob_error,
    );
}
unsafe extern "C" {
    #[doc = " @brief Get device information.\n\n @param[in] device The device to obtain information from.\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return ob_device_info* The device information."]
    pub fn ob_device_get_device_info(
        device: *const ob_device,
        error: *mut *mut ob_error,
    ) -> *mut ob_device_info;
}
unsafe extern "C" {
    #[doc = " @brief Delete device information.\n\n @param[in] info The device information to be deleted.\n @param[out] error Pointer to an error object that will be set if an error occurs."]
    pub fn ob_delete_device_info(info: *mut ob_device_info, error: *mut *mut ob_error);
}
unsafe extern "C" {
    #[doc = " @brief Get device name\n\n @param[in] info Device Information\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return const char* return the device name"]
    pub fn ob_device_info_get_name(
        info: *const ob_device_info,
        error: *mut *mut ob_error,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " @brief Get device pid\n\n @param[in] info Device Information\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return int return the device pid"]
    pub fn ob_device_info_get_pid(
        info: *const ob_device_info,
        error: *mut *mut ob_error,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Get device vid\n\n @param[in] info Device Information\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return int return device vid"]
    pub fn ob_device_info_get_vid(
        info: *const ob_device_info,
        error: *mut *mut ob_error,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Get device uid\n\n @param[in] info Device Information\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return const char* return device uid"]
    pub fn ob_device_info_get_uid(
        info: *const ob_device_info,
        error: *mut *mut ob_error,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " @brief Get device serial number\n\n @param[in] info Device Information\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return const char* return device serial number"]
    pub fn ob_device_info_get_serial_number(
        info: *const ob_device_info,
        error: *mut *mut ob_error,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " @brief Get the firmware version number\n\n @param[in] info Device Information\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return int return the firmware version number"]
    pub fn ob_device_info_get_firmware_version(
        info: *const ob_device_info,
        error: *mut *mut ob_error,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " @brief Get the device connection type\n\n @param[in] info Device Information\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return const char* The connection type, currently supports: \"USB\", \"USB1.0\", \"USB1.1\", \"USB2.0\", \"USB2.1\", \"USB3.0\", \"USB3.1\", \"USB3.2\", \"Ethernet\""]
    pub fn ob_device_info_get_connection_type(
        info: *const ob_device_info,
        error: *mut *mut ob_error,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " @brief Get the device IP address\n\n @attention Only valid for network devices, otherwise it will return \"0.0.0.0\"\n\n @param info Device Information\n @param error Pointer to an error object that will be set if an error occurs.\n @return const char* The IP address, such as \"192.168.1.10\""]
    pub fn ob_device_info_get_ip_address(
        info: *const ob_device_info,
        error: *mut *mut ob_error,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " @brief Get the hardware version number\n\n @param[in] info Device Information\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return const char* The hardware version number"]
    pub fn ob_device_info_get_hardware_version(
        info: *const ob_device_info,
        error: *mut *mut ob_error,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " @brief Check if the device extension information exists.\n\n @param device The device object.\n @param info_key The key of the device extension information.\n @param error Pointer to an error object that will be set if an error occurs.\n @return bool Whether the device extension information exists."]
    pub fn ob_device_is_extension_info_exist(
        device: *const ob_device,
        info_key: *const ::std::os::raw::c_char,
        error: *mut *mut ob_error,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " @brief Get the device extension information.\n @brief Extension information is a set of key-value pair of string, user cat get the information by the key.\n\n @param[in] device The device object.\n @param[in] info_key The key of the device extension information.\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return const char* The device extension information"]
    pub fn ob_device_get_extension_info(
        device: *const ob_device,
        info_key: *const ::std::os::raw::c_char,
        error: *mut *mut ob_error,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " @brief Get the minimum SDK version number supported by the device\n\n @param[in] info Device Information\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return const char* The minimum SDK version number supported by the device"]
    pub fn ob_device_info_get_supported_min_sdk_version(
        info: *const ob_device_info,
        error: *mut *mut ob_error,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " @brief Get the chip name\n\n @param[in] info Device Information\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return const char* The ASIC name"]
    pub fn ob_device_info_get_asicName(
        info: *const ob_device_info,
        error: *mut *mut ob_error,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " @brief Get the device type\n\n @param[in] info Device Information\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return ob_device_type The device type"]
    pub fn ob_device_info_get_device_type(
        info: *const ob_device_info,
        error: *mut *mut ob_error,
    ) -> ob_device_type;
}
unsafe extern "C" {
    #[doc = " @brief Delete a device list.\n\n @param[in] list The device list object to be deleted.\n @param[out] error Pointer to an error object that will be set if an error occurs."]
    pub fn ob_delete_device_list(list: *mut ob_device_list, error: *mut *mut ob_error);
}
unsafe extern "C" {
    #[doc = " @brief Get the number of devices\n\n @param[in] list Device list object\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return uint32_t return the number of devices"]
    pub fn ob_device_list_get_count(list: *const ob_device_list, error: *mut *mut ob_error) -> u32;
}
unsafe extern "C" {
    #[doc = " @brief Get device name\n\n @param[in] list Device list object\n @param[in] index Device index\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return const char* return device name"]
    pub fn ob_device_list_get_device_name(
        list: *const ob_device_list,
        index: u32,
        error: *mut *mut ob_error,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " @brief Get the pid of the specified device\n\n @param[in] list Device list object\n @param[in] index Device index\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return int return the device pid"]
    pub fn ob_device_list_get_device_pid(
        list: *const ob_device_list,
        index: u32,
        error: *mut *mut ob_error,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Get the vid of the specified device\n\n @param[in] list Device list object\n @param[in] index Device index\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return int return device vid"]
    pub fn ob_device_list_get_device_vid(
        list: *const ob_device_list,
        index: u32,
        error: *mut *mut ob_error,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Get the uid of the specified device\n\n @param[in] list Device list object\n @param[in] index Device index\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return const char* return the device uid"]
    pub fn ob_device_list_get_device_uid(
        list: *const ob_device_list,
        index: u32,
        error: *mut *mut ob_error,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " @brief Get the serial number of the specified device.\n\n @param[in] list Device list object.\n @param[in] index Device index.\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return const char* The device UID."]
    pub fn ob_device_list_get_device_serial_number(
        list: *const ob_device_list,
        index: u32,
        error: *mut *mut ob_error,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " @brief Get device connection type\n\n @param[in] list Device list object\n @param[in] index Device index\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return const char* returns the device connection type, currently supports: \"USB\", \"USB1.0\", \"USB1.1\", \"USB2.0\", \"USB2.1\", \"USB3.0\", \"USB3.1\", \"USB3.2\",\n \"Ethernet\""]
    pub fn ob_device_list_get_device_connection_type(
        list: *const ob_device_list,
        index: u32,
        error: *mut *mut ob_error,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " @brief Get device ip address\n\n @attention Only valid for network devices, otherwise it will return \"0.0.0.0\".\n\n @param list Device list object\n @param index Device index\n @param error Pointer to an error object that will be set if an error occurs.\n @return const char* returns the device ip address, such as \"192.168.1.10\""]
    pub fn ob_device_list_get_device_ip_address(
        list: *const ob_device_list,
        index: u32,
        error: *mut *mut ob_error,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " @brief Get device local mac address\n\n @attention Only valid for network devices, otherwise it will return \"0:0:0:0:0:0\".\n\n @param list Device list object\n @param index Device index\n @param error Pointer to an error object that will be set if an error occurs.\n @return const char* returns the device mac address"]
    pub fn ob_device_list_get_device_local_mac(
        list: *const ob_device_list,
        index: u32,
        error: *mut *mut ob_error,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " @brief Create a device.\n\n @attention If the device has already been acquired and created elsewhere, repeated acquisitions will return an error.\n\n @param[in] list Device list object.\n @param[in] index The index of the device to create.\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return ob_device* The created device.\n"]
    pub fn ob_device_list_get_device(
        list: *const ob_device_list,
        index: u32,
        error: *mut *mut ob_error,
    ) -> *mut ob_device;
}
unsafe extern "C" {
    #[doc = " @brief Create a device.\n\n @attention If the device has already been acquired and created elsewhere, repeated acquisitions will return an error.\n\n @param[in] list Device list object.\n @param[in] serial_number The serial number of the device to create.\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return ob_device* The created device."]
    pub fn ob_device_list_get_device_by_serial_number(
        list: *const ob_device_list,
        serial_number: *const ::std::os::raw::c_char,
        error: *mut *mut ob_error,
    ) -> *mut ob_device;
}
unsafe extern "C" {
    #[doc = " @brief Create device by uid\n @brief On Linux platform, for usb device, the uid of the device is composed of bus-port-dev, for example 1-1.2-1. But the SDK will remove the dev number and\n only keep the bus-port as the uid to create the device, for example 1-1.2, so that we can create a device connected to the specified USB port. Similarly,\n users can also directly pass in bus-port as uid to create device.\n @brief For GMSL device, the uid is GMSL port with \"gmsl2-\" prefix, for example gmsl2-1.\n\n @attention If the device has already been acquired and created elsewhere, repeated acquisitions will return an error.\n\n @param[in] list Device list object.\n @param[in] uid The UID of the device to create.\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return ob_device* The created device."]
    pub fn ob_device_list_get_device_by_uid(
        list: *const ob_device_list,
        uid: *const ::std::os::raw::c_char,
        error: *mut *mut ob_error,
    ) -> *mut ob_device;
}
unsafe extern "C" {
    #[doc = " @brief Get the original parameter list of camera calibration saved on the device.\n\n @attention The parameters in the list do not correspond to the current open-stream configuration.You need to select the parameters according to the actual\n situation, and may need to do scaling, mirroring and other processing. Non-professional users are recommended to use the ob_pipeline_get_camera_param()\n interface.\n\n @param[in] device The device object.\n @param[out] error Log error messages.\n\n @return ob_camera_param_list The camera parameter list."]
    pub fn ob_device_get_calibration_camera_param_list(
        device: *mut ob_device,
        error: *mut *mut ob_error,
    ) -> *mut ob_camera_param_list;
}
unsafe extern "C" {
    #[doc = " @brief Get the number of camera parameter lists\n\n @param[in] param_list Camera parameter list\n @param[out] error Log error messages\n @return uint32_t The number of lists"]
    pub fn ob_camera_param_list_get_count(
        param_list: *mut ob_camera_param_list,
        error: *mut *mut ob_error,
    ) -> u32;
}
unsafe extern "C" {
    #[doc = " @brief Get camera parameters from the camera parameter list\n\n @param[in] param_list Camera parameter list\n @param[in] index Parameter index\n @param[out] error Log error messages\n @return ob_camera_param The camera parameters. Since it returns the structure object directly, there is no need to provide a delete interface."]
    pub fn ob_camera_param_list_get_param(
        param_list: *mut ob_camera_param_list,
        index: u32,
        error: *mut *mut ob_error,
    ) -> ob_camera_param;
}
unsafe extern "C" {
    #[doc = " @brief Delete the camera parameter list\n\n @param[in] param_list Camera parameter list\n @param[out] error Log error messages"]
    pub fn ob_delete_camera_param_list(
        param_list: *mut ob_camera_param_list,
        error: *mut *mut ob_error,
    );
}
unsafe extern "C" {
    #[doc = " @brief Create a new error object.\n\n @param status The error status.\n @param message The error message.\n @param function The name of the API function that caused the error.\n @param args The error parameters.\n @param exception_type The type of exception that caused the error.\n @return ob_error* The new error object."]
    pub fn ob_create_error(
        status: ob_status,
        message: *const ::std::os::raw::c_char,
        function: *const ::std::os::raw::c_char,
        args: *const ::std::os::raw::c_char,
        exception_type: ob_exception_type,
    ) -> *mut ob_error;
}
unsafe extern "C" {
    #[doc = " @brief Get the error status.\n\n @param[in] error The error object.\n @return The error status."]
    pub fn ob_error_get_status(error: *const ob_error) -> ob_status;
}
unsafe extern "C" {
    #[doc = " @brief Get the error message.\n\n @param[in] error The error object.\n @return The error message."]
    pub fn ob_error_get_message(error: *const ob_error) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " @brief Get the name of the API function that caused the error.\n\n @param[in] error The error object.\n @return The name of the API function."]
    pub fn ob_error_get_function(error: *const ob_error) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " @brief Get the error parameters.\n\n @param[in] error The error object.\n @return The error parameters."]
    pub fn ob_error_get_args(error: *const ob_error) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " @brief Get the type of exception that caused the error.\n\n @param[in] error The error object.\n @return The type of exception."]
    pub fn ob_error_get_exception_type(error: *const ob_error) -> ob_exception_type;
}
unsafe extern "C" {
    #[doc = " @brief Delete the error object.\n\n @param[in] error The error object to delete, you should set the pointer to NULL after calling this function."]
    pub fn ob_delete_error(error: *mut ob_error);
}
unsafe extern "C" {
    #[doc = " @brief Create a Filter object.\n\n @attention If the filter of the specified name is a private filter, and the creator of the filter have not been activated, the function will return NULL.\n\n @param name The name of the filter.\n @param error Pointer to an error object that will be set if an error occurs."]
    pub fn ob_create_filter(
        name: *const ::std::os::raw::c_char,
        error: *mut *mut ob_error,
    ) -> *mut ob_filter;
}
unsafe extern "C" {
    #[doc = " @brief Get the name of ob_filter\n\n @param filter ob_filter object\n @param error Pointer to an error object that will be set if an error occurs.\n @return char The filter of name"]
    pub fn ob_filter_get_name(
        filter: *const ob_filter,
        error: *mut *mut ob_error,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " @brief Get the vendor specific code of a filter by filter name.\n @brief A private filter can define its own vendor specific code for specific purposes.\n\n @param name The name of the filter.\n @param error Pointer to an error object that will be set if an error occurs.\n @return const char* Return the vendor specific code of the filter."]
    pub fn ob_filter_get_vendor_specific_code(
        name: *const ::std::os::raw::c_char,
        error: *mut *mut ob_error,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " @brief Create a private Filter object with activation key.\n @brief Some private filters require an activation key to be activated, its depends on the vendor of the filter.\n\n @param name The name of the filter.\n @param activation_key The activation key of the filter.\n @param error Pointer to an error object that will be set if an error occurs.\n\n @return ob_filter* Return the private filter object."]
    pub fn ob_create_private_filter(
        name: *const ::std::os::raw::c_char,
        activation_key: *const ::std::os::raw::c_char,
        error: *mut *mut ob_error,
    ) -> *mut ob_filter;
}
unsafe extern "C" {
    #[doc = " @brief Delete the filter.\n\n @param[in] filter The filter object to be deleted.\n @param[out] error Pointer to an error object that will be set if an error occurs."]
    pub fn ob_delete_filter(filter: *mut ob_filter, error: *mut *mut ob_error);
}
unsafe extern "C" {
    #[doc = " @brief Get config schema of the filter\n @brief The returned string is a csv format string representing the configuration schema of the filter. The format of the string is:\n  <parameter_name>, <parameter_type: \"int\", \"float\", \"bool\">, <minimum_value>, <maximum_value>, <value_step>, <default_value>, <parameter_description>\n\n @param[in] filter The filter object to get the configuration schema for\n @param[out] error Pointer to an error object that will be set if an error occurs\n\n @return A csv format string representing the configuration schema of the filter"]
    pub fn ob_filter_get_config_schema(
        filter: *const ob_filter,
        error: *mut *mut ob_error,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " @brief Get the filter config schema list of the filter\n @brief The returned string is a list of ob_config_schema_item representing the configuration schema of the filter.\n\n @attention The returned list should be deleted by calling @ref ob_delete_filter_config_schema_list when it is no longer needed.\n\n @param filter The filter object to get the configuration schema for\n @param error Pointer to an error object that will be set if an error occurs\n @return ob_filter_config_schema_list* Return the filter config schema list of the filter"]
    pub fn ob_filter_get_config_schema_list(
        filter: *const ob_filter,
        error: *mut *mut ob_error,
    ) -> *mut ob_filter_config_schema_list;
}
unsafe extern "C" {
    #[doc = " @brief Delete a list of filter config schema items.\n\n @param config_schema_list The list of filter config schema items to delete.\n @param error Pointer to an error object that will be set if an error occurs."]
    pub fn ob_delete_filter_config_schema_list(
        config_schema_list: *mut ob_filter_config_schema_list,
        error: *mut *mut ob_error,
    );
}
unsafe extern "C" {
    #[doc = " @brief Update config of the filter\n\n @attention The passed in argc and argv must match the configuration schema returned by the @ref ob_filter_get_config_schema function.\n\n @param[in] filter The filter object to update the configuration for\n @param[in] argc The number of arguments in the argv array\n @param[in] argv An array of strings representing the configuration values\n @param[out] error Pointer to an error object that will be set if an error occurs"]
    pub fn ob_filter_update_config(
        filter: *mut ob_filter,
        argc: u8,
        argv: *mut *const ::std::os::raw::c_char,
        error: *mut *mut ob_error,
    );
}
unsafe extern "C" {
    #[doc = " @brief Get the filter config value by name and cast to double.\n\n @attention The returned value is cast to double, the actual type of the value depends on the filter config schema returned by @ref\n ob_filter_get_config_schema.\n\n @param[in] filter A filter object.\n @param[in] config_name config name\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return double The value of the config."]
    pub fn ob_filter_get_config_value(
        filter: *const ob_filter,
        config_name: *const ::std::os::raw::c_char,
        error: *mut *mut ob_error,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " @brief Set the filter config value by name.\n\n @attention The pass into value type is double, witch will be cast to the actual type inside the filter. The actual type can be queried by the filter config\n schema returned by @ref ob_filter_get_config_schema.\n\n @param[in] filter A filter object.\n @param[in] config_name config name\n @param[in] value The value to set.\n @param[out] error Pointer to an error object that will be set if an error occurs."]
    pub fn ob_filter_set_config_value(
        filter: *mut ob_filter,
        config_name: *const ::std::os::raw::c_char,
        value: f64,
        error: *mut *mut ob_error,
    );
}
unsafe extern "C" {
    #[doc = " @brief Reset the filter, clears the cache, and resets the state. If the asynchronous interface is used, the processing thread will also be stopped and the\n pending cache frames will be cleared.\n\n @param[in] filter A filter object.\n @param[out] error Pointer to an error object that will be set if an error occurs."]
    pub fn ob_filter_reset(filter: *mut ob_filter, error: *mut *mut ob_error);
}
unsafe extern "C" {
    #[doc = " @brief Enable the frame post processing\n @brief The filter default is enable.\n\n @attention If the filter has been disabled by calling this function, processing will directly output a clone of the input frame.\n\n @param[in] filter A filter object.\n @param[in] enable enable status, true: enable; false: disable.\n @param[out] error Pointer to an error object that will be set if an error occurs."]
    pub fn ob_filter_enable(filter: *mut ob_filter, enable: bool, error: *mut *mut ob_error);
}
unsafe extern "C" {
    #[doc = " @brief Get the enable status of the frame post processing\n\n @attention If the filter is disabled, the processing will directly output a clone of the input frame.\n\n @param[in] filter A filter object.\n @param[out] error Pointer to an error object that will be set if an error occurs.\n\n @return The post processing filter status. True: enable; False: disable."]
    pub fn ob_filter_is_enabled(filter: *const ob_filter, error: *mut *mut ob_error) -> bool;
}
unsafe extern "C" {
    #[doc = " @brief Process the frame (synchronous interface).\n\n @param[in] filter A filter object.\n @param[in] frame Pointer to the frame object to be processed.\n @param[out] error Pointer to an error object that will be set if an error occurs.\n\n @return The frame object processed by the filter."]
    pub fn ob_filter_process(
        filter: *mut ob_filter,
        frame: *const ob_frame,
        error: *mut *mut ob_error,
    ) -> *mut ob_frame;
}
unsafe extern "C" {
    #[doc = " @brief Set the processing result callback function for the filter (asynchronous callback interface).\n\n @param[in] filter A filter object.\n @param[in] callback Callback function.\n @param[in] user_data Arbitrary user data pointer can be passed in and returned from the callback.\n @param[out] error Pointer to an error object that will be set if an error occurs."]
    pub fn ob_filter_set_callback(
        filter: *mut ob_filter,
        callback: ob_frame_callback,
        user_data: *mut ::std::os::raw::c_void,
        error: *mut *mut ob_error,
    );
}
unsafe extern "C" {
    #[doc = " @brief Push the frame into the pending cache for the filter (asynchronous callback interface).\n @brief The frame will be processed by the filter when the processing thread is available and return a new processed frame to the callback function.\n\n @attention The frame object will be add reference count, so the user still need call @ref ob_delete_frame to release the frame after calling this function.\n\n @param[in] filter A filter object.\n @param[in] frame Pointer to the frame object to be processed.\n @param[out] error Pointer to an error object that will be set if an error occurs."]
    pub fn ob_filter_push_frame(
        filter: *mut ob_filter,
        frame: *const ob_frame,
        error: *mut *mut ob_error,
    );
}
unsafe extern "C" {
    #[doc = " @brief Get the number of filter in the list\n\n @param[in] filter_list  filter list\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return uint32_t The number of list"]
    pub fn ob_filter_list_get_count(
        filter_list: *const ob_filter_list,
        error: *mut *mut ob_error,
    ) -> u32;
}
unsafe extern "C" {
    #[doc = " @brief Get the filter by index\n\n @param[in] filter_list Filter list\n @param[in] index  Filter index\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return ob_filter The index of ob_filter"]
    pub fn ob_filter_list_get_filter(
        filter_list: *const ob_filter_list,
        index: u32,
        error: *mut *mut ob_error,
    ) -> *mut ob_filter;
}
unsafe extern "C" {
    #[doc = " @brief Delete a list of ob_filter objects.\n\n @param[in] filter_list The list of ob_filter objects to delete.\n @param[out] error Pointer to an error object that will be set if an error occurs."]
    pub fn ob_delete_filter_list(filter_list: *mut ob_filter_list, error: *mut *mut ob_error);
}
unsafe extern "C" {
    #[doc = " @brief Get the number of config schema items in the config schema list\n\n @param config_schema_list Filter config schema list\n @param error Pointer to an error object that will be set if an error occurs.\n @return uint32_t The number of config schema items in the filter list"]
    pub fn ob_filter_config_schema_list_get_count(
        config_schema_list: *const ob_filter_config_schema_list,
        error: *mut *mut ob_error,
    ) -> u32;
}
unsafe extern "C" {
    #[doc = " @brief Get the config schema item by index\n\n @param config_schema_list Filter config schema list\n @param index  Config schema item index\n @param error Pointer to an error object that will be set if an error occurs.\n @return ob_filter_config_schema_item* The config schema item by index"]
    pub fn ob_filter_config_schema_list_get_item(
        config_schema_list: *const ob_filter_config_schema_list,
        index: u32,
        error: *mut *mut ob_error,
    ) -> ob_filter_config_schema_item;
}
unsafe extern "C" {
    #[doc = " @brief Set the align to stream profile for the align filter.\n @brief It is useful when the align target stream dose not started (without any frame to get intrinsics and extrinsics).\n\n @param filter A filter object.\n @param align_to_stream_profile The align target stream profile.\n @param error Pointer to an error object that will be set if an error occurs."]
    pub fn ob_align_filter_set_align_to_stream_profile(
        filter: *mut ob_filter,
        align_to_stream_profile: *const ob_stream_profile,
        error: *mut *mut ob_error,
    );
}
unsafe extern "C" {
    #[doc = " @brief Crate a frame object based on the specified parameters.\n\n @attention The frame object is created with a reference count of 1, and the reference count should be decreased by calling @ref ob_delete_frame() when it is\n no longer needed.\n\n @param frame_type The frame object type.\n @param format The frame object format.\n @param data_size The size of the frame object data.\n @param error Pointer to an error object that will be set if an error occurs.\n @return ob_frame* Return the frame object."]
    pub fn ob_create_frame(
        frame_type: ob_frame_type,
        format: ob_format,
        data_size: u32,
        error: *mut *mut ob_error,
    ) -> *mut ob_frame;
}
unsafe extern "C" {
    #[doc = " @brief Create (clone) a frame object based on the specified other frame object.\n @brief The new frame object will have the same properties as the other frame object, but the data buffer is newly allocated.\n\n @attention The frame object is created with a reference count of 1, and the reference count should be decreased by calling @ref ob_delete_frame() when it is\n no longer needed.\n\n @param[in] other_frame The frame object to create the new frame object according to.\n @param[in] should_copy_data If true, the data of the source frame object will be copied to the new frame object. If false, the new frame object will\n have a data buffer with random data.\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return ob_frame* Return the new frame object."]
    pub fn ob_create_frame_from_other_frame(
        other_frame: *const ob_frame,
        should_copy_data: bool,
        error: *mut *mut ob_error,
    ) -> *mut ob_frame;
}
unsafe extern "C" {
    #[doc = " @brief Create a frame object according to the specified stream profile.\n\n @attention The frame object is created with a reference count of 1, and the reference count should be decreased by calling @ref ob_delete_frame() when it is\n no logger needed.\n\n @param stream_profile The stream profile to create the new frame object according to.\n @param error Pointer to an error object that will be set if an error occurs.\n @return ob_frame* Return the new frame object."]
    pub fn ob_create_frame_from_stream_profile(
        stream_profile: *const ob_stream_profile,
        error: *mut *mut ob_error,
    ) -> *mut ob_frame;
}
unsafe extern "C" {
    #[doc = " @brief Create an video frame object based on the specified parameters.\n\n @attention The frame object is created with a reference count of 1, and the reference count should be decreased by calling @ref ob_delete_frame() when it is\n no longer needed.\n\n @param[in] frame_type Frame object type.\n @param[in] format Frame object format.\n @param[in] width Frame object width.\n @param[in] height Frame object height.\n @param[in] stride_bytes Row span in bytes. If 0, the stride is calculated based on the width and format.\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return ob_frame* Return an empty frame object."]
    pub fn ob_create_video_frame(
        frame_type: ob_frame_type,
        format: ob_format,
        width: u32,
        height: u32,
        stride_bytes: u32,
        error: *mut *mut ob_error,
    ) -> *mut ob_frame;
}
unsafe extern "C" {
    #[doc = " @brief Create a frame object based on an externally created buffer.\n\n @attention The buffer is owned by the user and will not be destroyed by the frame object. The user should ensure that the buffer is valid and not modified.\n @attention The frame object is created with a reference count of 1, and the reference count should be decreased by calling @ref ob_delete_frame() when it is\n no longer needed.\n\n @param[in] frame_type Frame object type.\n @param[in] format Frame object format.\n @param[in] buffer Frame object buffer.\n @param[in] buffer_size Frame object buffer size.\n @param[in] buffer_destroy_cb Destroy callback, will be called when the frame object is destroyed.\n @param[in] buffer_destroy_context Destroy context, user-defined context to be passed to the destroy callback.\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return ob_frame* Return the frame object."]
    pub fn ob_create_frame_from_buffer(
        frame_type: ob_frame_type,
        format: ob_format,
        buffer: *mut u8,
        buffer_size: u32,
        buffer_destroy_cb: ob_frame_destroy_callback,
        buffer_destroy_context: *mut ::std::os::raw::c_void,
        error: *mut *mut ob_error,
    ) -> *mut ob_frame;
}
unsafe extern "C" {
    #[doc = " @brief Create a video frame object based on an externally created buffer.\n\n @attention The buffer is owned by the user and will not be destroyed by the frame object. The user should ensure that the buffer is valid and not modified.\n @attention The frame object is created with a reference count of 1, and the reference count should be decreased by calling @ref ob_delete_frame() when it is\n no longer needed.\n\n @param[in] frame_type Frame object type.\n @param[in] format Frame object format.\n @param[in] width Frame object width.\n @param[in] height Frame object height.\n @param[in] stride_bytes Row span in bytes. If 0, the stride is calculated based on the width and format.\n @param[in] buffer Frame object buffer.\n @param[in] buffer_size Frame object buffer size.\n @param[in] buffer_destroy_cb Destroy callback, user-defined function to destroy the buffer.\n @param[in] buffer_destroy_context Destroy context, user-defined context to be passed to the destroy callback.\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return ob_frame* Return the frame object."]
    pub fn ob_create_video_frame_from_buffer(
        frame_type: ob_frame_type,
        format: ob_format,
        width: u32,
        height: u32,
        stride_bytes: u32,
        buffer: *mut u8,
        buffer_size: u32,
        buffer_destroy_cb: ob_frame_destroy_callback,
        buffer_destroy_context: *mut ::std::os::raw::c_void,
        error: *mut *mut ob_error,
    ) -> *mut ob_frame;
}
unsafe extern "C" {
    #[doc = " @brief Create an empty frameset object.\n @brief A frameset object is a special type of frame object that can be used to store multiple frames.\n\n @attention The frameset object is created with a reference count of 1, and the reference count should be decreased by calling @ref ob_delete_frame() when it\n is no longer needed.\n\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return ob_frame* Return the frameset object."]
    pub fn ob_create_frameset(error: *mut *mut ob_error) -> *mut ob_frame;
}
unsafe extern "C" {
    #[doc = " @brief Increase the reference count of a frame object.\n @brief The reference count is used to manage the lifetime of the frame object.\n\n @attention When calling this function, the reference count of the frame object is\n increased and requires to be decreased by calling @ref ob_delete_frame().\n\n @param[in] frame Frame object to increase the reference count.\n @param[out] error Pointer to an error object that will be set if an error occurs."]
    pub fn ob_frame_add_ref(frame: *const ob_frame, error: *mut *mut ob_error);
}
unsafe extern "C" {
    #[doc = " @brief Delete a frame object\n @brief This function will decrease the reference count of the frame object and release the memory if the reference count becomes 0.\n\n @param[in] frame The frame object to delete.\n @param[out] error Pointer to an error object that will be set if an error occurs."]
    pub fn ob_delete_frame(frame: *const ob_frame, error: *mut *mut ob_error);
}
unsafe extern "C" {
    #[doc = " @brief Copy the information of the source frame object to the destination frame object.\n @brief Including the index, timestamp, system timestamp, global timestamp and metadata will be copied.\n\n @param[in] src_frame Source frame object to copy the information from.\n @param[in] dst_frame Destination frame object to copy the information to.\n @param[out] error Pointer to an error object that will be set if an error occurs."]
    pub fn ob_frame_copy_info(
        src_frame: *const ob_frame,
        dst_frame: *mut ob_frame,
        error: *mut *mut ob_error,
    );
}
unsafe extern "C" {
    #[doc = " @brief Get the frame index\n\n @param[in] frame Frame object\n @param[out] error Log wrong message\n @return uint64_t return the frame index"]
    pub fn ob_frame_get_index(frame: *const ob_frame, error: *mut *mut ob_error) -> u64;
}
unsafe extern "C" {
    #[doc = " @brief Get the frame format\n\n @param[in] frame Frame object\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return ob_format return the frame format"]
    pub fn ob_frame_get_format(frame: *const ob_frame, error: *mut *mut ob_error) -> ob_format;
}
unsafe extern "C" {
    #[doc = " @brief Get the frame type\n\n @param[in] frame Frame object\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return ob_frame_type return the frame type"]
    pub fn ob_frame_get_type(frame: *const ob_frame, error: *mut *mut ob_error) -> ob_frame_type;
}
unsafe extern "C" {
    #[doc = " @brief Get the frame timestamp (also known as device timestamp, hardware timestamp) of the frame in microseconds.\n @brief The hardware timestamp is the time point when the frame was captured by the device (Typically in the mid-exposure, unless otherwise stated), on device\n clock domain.\n\n @param[in] frame Frame object\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return uint64_t return the frame hardware timestamp in microseconds"]
    pub fn ob_frame_get_timestamp_us(frame: *const ob_frame, error: *mut *mut ob_error) -> u64;
}
unsafe extern "C" {
    #[doc = " @brief Set the frame timestamp (also known as the device timestamp, hardware timestamp) of a frame object.\n\n @param[in] frame Frame object to set the timestamp.\n @param[in] timestamp_us frame timestamp to set in microseconds.\n @param[out] error Pointer to an error object that will be set if an error occurs."]
    pub fn ob_frame_set_timestamp_us(
        frame: *mut ob_frame,
        timestamp_us: u64,
        error: *mut *mut ob_error,
    );
}
unsafe extern "C" {
    #[doc = " @brief Get the system timestamp of the frame in microseconds.\n @brief The system timestamp is the time point when the frame was received by the host, on host clock domain.\n\n @param[in] frame Frame object\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return uint64_t return the frame system timestamp in microseconds"]
    pub fn ob_frame_get_system_timestamp_us(
        frame: *const ob_frame,
        error: *mut *mut ob_error,
    ) -> u64;
}
unsafe extern "C" {
    #[doc = " @brief Set the system timestamp of the frame in microseconds.\n\n @param frame Frame object\n @param system_timestamp_us frame system timestamp to set in microseconds.\n @param error Pointer to an error object that will be set if an error occurs."]
    pub fn ob_frame_set_system_timestamp_us(
        frame: *mut ob_frame,
        system_timestamp_us: u64,
        error: *mut *mut ob_error,
    );
}
unsafe extern "C" {
    #[doc = " @brief Get the global timestamp of the frame in microseconds.\n @brief The global timestamp is the time point when the frame was captured by the device, and has been converted to the host clock domain. The\n conversion process base on the frame timestamp and can eliminate the timer drift of the device\n\n @attention The global timestamp is disabled by default. If global timestamp is not enabled, the function will return 0. To enable it, call @ref\n ob_device_enable_global_timestamp() function.\n @attention Only some models of device support getting the global timestamp.  Check the device support status by @ref\n ob_device_is_global_timestamp_supported() function.\n\n @param[in] frame Frame object\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return uint64_t The global timestamp of the frame in microseconds."]
    pub fn ob_frame_get_global_timestamp_us(
        frame: *const ob_frame,
        error: *mut *mut ob_error,
    ) -> u64;
}
unsafe extern "C" {
    #[doc = " @brief Get the data buffer of a frame.\n\n @attention The returned data buffer is mutable, but it is not recommended to modify it directly. Modifying the data directly may cause issues if the frame is\n being used in other threads  or future use. If you need to modify the data, it is recommended to create a new frame object.\n\n @param[in] frame The frame object from which to retrieve the data.\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return uint8_t* Pointer to the frame data buffer."]
    pub fn ob_frame_get_data(frame: *const ob_frame, error: *mut *mut ob_error) -> *mut u8;
}
unsafe extern "C" {
    #[doc = " @brief Update the data of a frame.\n @brief The data will be memcpy to the frame data buffer.\n @brief The frame data size will be also updated as the input data size.\n\n @attention It is not recommended to update the frame data if the frame was not created by the user. If you must update it, ensure that the frame is not being\n used in other threads.\n @attention The size of the new data should be equal to or less than the current data size of the frame. Exceeding the original size may cause memory\n exceptions.\n\n @param[in] frame The frame object to update.\n @param[in] data The new data to update the frame with.\n @param[in] data_size The size of the new data.\n @param[out] error Pointer to an error object that will be set if an error occurs."]
    pub fn ob_frame_update_data(
        frame: *mut ob_frame,
        data: *const u8,
        data_size: u32,
        error: *mut *mut ob_error,
    );
}
unsafe extern "C" {
    #[doc = " @brief Get the frame data size\n\n @param[in] frame Frame object\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return uint32_t return the frame data size\n If it is point cloud data, it return the number of bytes occupied by all point sets. If you need to find the number of points, you need to divide dataSize\n by the structure size of the corresponding point type."]
    pub fn ob_frame_get_data_size(frame: *const ob_frame, error: *mut *mut ob_error) -> u32;
}
unsafe extern "C" {
    #[doc = " @brief Get the metadata of the frame\n\n @attention The returned metadata is mutable, but it is not recommended to modify it directly. Modifying the metadata directly may cause issues if the frame\n is being used in other threads or future use. If you need to modify the metadata, it is recommended to create a new frame object.\n\n @param[in] frame frame object\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return const uint8_t * return the metadata pointer of the frame"]
    pub fn ob_frame_get_metadata(frame: *const ob_frame, error: *mut *mut ob_error) -> *mut u8;
}
unsafe extern "C" {
    #[doc = " @brief Get the metadata size of the frame\n\n @param[in] frame frame object\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return uint32_t return the metadata size of the frame"]
    pub fn ob_frame_get_metadata_size(frame: *const ob_frame, error: *mut *mut ob_error) -> u32;
}
unsafe extern "C" {
    #[doc = " @brief Update the metadata of the frame\n @brief The metadata will be memcpy to the frame metadata buffer.\n @brief The frame metadata size will be also updated as the input metadata size.\n\n @attention It is not recommended to update the frame metadata if the frame was not created by the user. If you must update it, ensure that the frame is not\n being used in other threads or future use.\n @attention The metadata size should be equal to or less than 256 bytes, otherwise it will cause memory exception.\n\n @param[in] frame frame object\n @param[in] metadata The new metadata to update.\n @param[in] metadata_size The size of the new metadata.\n @param[out] error Pointer to an error object that will be set if an error occurs."]
    pub fn ob_frame_update_metadata(
        frame: *mut ob_frame,
        metadata: *const u8,
        metadata_size: u32,
        error: *mut *mut ob_error,
    );
}
unsafe extern "C" {
    #[doc = " @brief check if the frame contains the specified metadata\n\n @param[in] frame frame object\n @param[in] type metadata type, refer to @ref ob_frame_metadata_type\n @param[out] error Pointer to an error object that will be set if an error occurs."]
    pub fn ob_frame_has_metadata(
        frame: *const ob_frame,
        type_: ob_frame_metadata_type,
        error: *mut *mut ob_error,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " @brief Get the metadata value of the frame\n\n @param[in] frame frame object\n @param[in] type metadata type, refer to @ref ob_frame_metadata_type\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return int64_t return the metadata value of the frame"]
    pub fn ob_frame_get_metadata_value(
        frame: *const ob_frame,
        type_: ob_frame_metadata_type,
        error: *mut *mut ob_error,
    ) -> i64;
}
unsafe extern "C" {
    #[doc = " @brief Get the stream profile of the frame\n\n @attention Require @ref ob_delete_stream_profile() to release the return stream profile.\n\n @param frame frame object\n @param error Pointer to an error object that will be set if an error occurs.\n @return ob_stream_profile* Return the stream profile of the frame, if the frame is not captured by a sensor stream, it will return NULL"]
    pub fn ob_frame_get_stream_profile(
        frame: *const ob_frame,
        error: *mut *mut ob_error,
    ) -> *mut ob_stream_profile;
}
unsafe extern "C" {
    #[doc = " @brief Set (override) the stream profile of the frame\n\n @param frame frame object\n @param stream_profile The stream profile to set for the frame.\n @param error Pointer to an error object that will be set if an error occurs."]
    pub fn ob_frame_set_stream_profile(
        frame: *mut ob_frame,
        stream_profile: *const ob_stream_profile,
        error: *mut *mut ob_error,
    );
}
unsafe extern "C" {
    #[doc = " @brief Get the sensor of the frame\n\n @attention Require @ref ob_delete_sensor() to release the return sensor.\n\n @param[in] frame frame object\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return ob_sensor* return the sensor of the frame, if the frame is not captured by a sensor or the sensor stream has been destroyed, it will return NULL"]
    pub fn ob_frame_get_sensor(frame: *const ob_frame, error: *mut *mut ob_error)
        -> *mut ob_sensor;
}
unsafe extern "C" {
    #[doc = " @brief Get the device of the frame\n\n @attention Require @ref ob_delete_device() to release the return device.\n\n @param frame frame object\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return ob_device* return the device of the frame, if the frame is not captured by a sensor stream or the device has been destroyed, it will return NULL"]
    pub fn ob_frame_get_device(frame: *const ob_frame, error: *mut *mut ob_error)
        -> *mut ob_device;
}
unsafe extern "C" {
    #[doc = " @brief Get video frame width\n\n @param[in] frame Frame object\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return uint32_t return the frame width"]
    pub fn ob_video_frame_get_width(frame: *const ob_frame, error: *mut *mut ob_error) -> u32;
}
unsafe extern "C" {
    #[doc = " @brief Get video frame height\n\n @param[in] frame Frame object\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return uint32_t return the frame height"]
    pub fn ob_video_frame_get_height(frame: *const ob_frame, error: *mut *mut ob_error) -> u32;
}
unsafe extern "C" {
    #[doc = " @brief Get video frame pixel format\n @brief Usually used to determine the pixel type of depth frame (depth, disparity, raw phase, etc.)\n\n @attention Always return OB_PIXEL_UNKNOWN for non-depth frame currently if user has not set the pixel type by @ref ob_video_frame_set_pixel_type()\n\n @param frame Frame object\n @param error Pointer to an error object that will be set if an error occurs.\n @return ob_pixel_type return the pixel format of the frame."]
    pub fn ob_video_frame_get_pixel_type(
        frame: *const ob_frame,
        error: *mut *mut ob_error,
    ) -> ob_pixel_type;
}
unsafe extern "C" {
    #[doc = " @brief Set video frame pixel format\n\n @param frame Frame object\n @param pixel_type the pixel format of the frame\n @param error Pointer to an error object that will be set if an error occurs."]
    pub fn ob_video_frame_set_pixel_type(
        frame: *mut ob_frame,
        pixel_type: ob_pixel_type,
        error: *mut *mut ob_error,
    );
}
unsafe extern "C" {
    #[doc = " @brief Get the effective number of pixels (such as Y16 format frame, but only the lower 10 bits are effective bits, and the upper 6 bits are filled with 0)\n @attention Only valid for Y8/Y10/Y11/Y12/Y14/Y16 format\n\n @param[in] frame video frame object\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return uint8_t return the effective number of pixels in the pixel, or 0 if it is an unsupported format"]
    pub fn ob_video_frame_get_pixel_available_bit_size(
        frame: *const ob_frame,
        error: *mut *mut ob_error,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = " @brief Set the effective number of pixels (such as Y16 format frame, but only the lower 10 bits are effective bits, and the upper 6 bits are filled with 0)\n @attention Only valid for Y8/Y10/Y11/Y12/Y14/Y16 format\n\n @param[in] frame video frame object\n @param[in] bit_size the effective number of pixels in the pixel, or 0 if it is an unsupported format\n @param[out] error Pointer to an error object that will be set if an error occurs."]
    pub fn ob_video_frame_set_pixel_available_bit_size(
        frame: *mut ob_frame,
        bit_size: u8,
        error: *mut *mut ob_error,
    );
}
unsafe extern "C" {
    #[doc = " @brief Get the source sensor type of the ir frame (left or right for dual camera)\n\n @param frame Frame object\n @param ob_error Pointer to an error object that will be set if an error occurs.\n @return ob_sensor_type return the source sensor type of the ir frame"]
    pub fn ob_ir_frame_get_source_sensor_type(
        frame: *const ob_frame,
        ob_error: *mut *mut ob_error,
    ) -> ob_sensor_type;
}
unsafe extern "C" {
    #[doc = " @brief Get the value scale of the depth frame. The pixel value of the depth frame is multiplied by the scale to give a depth value in millimeters.\n For example, if valueScale=0.1 and a certain coordinate pixel value is pixelValue=10000, then the depth value = pixelValue*valueScale = 10000*0.1=1000mm.\n\n @param[in] frame Frame object\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return float The value scale of the depth frame"]
    pub fn ob_depth_frame_get_value_scale(frame: *const ob_frame, error: *mut *mut ob_error)
        -> f32;
}
unsafe extern "C" {
    #[doc = " @brief Set the value scale of the depth frame. The pixel value of the depth frame is multiplied by the scale to give a depth value in millimeters.\n For example, if valueScale=0.1 and a certain coordinate pixel value is pixelValue=10000, then the depth value = pixelValue*valueScale = 10000*0.1=1000mm.\n\n @param[in] frame Frame object\n @param[in] value_scale The value scale of the depth frame\n @param[out] error Pointer to an error object that will be set if an error occurs."]
    pub fn ob_depth_frame_set_value_scale(
        frame: *mut ob_frame,
        value_scale: f32,
        error: *mut *mut ob_error,
    );
}
unsafe extern "C" {
    #[doc = " @brief Get the point coordinate value scale of the points frame. The point position value of the points frame is multiplied by the scale to give a position\n value in millimeters. For example, if scale=0.1, the x-coordinate value of a point is x = 10000, which means that the actual x-coordinate value = x*scale =\n 10000*0.1 = 1000mm.\n\n @param[in] frame Frame object\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return float The coordinate value scale of the points frame"]
    pub fn ob_points_frame_get_coordinate_value_scale(
        frame: *const ob_frame,
        error: *mut *mut ob_error,
    ) -> f32;
}
unsafe extern "C" {
    #[doc = " @brief Get accelerometer frame data.\n\n @param[in] frame Accelerometer frame.\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return ob_accel_value Return the accelerometer data."]
    pub fn ob_accel_frame_get_value(
        frame: *const ob_frame,
        error: *mut *mut ob_error,
    ) -> ob_accel_value;
}
unsafe extern "C" {
    #[doc = " @brief Get the temperature when acquiring the accelerometer frame.\n\n @param[in] frame Accelerometer frame.\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return float Return the temperature value."]
    pub fn ob_accel_frame_get_temperature(frame: *const ob_frame, error: *mut *mut ob_error)
        -> f32;
}
unsafe extern "C" {
    #[doc = " @brief Get gyroscope frame data.\n\n @param[in] frame Gyroscope frame.\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return ob_gyro_value Return the gyroscope data."]
    pub fn ob_gyro_frame_get_value(
        frame: *const ob_frame,
        error: *mut *mut ob_error,
    ) -> ob_gyro_value;
}
unsafe extern "C" {
    #[doc = " @brief Get the temperature when acquiring the gyroscope frame.\n\n @param[in] frame Gyroscope frame.\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return float Return the temperature value."]
    pub fn ob_gyro_frame_get_temperature(frame: *const ob_frame, error: *mut *mut ob_error) -> f32;
}
unsafe extern "C" {
    #[doc = " @brief Get the number of frames contained in the frameset\n\n @attention The frame returned by this function should call @ref ob_delete_frame() to decrease the reference count when it is no longer needed.\n\n @param[in] frameset frameset object\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return uint32_t return the number of frames"]
    pub fn ob_frameset_get_count(frameset: *const ob_frame, error: *mut *mut ob_error) -> u32;
}
unsafe extern "C" {
    #[doc = " @brief Get the depth frame from the frameset.\n\n @attention The frame returned by this function should call @ref ob_delete_frame() to decrease the reference count when it is no longer needed.\n\n @param[in] frameset Frameset object.\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return ob_frame* Return the depth frame."]
    pub fn ob_frameset_get_depth_frame(
        frameset: *const ob_frame,
        error: *mut *mut ob_error,
    ) -> *mut ob_frame;
}
unsafe extern "C" {
    #[doc = " @brief Get the color frame from the frameset.\n\n @attention The frame returned by this function should call @ref ob_delete_frame() to decrease the reference count when it is no longer needed.\n\n @param[in] frameset Frameset object.\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return ob_frame* Return the color frame."]
    pub fn ob_frameset_get_color_frame(
        frameset: *const ob_frame,
        error: *mut *mut ob_error,
    ) -> *mut ob_frame;
}
unsafe extern "C" {
    #[doc = " @brief Get the infrared frame from the frameset.\n\n @attention The frame returned by this function should call @ref ob_delete_frame() to decrease the reference count when it is no longer needed.\n\n @param[in] frameset Frameset object.\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return ob_frame* Return the infrared frame."]
    pub fn ob_frameset_get_ir_frame(
        frameset: *const ob_frame,
        error: *mut *mut ob_error,
    ) -> *mut ob_frame;
}
unsafe extern "C" {
    #[doc = " @brief Get point cloud frame from the frameset.\n\n @attention The frame returned by this function should call @ref ob_delete_frame() to decrease the reference count when it is no longer needed.\n\n @param[in] frameset Frameset object.\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return ob_frame* Return the point cloud frame."]
    pub fn ob_frameset_get_points_frame(
        frameset: *const ob_frame,
        error: *mut *mut ob_error,
    ) -> *mut ob_frame;
}
unsafe extern "C" {
    #[doc = " @brief Get a frame of a specific type from the frameset.\n\n @attention The frame returned by this function should call @ref ob_delete_frame() to decrease the reference count when it is no longer needed.\n\n @param[in] frameset Frameset object.\n @param[in] frame_type Frame type.\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return ob_frame* Return the frame of the specified type, or nullptr if it does not exist."]
    pub fn ob_frameset_get_frame(
        frameset: *const ob_frame,
        frame_type: ob_frame_type,
        error: *mut *mut ob_error,
    ) -> *mut ob_frame;
}
unsafe extern "C" {
    #[doc = " @brief Get a frame at a specific index from the FrameSet\n\n @param[in] frameset Frameset object.\n @param[in] index The index of the frame.\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return ob_frame* Return the frame at the specified index, or nullptr if it does not exist."]
    pub fn ob_frameset_get_frame_by_index(
        frameset: *const ob_frame,
        index: u32,
        error: *mut *mut ob_error,
    ) -> *mut ob_frame;
}
unsafe extern "C" {
    #[doc = " @brief Push a frame to the frameset\n\n @attention If a frame with same type already exists in the frameset, it will be replaced by the new frame.\n @attention The frame push to the frameset will be add reference count, so you still need to call @ref ob_delete_frame() to decrease the reference count when\n it is no longer needed.\n\n @param[in] frameset Frameset object.\n @param[in] frame Frame object to push.\n @param[out] error Pointer to an error object that will be set if an error occurs."]
    pub fn ob_frameset_push_frame(
        frameset: *mut ob_frame,
        frame: *const ob_frame,
        error: *mut *mut ob_error,
    );
}
unsafe extern "C" {
    #[doc = " @brief Get point cloud frame width\n\n @param[in] frame point cloud Frame object\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return uint32_t return the point cloud frame width"]
    pub fn ob_point_cloud_frame_get_width(frame: *const ob_frame, error: *mut *mut ob_error)
        -> u32;
}
unsafe extern "C" {
    #[doc = " @brief Get point cloud frame height\n\n @param[in] frame point cloud Frame object\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return uint32_t return the point cloud frame height"]
    pub fn ob_point_cloud_frame_get_height(
        frame: *const ob_frame,
        error: *mut *mut ob_error,
    ) -> u32;
}
unsafe extern "C" {
    #[doc = " @brief Create a pipeline object\n\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return ob_pipeline* return the pipeline object"]
    pub fn ob_create_pipeline(error: *mut *mut ob_error) -> *mut ob_pipeline;
}
unsafe extern "C" {
    #[doc = " @brief Using device objects to create pipeline objects\n\n @param[in] dev Device object used to create pipeline\n @param[out] error  Pointer to an error object that will be set if an error occurs.\n @return ob_pipeline* return the pipeline object"]
    pub fn ob_create_pipeline_with_device(
        dev: *const ob_device,
        error: *mut *mut ob_error,
    ) -> *mut ob_pipeline;
}
unsafe extern "C" {
    #[doc = " @brief Delete pipeline objects\n\n @param[in] pipeline  The pipeline object to be deleted\n @param[out] error Pointer to an error object that will be set if an error occurs."]
    pub fn ob_delete_pipeline(pipeline: *mut ob_pipeline, error: *mut *mut ob_error);
}
unsafe extern "C" {
    #[doc = " @brief Start the pipeline with default parameters\n\n @param[in] pipeline  pipeline object\n @param[out] error Pointer to an error object that will be set if an error occurs."]
    pub fn ob_pipeline_start(pipeline: *mut ob_pipeline, error: *mut *mut ob_error);
}
unsafe extern "C" {
    #[doc = " @brief Start the pipeline with configuration parameters\n\n @param[in] pipeline  pipeline object\n @param[in] config Parameters to be configured\n @param[out] error Pointer to an error object that will be set if an error occurs."]
    pub fn ob_pipeline_start_with_config(
        pipeline: *mut ob_pipeline,
        config: *const ob_config,
        error: *mut *mut ob_error,
    );
}
unsafe extern "C" {
    #[doc = " @brief Start the pipeline and set the frame collection data callback\n\n @attention After start the pipeline with this interface, the frames will be output to the callback function and cannot be obtained frames by call\n @ob_pipeline_wait_for_frameset\n\n @param[in] pipeline pipeline object\n @param[in] config  Parameters to be configured\n @param[in] callback Trigger a callback when all frame data in the frameset arrives\n @param[in] user_data  Pass in any user data and get it from the callback\n @param[out] error  Pointer to an error object that will be set if an error occurs."]
    pub fn ob_pipeline_start_with_callback(
        pipeline: *mut ob_pipeline,
        config: *const ob_config,
        callback: ob_frameset_callback,
        user_data: *mut ::std::os::raw::c_void,
        error: *mut *mut ob_error,
    );
}
unsafe extern "C" {
    #[doc = " @brief Stop pipeline\n\n @param[in] pipeline pipeline object\n @param[out] error  Pointer to an error object that will be set if an error occurs."]
    pub fn ob_pipeline_stop(pipeline: *mut ob_pipeline, error: *mut *mut ob_error);
}
unsafe extern "C" {
    #[doc = " @brief Get the configuration object associated with the pipeline\n @brief Returns default configuration if the user has not configured\n\n @param[in] pipeline The pipeline object\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return ob_config* The configuration object"]
    pub fn ob_pipeline_get_config(
        pipeline: *const ob_pipeline,
        error: *mut *mut ob_error,
    ) -> *mut ob_config;
}
unsafe extern "C" {
    #[doc = " @brief Switch the corresponding configuration\n\n @param[in] pipeline The pipeline object\n @param[in] config The pipeline configuration\n @param[out] error Log error messages"]
    pub fn ob_pipeline_switch_config(
        pipeline: *mut ob_pipeline,
        config: *mut ob_config,
        error: *mut *mut ob_error,
    );
}
unsafe extern "C" {
    #[doc = " @brief Wait for a set of frames to be returned synchronously\n\n @param[in] pipeline The pipeline object\n @param[in] timeout_ms The timeout for waiting (in milliseconds)\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return ob_frame* The frameset that was waited for. A frameset is a special frame that can be used to obtain independent frames from the set."]
    pub fn ob_pipeline_wait_for_frameset(
        pipeline: *mut ob_pipeline,
        timeout_ms: u32,
        error: *mut *mut ob_error,
    ) -> *mut ob_frame;
}
unsafe extern "C" {
    #[doc = " @brief Get the device object associated with the pipeline\n\n @param[in] pipeline The pipeline object\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return ob_device* The device object"]
    pub fn ob_pipeline_get_device(
        pipeline: *const ob_pipeline,
        error: *mut *mut ob_error,
    ) -> *mut ob_device;
}
unsafe extern "C" {
    #[doc = " @brief Get the stream profile list associated with the pipeline\n\n @param[in] pipeline The pipeline object\n @param[in] sensorType The sensor type. The supported sensor types can be obtained through the ob_device_get_sensor_list() interface.\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return ob_stream_profile_list* The stream profile list"]
    pub fn ob_pipeline_get_stream_profile_list(
        pipeline: *const ob_pipeline,
        sensorType: ob_sensor_type,
        error: *mut *mut ob_error,
    ) -> *mut ob_stream_profile_list;
}
unsafe extern "C" {
    #[doc = " @brief Enable frame synchronization\n @brief Synchronize the frames of different streams by using the timestamp information of the frames.\n @brief Dynamically (when pipeline is started) enable/disable frame synchronization is allowed.\n\n @param[in] pipeline The pipeline object\n @param[out] error Pointer to an error object that will be set if an error occurs."]
    pub fn ob_pipeline_enable_frame_sync(pipeline: *mut ob_pipeline, error: *mut *mut ob_error);
}
unsafe extern "C" {
    #[doc = " @brief Disable frame synchronization\n\n @param[in] pipeline The pipeline object\n @param[out] error Pointer to an error object that will be set if an error occurs."]
    pub fn ob_pipeline_disable_frame_sync(pipeline: *mut ob_pipeline, error: *mut *mut ob_error);
}
unsafe extern "C" {
    #[doc = " @brief Return a list of D2C-enabled depth sensor resolutions corresponding to the input color sensor resolution\n\n @param[in] pipeline The pipeline object\n @param[in] color_profile The input profile of the color sensor\n @param[in] align_mode The input align mode\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return ob_stream_profile_list* The list of D2C-enabled depth sensor resolutions"]
    pub fn ob_get_d2c_depth_profile_list(
        pipeline: *const ob_pipeline,
        color_profile: *const ob_stream_profile,
        align_mode: ob_align_mode,
        error: *mut *mut ob_error,
    ) -> *mut ob_stream_profile_list;
}
unsafe extern "C" {
    #[doc = " @brief Create the pipeline configuration\n\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return ob_config* The configuration object"]
    pub fn ob_create_config(error: *mut *mut ob_error) -> *mut ob_config;
}
unsafe extern "C" {
    #[doc = " @brief Delete the pipeline configuration\n\n @param[in] config The configuration to be deleted\n @param[out] error Pointer to an error object that will be set if an error occurs."]
    pub fn ob_delete_config(config: *mut ob_config, error: *mut *mut ob_error);
}
unsafe extern "C" {
    #[doc = " @brief Enable a stream with default profile\n\n @param[in] config The pipeline configuration object\n @param[in] stream_type The type of the stream to be enabled\n @param[out] error Pointer to an error object that will be set if an error occurs."]
    pub fn ob_config_enable_stream(
        config: *mut ob_config,
        stream_type: ob_stream_type,
        error: *mut *mut ob_error,
    );
}
unsafe extern "C" {
    #[doc = " @brief Enable all streams in the pipeline configuration\n\n @param[in] config The pipeline configuration\n @param[out] error Log error messages"]
    pub fn ob_config_enable_all_stream(config: *mut ob_config, error: *mut *mut ob_error);
}
unsafe extern "C" {
    #[doc = " @brief Enable a stream according to the stream profile\n\n @param[in] config The pipeline configuration object\n @param[in] profile The stream profile to be enabled\n @param[out] error Pointer to an error object that will be set if an error occurs."]
    pub fn ob_config_enable_stream_with_stream_profile(
        config: *mut ob_config,
        profile: *const ob_stream_profile,
        error: *mut *mut ob_error,
    );
}
unsafe extern "C" {
    #[doc = " @brief Enable video stream with specified parameters\n\n @attention The stream_type should be a video stream type, such as OB_STREAM_IR, OB_STREAM_COLOR, OB_STREAM_DEPTH, etc.\n\n @param[in] config The pipeline configuration object\n @param[in] stream_type The type of the stream to be enabled\n @param[in] width The width of the video stream\n @param[in] height The height of the video stream\n @param[in] fps The frame rate of the video stream\n @param[in] format The format of the video stream\n @param[out] error Pointer to an error object that will be set if an error occurs."]
    pub fn ob_config_enable_video_stream(
        config: *mut ob_config,
        stream_type: ob_stream_type,
        width: u32,
        height: u32,
        fps: u32,
        format: ob_format,
        error: *mut *mut ob_error,
    );
}
unsafe extern "C" {
    #[doc = " @brief Enable accelerometer stream with specified parameters\n\n @param[in] config The pipeline configuration object\n @param[in] full_scale_range The full scale range of the accelerometer\n @param[in] sample_rate The sample rate of the accelerometer\n @param[out] error Pointer to an error object that will be set if an error occurs."]
    pub fn ob_config_enable_accel_stream(
        config: *mut ob_config,
        full_scale_range: ob_accel_full_scale_range,
        sample_rate: ob_accel_sample_rate,
        error: *mut *mut ob_error,
    );
}
unsafe extern "C" {
    #[doc = " @brief Enable gyroscope stream with specified parameters\n\n @param[in] config The pipeline configuration object\n @param[in] full_scale_range The full scale range of the gyroscope\n @param[in] sample_rate The sample rate of the gyroscope\n @param[out] error Pointer to an error object that will be set if an error occurs."]
    pub fn ob_config_enable_gyro_stream(
        config: *mut ob_config,
        full_scale_range: ob_gyro_full_scale_range,
        sample_rate: ob_gyro_sample_rate,
        error: *mut *mut ob_error,
    );
}
unsafe extern "C" {
    #[doc = " @brief  Get the enabled stream profile list in the pipeline configuration\n\n @param config The pipeline configuration object\n @param error Pointer to an error object that will be set if an error occurs.\n @return ob_stream_profile_list* The enabled stream profile list, should be released by @ref ob_delete_stream_profile_list after use"]
    pub fn ob_config_get_enabled_stream_profile_list(
        config: *const ob_config,
        error: *mut *mut ob_error,
    ) -> *mut ob_stream_profile_list;
}
unsafe extern "C" {
    #[doc = " @brief Disable a specific stream in the pipeline configuration\n\n @param[in] config The pipeline configuration object\n @param[in] type The type of stream to be disabled\n @param[out] error Pointer to an error object that will be set if an error occurs."]
    pub fn ob_config_disable_stream(
        config: *mut ob_config,
        type_: ob_stream_type,
        error: *mut *mut ob_error,
    );
}
unsafe extern "C" {
    #[doc = " @brief Disable all streams in the pipeline configuration\n\n @param[in] config The pipeline configuration object\n @param[out] error Pointer to an error object that will be set if an error occurs."]
    pub fn ob_config_disable_all_stream(config: *mut ob_config, error: *mut *mut ob_error);
}
unsafe extern "C" {
    #[doc = " @brief Set the alignment mode for the pipeline configuration\n\n @param[in] config The pipeline configuration object\n @param[in] mode The alignment mode to be set\n @param[out] error Pointer to an error object that will be set if an error occurs."]
    pub fn ob_config_set_align_mode(
        config: *mut ob_config,
        mode: ob_align_mode,
        error: *mut *mut ob_error,
    );
}
unsafe extern "C" {
    #[doc = " @brief Set whether depth scaling is required after enable depth to color alignment\n @brief After enabling depth to color alignment, the depth image may need to be scaled to match the color image size.\n\n @param[in] config The pipeline configuration object\n @param[in] enable Whether scaling is required\n @param[out] error Pointer to an error object that will be set if an error occurs."]
    pub fn ob_config_set_depth_scale_after_align_require(
        config: *mut ob_config,
        enable: bool,
        error: *mut *mut ob_error,
    );
}
unsafe extern "C" {
    #[doc = " @brief Set the frame aggregation output mode for the pipeline configuration\n @brief The processing strategy when the FrameSet generated by the frame aggregation function does not contain the frames of all opened streams (which\n can be caused by different frame rates of each stream, or by the loss of frames of one stream): drop directly or output to the user.\n\n @param[in] config The pipeline configuration object\n @param[in] mode The frame aggregation output mode to be set (default mode is @ref OB_FRAME_AGGREGATE_OUTPUT_ANY_SITUATION)\n @param[out] error Pointer to an error object that will be set if an error occurs."]
    pub fn ob_config_set_frame_aggregate_output_mode(
        config: *mut ob_config,
        mode: ob_frame_aggregate_output_mode,
        error: *mut *mut ob_error,
    );
}
unsafe extern "C" {
    #[doc = " @brief Get current camera parameters\n @attention If D2C is enabled, it will return the camera parameters after D2C, if not, it will return to the default parameters\n\n @param[in] pipeline pipeline object\n @param[out] error Log error messages\n @return ob_camera_param The camera internal parameters"]
    pub fn ob_pipeline_get_camera_param(
        pipeline: *mut ob_pipeline,
        error: *mut *mut ob_error,
    ) -> ob_camera_param;
}
unsafe extern "C" {
    #[doc = " @brief Get the current camera parameters\n\n @param[in] pipeline pipeline object\n @param[in] colorWidth color width\n @param[in] colorHeight color height\n @param[in] depthWidth depth width\n @param[in] depthHeight depth height\n @param[out] error Log error messages\n @return ob_camera_param returns camera internal parameters"]
    pub fn ob_pipeline_get_camera_param_with_profile(
        pipeline: *mut ob_pipeline,
        colorWidth: u32,
        colorHeight: u32,
        depthWidth: u32,
        depthHeight: u32,
        error: *mut *mut ob_error,
    ) -> ob_camera_param;
}
unsafe extern "C" {
    #[doc = " @brief Get device calibration parameters with the specified configuration\n\n @param[in] pipeline pipeline object\n @param[in] config The pipeline configuration\n @param[out] error Log error messages\n @return ob_calibration_param The calibration parameters"]
    pub fn ob_pipeline_get_calibration_param(
        pipeline: *mut ob_pipeline,
        config: *mut ob_config,
        error: *mut *mut ob_error,
    ) -> ob_calibration_param;
}
unsafe extern "C" {
    #[doc = " @brief Get the type of the sensor.\n\n @param[in] sensor The sensor object.\n @param[out] error Logs error messages.\n @return The sensor type."]
    pub fn ob_sensor_get_type(
        sensor: *const ob_sensor,
        error: *mut *mut ob_error,
    ) -> ob_sensor_type;
}
unsafe extern "C" {
    #[doc = " @brief Get a list of all supported stream profiles.\n\n @param[in] sensor The sensor object.\n @param[out] error Logs error messages.\n @return A list of stream profiles."]
    pub fn ob_sensor_get_stream_profile_list(
        sensor: *const ob_sensor,
        error: *mut *mut ob_error,
    ) -> *mut ob_stream_profile_list;
}
unsafe extern "C" {
    #[doc = " @brief Open the current sensor and set the callback data frame.\n\n @param[in] sensor The sensor object.\n @param[in] profile The stream configuration information.\n @param[in] callback The callback function triggered when frame data arrives.\n @param[in] user_data Any user data to pass in and get from the callback.\n @param[out] error Logs error messages."]
    pub fn ob_sensor_start(
        sensor: *mut ob_sensor,
        profile: *const ob_stream_profile,
        callback: ob_frame_callback,
        user_data: *mut ::std::os::raw::c_void,
        error: *mut *mut ob_error,
    );
}
unsafe extern "C" {
    #[doc = " @brief Stop the sensor stream.\n\n @param[in] sensor The sensor object.\n @param[out] error Logs error messages."]
    pub fn ob_sensor_stop(sensor: *mut ob_sensor, error: *mut *mut ob_error);
}
unsafe extern "C" {
    #[doc = " @brief Switch resolutions.\n\n @param[in] sensor The sensor object.\n @param[in] profile The stream configuration information.\n @param[out] error Logs error messages."]
    pub fn ob_sensor_switch_profile(
        sensor: *mut ob_sensor,
        profile: *mut ob_stream_profile,
        error: *mut *mut ob_error,
    );
}
unsafe extern "C" {
    #[doc = " @brief Delete a sensor object.\n\n @param[in] sensor The sensor object to delete.\n @param[out] error Logs error messages."]
    pub fn ob_delete_sensor(sensor: *mut ob_sensor, error: *mut *mut ob_error);
}
unsafe extern "C" {
    #[doc = " @brief  Create a list of recommended filters for the specified sensor.\n\n @param[in] sensor The ob_sensor object.\n @param[out] error Pointer to an error object that will be set if an error occurs.\n\n @return ob_filter_list"]
    pub fn ob_sensor_create_recommended_filter_list(
        sensor: *const ob_sensor,
        error: *mut *mut ob_error,
    ) -> *mut ob_filter_list;
}
unsafe extern "C" {
    #[doc = " @brief Get the number of sensors in the sensor list.\n\n @param[in] sensor_list The list of sensor objects.\n @param[out] error Logs error messages.\n @return The number of sensors in the list."]
    pub fn ob_sensor_list_get_count(
        sensor_list: *const ob_sensor_list,
        error: *mut *mut ob_error,
    ) -> u32;
}
unsafe extern "C" {
    #[doc = " @brief Get the sensor type.\n\n @param[in] sensor_list The list of sensor objects.\n @param[in] index The index of the sensor on the list.\n @param[out] error Logs error messages.\n @return The sensor type."]
    pub fn ob_sensor_list_get_sensor_type(
        sensor_list: *const ob_sensor_list,
        index: u32,
        error: *mut *mut ob_error,
    ) -> ob_sensor_type;
}
unsafe extern "C" {
    #[doc = " @brief Get a sensor by sensor type.\n\n @param[in] sensor_list The list of sensor objects.\n @param[in] sensorType The sensor type to be obtained.\n @param[out] error Logs error messages.\n @return The sensor pointer. If the specified type of sensor does not exist, it will return null."]
    pub fn ob_sensor_list_get_sensor_by_type(
        sensor_list: *const ob_sensor_list,
        sensorType: ob_sensor_type,
        error: *mut *mut ob_error,
    ) -> *mut ob_sensor;
}
unsafe extern "C" {
    #[doc = " @brief Get a sensor by index number.\n\n @param[in] sensor_list The list of sensor objects.\n @param[in] index The index of the sensor on the list.\n @param[out] error Logs error messages.\n @return The sensor object."]
    pub fn ob_sensor_list_get_sensor(
        sensor_list: *const ob_sensor_list,
        index: u32,
        error: *mut *mut ob_error,
    ) -> *mut ob_sensor;
}
unsafe extern "C" {
    #[doc = " @brief Delete a list of sensor objects.\n\n @param[in] sensor_list The list of sensor objects to delete.\n @param[out] error Logs error messages."]
    pub fn ob_delete_sensor_list(sensor_list: *mut ob_sensor_list, error: *mut *mut ob_error);
}
unsafe extern "C" {
    #[doc = " @brief Create a stream profile object\n\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return ob_stream_profile* return the stream profile object"]
    pub fn ob_create_stream_profile(
        type_: ob_stream_type,
        format: ob_format,
        error: *mut *mut ob_error,
    ) -> *mut ob_stream_profile;
}
unsafe extern "C" {
    #[doc = " @brief Create a video stream profile object\n\n @param[in] type Stream type\n @param[in] format Stream format\n @param[in] width Stream width\n @param[in] height Stream height\n @param[in] fps Stream frame rate\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return ob_stream_profile* return the video stream profile object"]
    pub fn ob_create_video_stream_profile(
        type_: ob_stream_type,
        format: ob_format,
        width: u32,
        height: u32,
        fps: u32,
        error: *mut *mut ob_error,
    ) -> *mut ob_stream_profile;
}
unsafe extern "C" {
    #[doc = " @brief Create a accel stream profile object\n\n @param[in] full_scale_range Accel full scale range\n @param[in] sample_rate Accel sample rate\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return ob_stream_profile* return the accel stream profile object"]
    pub fn ob_create_accel_stream_profile(
        full_scale_range: ob_accel_full_scale_range,
        sample_rate: ob_accel_sample_rate,
        error: *mut *mut ob_error,
    ) -> *mut ob_stream_profile;
}
unsafe extern "C" {
    #[doc = " @brief Create a gyro stream profile object\n\n @param[in] full_scale_range Gyro full scale range\n @param[in] sample_rate Gyro sample rate\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return ob_stream_profile* return the accel stream profile object"]
    pub fn ob_create_gyro_stream_profile(
        full_scale_range: ob_gyro_full_scale_range,
        sample_rate: ob_gyro_sample_rate,
        error: *mut *mut ob_error,
    ) -> *mut ob_stream_profile;
}
unsafe extern "C" {
    #[doc = " @brief Copy the stream profile object from an other stream profile object\n\n @param[in] srcProfile Source stream profile object\n @param[out] error Pointer to an error object that will be set if an error occurs.\n\n @return ob_stream_profile* return the new stream profile object"]
    pub fn ob_create_stream_profile_from_other_stream_profile(
        srcProfile: *const ob_stream_profile,
        error: *mut *mut ob_error,
    ) -> *mut ob_stream_profile;
}
unsafe extern "C" {
    #[doc = " @brief Copy the stream profile object with a new format object\n\n @param[in] profile Stream profile object\n @param[in] new_format New format\n @param[out] error Pointer to an error object that will be set if an error occurs.\n\n @return ob_stream_profile* return the new stream profile object with the new format"]
    pub fn ob_create_stream_profile_with_new_format(
        profile: *const ob_stream_profile,
        new_format: ob_format,
        error: *mut *mut ob_error,
    ) -> *mut ob_stream_profile;
}
unsafe extern "C" {
    #[doc = " @brief Delete the stream configuration.\n\n @param[in] profile Stream profile object .\n @param[out] error Pointer to an error object that will be set if an error occurs."]
    pub fn ob_delete_stream_profile(profile: *const ob_stream_profile, error: *mut *mut ob_error);
}
unsafe extern "C" {
    #[doc = " @brief Get stream profile format\n\n @param[in] profile Stream profile object\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return ob_format return the format of the stream"]
    pub fn ob_stream_profile_get_format(
        profile: *const ob_stream_profile,
        error: *mut *mut ob_error,
    ) -> ob_format;
}
unsafe extern "C" {
    #[doc = " @brief Set stream profile format\n\n @param[in] profile Stream profile object\n @param[in] format The format of the stream\n @param[out] error Pointer to an error object that will be set if an error occurs."]
    pub fn ob_stream_profile_set_format(
        profile: *mut ob_stream_profile,
        format: ob_format,
        error: *mut *mut ob_error,
    );
}
unsafe extern "C" {
    #[doc = " @brief Get stream profile type\n\n @param[in] profile Stream profile object\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return ob_stream_type stream type"]
    pub fn ob_stream_profile_get_type(
        profile: *const ob_stream_profile,
        error: *mut *mut ob_error,
    ) -> ob_stream_type;
}
unsafe extern "C" {
    #[doc = " @brief Set stream profile type\n\n @param[in] profile Stream profile object\n @param[in] type The type of the stream\n @param[out] error Pointer to an error object that will be set if an error occurs."]
    pub fn ob_stream_profile_set_type(
        profile: *const ob_stream_profile,
        type_: ob_stream_type,
        error: *mut *mut ob_error,
    );
}
unsafe extern "C" {
    #[doc = " @brief Get the extrinsic for source stream to target stream\n\n @param[in] source Source stream profile\n @param[in]  target Target stream profile\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return ob_extrinsic The extrinsic"]
    pub fn ob_stream_profile_get_extrinsic_to(
        source: *const ob_stream_profile,
        target: *mut ob_stream_profile,
        error: *mut *mut ob_error,
    ) -> ob_extrinsic;
}
unsafe extern "C" {
    #[doc = " @brief Set the extrinsic for source stream to target stream\n\n @param[in] source Stream profile object\n @param[in] target  Target stream type\n @param[in] extrinsic The extrinsic\n @param[out] error   Pointer to an error object that will be set if an error occurs."]
    pub fn ob_stream_profile_set_extrinsic_to(
        source: *mut ob_stream_profile,
        target: *const ob_stream_profile,
        extrinsic: ob_extrinsic,
        error: *mut *mut ob_error,
    );
}
unsafe extern "C" {
    #[doc = " @brief Set the extrinsic for source stream to target stream type\n\n @param[in] source Source stream profile\n @param[in]  type Target stream type\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return ob_extrinsic The extrinsic"]
    pub fn ob_stream_profile_set_extrinsic_to_type(
        source: *mut ob_stream_profile,
        type_: ob_stream_type,
        extrinsic: ob_extrinsic,
        error: *mut *mut ob_error,
    );
}
unsafe extern "C" {
    #[doc = " @brief Get the frame rate of the video stream\n\n @param[in] profile Stream profile object\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return uint32_t return the frame rate of the stream"]
    pub fn ob_video_stream_profile_get_fps(
        profile: *const ob_stream_profile,
        error: *mut *mut ob_error,
    ) -> u32;
}
unsafe extern "C" {
    #[doc = " @brief Get the width of the video stream\n\n @param[in] profile Stream profile object , If the profile is not a video stream configuration, an error will be returned\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return uint32_t return the width of the stream"]
    pub fn ob_video_stream_profile_get_width(
        profile: *const ob_stream_profile,
        error: *mut *mut ob_error,
    ) -> u32;
}
unsafe extern "C" {
    #[doc = " @brief Set the width of the video stream\n\n @param[in] profile Stream profile object , If the profile is not a video stream configuration, an error will be returned\n @param[in] width The width of the stream\n @param[out] error Pointer to an error object that will be set if an error occurs."]
    pub fn ob_video_stream_profile_set_width(
        profile: *mut ob_stream_profile,
        width: u32,
        error: *mut *mut ob_error,
    );
}
unsafe extern "C" {
    #[doc = " @brief Get the height of the video stream\n\n @param[in] profile Stream profile object , If the profile is not a video stream configuration, an error will be returned\n @param[out] error  Pointer to an error object that will be set if an error occurs.\n @return uint32_t return the height of the stream"]
    pub fn ob_video_stream_profile_get_height(
        profile: *const ob_stream_profile,
        error: *mut *mut ob_error,
    ) -> u32;
}
unsafe extern "C" {
    #[doc = " @brief Set the height of the video stream\n\n @param[in] profile Stream profile object , If the profile is not a video stream configuration, an error will be returned\n @param[in] height The height of the stream\n @param[out] error  Pointer to an error object that will be set if an error occurs."]
    pub fn ob_video_stream_profile_set_height(
        profile: *mut ob_stream_profile,
        height: u32,
        error: *mut *mut ob_error,
    );
}
unsafe extern "C" {
    #[doc = " @brief Get the intrinsic of the video stream profile\n\n @param[in]  profile Stream profile object\n @param[out] error   Pointer to an error object that will be set if an error occurs.\n @return ob_camera_intrinsic Return the intrinsic of the stream"]
    pub fn ob_video_stream_profile_get_intrinsic(
        profile: *const ob_stream_profile,
        error: *mut *mut ob_error,
    ) -> ob_camera_intrinsic;
}
unsafe extern "C" {
    #[doc = " @brief Set the intrinsic of the video stream profile\n\n @param[in] profile Stream profile object\n @param[in]  intrinsic The intrinsic of the stream\n @param[out] error   Pointer to an error object that will be set if an error occurs."]
    pub fn ob_video_stream_profile_set_intrinsic(
        profile: *mut ob_stream_profile,
        intrinsic: ob_camera_intrinsic,
        error: *mut *mut ob_error,
    );
}
unsafe extern "C" {
    #[doc = " @brief Get the distortion of the video stream profile\n\n @param[in]  profile Stream profile object\n @param[out] error   Pointer to an error object that will be set if an error occurs.\n @return ob_camera_distortion Return the distortion of the stream"]
    pub fn ob_video_stream_profile_get_distortion(
        profile: *const ob_stream_profile,
        error: *mut *mut ob_error,
    ) -> ob_camera_distortion;
}
unsafe extern "C" {
    #[doc = " @brief Set the distortion of the video stream profile\n\n @param[in] profile Stream profile object\n @param[in]  distortion The distortion of the stream\n @param[out] error   Pointer to an error object that will be set if an error occurs."]
    pub fn ob_video_stream_profile_set_distortion(
        profile: *mut ob_stream_profile,
        distortion: ob_camera_distortion,
        error: *mut *mut ob_error,
    );
}
unsafe extern "C" {
    #[doc = " @brief Get the process param of the disparity stream\n\n @param[in]  profile Stream profile object\n @param[out] error   Pointer to an error object that will be set if an error occurs.\n @return ob_disparity_param Return the disparity process param of the stream"]
    pub fn ob_disparity_based_stream_profile_get_disparity_param(
        profile: *const ob_stream_profile,
        error: *mut *mut ob_error,
    ) -> ob_disparity_param;
}
unsafe extern "C" {
    #[doc = " @brief Set the disparity process param of the disparity stream.\n\n @param[in] profile Stream profile object. If the profile is not for the disparity stream, an error will be returned.\n @param[in] param The disparity process param of the disparity stream.\n @param[out] error Pointer to an error object that will be set if an error occurs."]
    pub fn ob_disparity_based_stream_profile_set_disparity_param(
        profile: *mut ob_stream_profile,
        param: ob_disparity_param,
        error: *mut *mut ob_error,
    );
}
unsafe extern "C" {
    #[doc = " @brief Get the full-scale range of the accelerometer stream.\n\n @param[in] profile Stream profile object. If the profile is not for the accelerometer stream, an error will be returned.\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return The full-scale range of the accelerometer stream."]
    pub fn ob_accel_stream_profile_get_full_scale_range(
        profile: *const ob_stream_profile,
        error: *mut *mut ob_error,
    ) -> ob_accel_full_scale_range;
}
unsafe extern "C" {
    #[doc = " @brief Get the sampling frequency of the accelerometer frame.\n\n @param[in] profile Stream profile object. If the profile is not for the accelerometer stream, an error will be returned.\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return The sampling frequency of the accelerometer frame."]
    pub fn ob_accel_stream_profile_get_sample_rate(
        profile: *const ob_stream_profile,
        error: *mut *mut ob_error,
    ) -> ob_accel_sample_rate;
}
unsafe extern "C" {
    #[doc = " @brief Get the intrinsic of the accelerometer stream.\n\n @param[in]  profile Stream profile object. If the profile is not for the accelerometer stream, an error will be returned.\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return ob_accel_intrinsic Return the intrinsic of the accelerometer stream."]
    pub fn ob_accel_stream_profile_get_intrinsic(
        profile: *const ob_stream_profile,
        error: *mut *mut ob_error,
    ) -> ob_accel_intrinsic;
}
unsafe extern "C" {
    #[doc = " @brief Set the intrinsic of the accelerometer stream.\n\n @param[in] profile Stream profile object. If the profile is not for the accelerometer stream, an error will be returned.\n @param[in]  intrinsic The intrinsic of the accelerometer stream.\n @param[out] error Pointer to an error object that will be set if an error occurs."]
    pub fn ob_accel_stream_profile_set_intrinsic(
        profile: *mut ob_stream_profile,
        intrinsic: ob_accel_intrinsic,
        error: *mut *mut ob_error,
    );
}
unsafe extern "C" {
    #[doc = " @brief Get the full-scale range of the gyroscope stream.\n\n @param[in] profile Stream profile object. If the profile is not for the gyroscope stream, an error will be returned.\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return The full-scale range of the gyroscope stream."]
    pub fn ob_gyro_stream_profile_get_full_scale_range(
        profile: *const ob_stream_profile,
        error: *mut *mut ob_error,
    ) -> ob_gyro_full_scale_range;
}
unsafe extern "C" {
    #[doc = " @brief Get the sampling frequency of the gyroscope stream.\n\n @param[in] profile Stream profile object. If the profile is not for the gyroscope stream, an error will be returned.\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return The sampling frequency of the gyroscope stream."]
    pub fn ob_gyro_stream_profile_get_sample_rate(
        profile: *const ob_stream_profile,
        error: *mut *mut ob_error,
    ) -> ob_gyro_sample_rate;
}
unsafe extern "C" {
    #[doc = " @brief Get the intrinsic of the gyroscope stream.\n\n @param[in]  profile Stream profile object. If the profile is not for the gyroscope stream, an error will be returned.\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return ob_gyro_intrinsic Return the intrinsic of the gyroscope stream."]
    pub fn ob_gyro_stream_get_intrinsic(
        profile: *const ob_stream_profile,
        error: *mut *mut ob_error,
    ) -> ob_gyro_intrinsic;
}
unsafe extern "C" {
    #[doc = " @brief Set the intrinsic of the gyroscope stream.\n\n @param[in] profile Stream profile object. If the profile is not for the gyroscope stream, an error will be returned.\n @param[in]  intrinsic The intrinsic of the gyroscope stream.\n @param[out] error Pointer to an error object that will be set if an error occurs."]
    pub fn ob_gyro_stream_set_intrinsic(
        profile: *mut ob_stream_profile,
        intrinsic: ob_gyro_intrinsic,
        error: *mut *mut ob_error,
    );
}
unsafe extern "C" {
    #[doc = " @brief Get the number of StreamProfile lists.\n\n @param[in] profile_list StreamProfile list.\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return The number of StreamProfile lists."]
    pub fn ob_stream_profile_list_get_count(
        profile_list: *const ob_stream_profile_list,
        error: *mut *mut ob_error,
    ) -> u32;
}
unsafe extern "C" {
    #[doc = " @brief Get the corresponding StreamProfile by subscripting.\n\n @attention The stream profile returned by this function should be deleted by calling @ref ob_delete_stream_profile() when it is no longer needed.\n\n @param[in] profile_list StreamProfile lists.\n @param[in] index Index.\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return The matching profile."]
    pub fn ob_stream_profile_list_get_profile(
        profile_list: *const ob_stream_profile_list,
        index: ::std::os::raw::c_int,
        error: *mut *mut ob_error,
    ) -> *mut ob_stream_profile;
}
unsafe extern "C" {
    #[doc = " @brief Match the corresponding ob_stream_profile through the passed parameters. If there are multiple matches,\n the first one in the list will be returned by default. If no matched profile is found, an error will be returned.\n\n @attention The stream profile returned by this function should be deleted by calling @ref ob_delete_stream_profile() when it is no longer needed.\n\n @param[in] profile_list Resolution list.\n @param[in] width Width. If you don't need to add matching conditions, you can pass OB_WIDTH_ANY.\n @param[in] height Height. If you don't need to add matching conditions, you can pass OB_HEIGHT_ANY.\n @param[in] format Format. If you don't need to add matching conditions, you can pass OB_FORMAT_ANY.\n @param[in] fps Frame rate. If you don't need to add matching conditions, you can pass OB_FPS_ANY.\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return The matching profile."]
    pub fn ob_stream_profile_list_get_video_stream_profile(
        profile_list: *const ob_stream_profile_list,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        format: ob_format,
        fps: ::std::os::raw::c_int,
        error: *mut *mut ob_error,
    ) -> *mut ob_stream_profile;
}
unsafe extern "C" {
    #[doc = " @brief Match the corresponding ob_stream_profile through the passed parameters. If there are multiple matches,\n the first one in the list will be returned by default. If no matched profile is found, an error will be returned.\n\n @attention The stream profile returned by this function should be deleted by calling @ref ob_delete_stream_profile() when it is no longer needed.\n\n @param[in] profile_list Resolution list.\n @param[in] full_scale_range Full-scale range. If you don't need to add matching conditions, you can pass 0.\n @param[in] sample_rate Sample rate. If you don't need to add matching conditions, you can pass 0.\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return The matching profile."]
    pub fn ob_stream_profile_list_get_accel_stream_profile(
        profile_list: *const ob_stream_profile_list,
        full_scale_range: ob_accel_full_scale_range,
        sample_rate: ob_accel_sample_rate,
        error: *mut *mut ob_error,
    ) -> *mut ob_stream_profile;
}
unsafe extern "C" {
    #[doc = " @brief Match the corresponding ob_stream_profile through the passed parameters. If there are multiple matches,\n the first one in the list will be returned by default. If no matched profile is found, an error will be returned.\n\n @attention The stream profile returned by this function should be deleted by calling @ref ob_delete_stream_profile() when it is no longer needed.\n\n @param[in] profile_list Resolution list.\n @param[in] full_scale_range Full-scale range. If you don't need to add matching conditions, you can pass 0.\n @param[in] sample_rate Sample rate. If you don't need to add matching conditions, you can pass 0.\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return The matching profile."]
    pub fn ob_stream_profile_list_get_gyro_stream_profile(
        profile_list: *const ob_stream_profile_list,
        full_scale_range: ob_gyro_full_scale_range,
        sample_rate: ob_gyro_sample_rate,
        error: *mut *mut ob_error,
    ) -> *mut ob_stream_profile;
}
unsafe extern "C" {
    #[doc = " @brief Delete the stream profile list.\n\n @param[in] profile_list Stream configuration list.\n @param[out] error Pointer to an error object that will be set if an error occurs."]
    pub fn ob_delete_stream_profile_list(
        profile_list: *const ob_stream_profile_list,
        error: *mut *mut ob_error,
    );
}
unsafe extern "C" {
    #[doc = " @brief Get the SDK version number.\n\n @return int The SDK version number."]
    pub fn ob_get_version() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Get the SDK major version number.\n\n @return int The SDK major version number."]
    pub fn ob_get_major_version() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Get the SDK minor version number.\n\n @return int The SDK minor version number."]
    pub fn ob_get_minor_version() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Get the SDK patch version number.\n\n @return int The SDK patch version number."]
    pub fn ob_get_patch_version() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Get the SDK stage version.\n @attention The returned char* does not need to be freed.\n\n @return const char* The SDK stage version."]
    pub fn ob_get_stage_version() -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " @brief Convert OBFormat to \" char* \" type and then return.\n\n @param[in] type OBFormat type.\n @return OBFormat of \"char*\" type."]
    pub fn ob_format_type_to_string(type_: OBFormat) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " @brief Convert OBFrameType to \" char* \" type and then return.\n\n @param[in] type OBFrameType type.\n @return OBFrameType of \"char*\" type."]
    pub fn ob_frame_type_to_string(type_: OBFrameType) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " @brief Convert OBStreamType to \" char* \" type and then return.\n\n @param[in] type OBStreamType type.\n @return OBStreamType of \"char*\" type."]
    pub fn ob_stream_type_to_string(type_: OBStreamType) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " @brief Convert OBSensorType to \" char* \" type and then return.\n\n @param[in] type OBSensorType type.\n @return OBSensorType of \"char*\" type."]
    pub fn ob_sensor_type_to_string(type_: OBSensorType) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " @brief Convert OBIMUSampleRate to \" char* \" type and then return.\n\n @param[in] type OBIMUSampleRate type.\n @return OBIMUSampleRate of \"char*\" type."]
    pub fn ob_imu_rate_type_to_string(type_: OBIMUSampleRate) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " @brief Convert OBGyroFullScaleRange to \" char* \" type and then return.\n\n @param[in] type OBGyroFullScaleRange type.\n @return OBGyroFullScaleRange of \"char*\" type."]
    pub fn ob_gyro_range_type_to_string(
        type_: OBGyroFullScaleRange,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " @brief Convert OBAccelFullScaleRange to \" char* \" type and then return.\n\n @param[in] type OBAccelFullScaleRange type.\n @return OBAccelFullScaleRange of \"char*\" type."]
    pub fn ob_accel_range_type_to_string(
        type_: OBAccelFullScaleRange,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " @brief Convert OBFrameMetadataType to \" char* \" type and then return.\n\n @param[in] type OBFrameMetadataType type.\n @return OBFrameMetadataType of \"char*\" type."]
    pub fn ob_meta_data_type_to_string(type_: OBFrameMetadataType)
        -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " @brief Convert OBStreamType to OBSensorType.\n\n @param[in] type The sensor type to convert.\n @return OBStreamType The corresponding stream type."]
    pub fn ob_sensor_type_to_stream_type(type_: OBSensorType) -> OBStreamType;
}
unsafe extern "C" {
    #[doc = " @brief Convert OBFormat to \" char* \" type and then return.\n\n @param format The OBFormat to convert.\n @return The string."]
    pub fn ob_format_to_string(format: OBFormat) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " @brief Create a recording device for the specified device with a specified file path and compression enabled.\n\n @param[in] device The device to record.\n @param[in] file_path The file path to record to.\n @param[in] compression_enabled Whether to enable compression for the recording.\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return A pointer to the newly created recording device, or NULL if an error occurred."]
    pub fn ob_create_record_device(
        device: *mut ob_device,
        file_path: *const ::std::os::raw::c_char,
        compression_enabled: bool,
        error: *mut *mut ob_error,
    ) -> *mut ob_record_device;
}
unsafe extern "C" {
    #[doc = " @brief Delete a recording device.\n\n @param[in] recorder The recording device to delete.\n @param[out] error Pointer to an error object that will be set if an error occurs."]
    pub fn ob_delete_record_device(recorder: *mut ob_record_device, error: *mut *mut ob_error);
}
unsafe extern "C" {
    #[doc = " @brief Pause recording on the specified recording device.\n\n @param[in] recorder The recording device to pause.\n @param[out] error Pointer to an error object that will be set if an error occurs."]
    pub fn ob_record_device_pause(recorder: *mut ob_record_device, error: *mut *mut ob_error);
}
unsafe extern "C" {
    #[doc = " @brief Resume recording on the specified recording device.\n\n @param[in] recorder The recording device to resume.\n @param[out] error Pointer to an error object that will be set if an error occurs."]
    pub fn ob_record_device_resume(recorder: *mut ob_record_device, error: *mut *mut ob_error);
}
unsafe extern "C" {
    #[doc = " @brief Create a playback device for the specified file path.\n\n @param[in] file_path The file path to playback from.\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return A pointer to the newly created playback device, or NULL if an error occurred."]
    pub fn ob_create_playback_device(
        file_path: *const ::std::os::raw::c_char,
        error: *mut *mut ob_error,
    ) -> *mut ob_device;
}
unsafe extern "C" {
    #[doc = " @brief Pause playback on the specified playback device.\n\n @param[in] player The playback device to pause.\n @param[out] error Pointer to an error object that will be set if an error occurs."]
    pub fn ob_playback_device_pause(player: *mut ob_device, error: *mut *mut ob_error);
}
unsafe extern "C" {
    #[doc = " @brief Resume playback on the specified playback device.\n\n @param[in] player The playback device to resume.\n @param[out] error Pointer to an error object that will be set if an error occurs."]
    pub fn ob_playback_device_resume(player: *mut ob_device, error: *mut *mut ob_error);
}
unsafe extern "C" {
    #[doc = " @brief Set the playback to a specified time point of the played data.\n\n @param[in] player The playback device to set the position for.\n @param[in] timestamp The position to set the playback to, in milliseconds.\n @param[out] error Pointer to an error object that will be set if an error occurs."]
    pub fn ob_playback_device_seek(
        player: *mut ob_device,
        timestamp: u64,
        error: *mut *mut ob_error,
    );
}
unsafe extern "C" {
    #[doc = " @brief Set the playback to a specified time point of the played data.\n\n @param[in] player The playback device to set the position for.\n @param[in] rate The playback rate to set.\n @param[out] error Pointer to an error object that will be set if an error occurs."]
    pub fn ob_playback_device_set_playback_rate(
        player: *mut ob_device,
        rate: f32,
        error: *mut *mut ob_error,
    );
}
unsafe extern "C" {
    #[doc = " @brief Get the current playback status of the played data.\n\n @param[in] player The playback device to get the status for.\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return The current playback status of the played data."]
    pub fn ob_playback_device_get_current_playback_status(
        player: *mut ob_device,
        error: *mut *mut ob_error,
    ) -> ob_playback_status;
}
unsafe extern "C" {
    #[doc = " @brief Set a callback function to receive playback status updates.\n\n @param[in] player The playback device to set the callback for.\n @param[in] callback The callback function to receive playback status updates.\n @param[out] error Pointer to an error object that will be set if an error occurs."]
    pub fn ob_playback_device_set_playback_status_changed_callback(
        player: *mut ob_device,
        callback: ob_playback_status_changed_callback,
        user_data: *mut ::std::os::raw::c_void,
        error: *mut *mut ob_error,
    );
}
unsafe extern "C" {
    #[doc = " @brief Get the current playback position of the played data.\n\n @param[in] player The playback device to get the position for.\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return The current playback position of the played data, in milliseconds."]
    pub fn ob_playback_device_get_position(
        player: *mut ob_device,
        error: *mut *mut ob_error,
    ) -> u64;
}
unsafe extern "C" {
    #[doc = " @brief Get the duration of the played data.\n\n @param[in] player The playback device to get the duration for.\n @param[out] error Pointer to an error object that will be set if an error occurs.\n @return The duration of the played data, in milliseconds."]
    pub fn ob_playback_device_get_duration(
        player: *mut ob_device,
        error: *mut *mut ob_error,
    ) -> u64;
}
